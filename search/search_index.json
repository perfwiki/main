{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Main Page","text":""},{"location":"#perf-linux-profiling-with-performance-counters","title":"<code>perf</code>: Linux profiling with performance counters","text":"<p>...More than just counters...</p>"},{"location":"#introduction","title":"Introduction","text":"<p>This is the wiki page for the Linux <code>perf</code> command, also called perf_events. <code>perf</code> is powerful: it can instrument CPU performance counters, tracepoints, kprobes, and uprobes (dynamic tracing). It is capable of lightweight profiling. It is also included in the Linux kernel, under <code>tools/perf</code>, and is frequently updated and enhanced.</p> <p><code>perf</code> began as a tool for using the performance counters subsystem in Linux, and has had various enhancements to add tracing capabilities.</p> <p>Performance counters are CPU hardware registers that count hardware events such as instructions executed, cache-misses suffered, or branches mispredicted. They form a basis for profiling applications to trace dynamic control flow and identify hotspots. <code>perf</code> provides rich generalized abstractions over hardware specific capabilities. Among others, it provides per task, per CPU and per-workload counters, sampling on top of these and source code event annotation.</p> <p>Tracepoints are instrumentation points placed at logical locations in code, such as for system calls, TCP/IP events, file system operations, etc. These have negligible overhead when not in use, and can be enabled by the <code>perf</code> command to collect information including timestamps and stack traces. <code>perf</code> can also dynamically create tracepoints using the kprobes and uprobes frameworks, for kernel and userspace dynamic tracing. The possibilities with these are endless.</p> <p>The userspace <code>perf</code> command present a simple to use interface with commands like:</p> <ul> <li><code>perf stat</code>: obtain event counts</li> <li><code>perf record</code>: record events for later reporting</li> <li><code>perf report</code>: break down events by process, function, etc.</li> <li><code>perf annotate</code>: annotate assembly or source code with event counts</li> <li><code>perf top</code>: see live event count </li> <li><code>perf bench</code>: run different kernel microbenchmarks</li> </ul> <p>To learn more, see the examples in the Tutorial or how to do a Top-Down Analysis.</p> <p>To ask questions, report bugs/issues mail the mailing list\ud83d\udce8 or use bugzilla\ud83d\udc1e.</p> <p>In order to subscribe to receive perf mailing lists messages via email you will need to send a message to a special subscription address of the list.</p> <ul> <li> <p>to receive an\u00a0individual copy of every message sent to the list, send an email to:</p> <ul> <li>linux-perf-users+subscribe@vger.kernel.org</li> </ul> </li> <li> <p>to receive a\u00a0daily digest of all messages sent to the list, send an email to:</p> <ul> <li>linux-perf-users+subscribe-digest@vger.kernel.org</li> </ul> </li> </ul>"},{"location":"#wiki-contents","title":"Wiki Contents","text":"<ul> <li>Tutorial</li> <li>Top-Down Analysis</li> <li>Kernel lock contention</li> <li>Todo</li> <li>Hardware Reference</li> <li>perf_events kernel ABI</li> <li>perf tools support for Intel\u00ae Processor Trace</li> <li>Useful Links: How perf tools work, examples of usage to solve real problems, observability articles, hardware manuals</li> <li>Glossary</li> <li>Latest Manual Pages</li> <li>Development</li> </ul>"},{"location":"#google-summer-of-code","title":"Google Summer of Code","text":"<p>As part of the Linux Foundation the perf tool has participated in the Google Summer-of-Code since 2021. Check out the 2024 process.</p>"},{"location":"arm64-cross-compilation-dockerfile/","title":"Arm64 cross-compilation Dockerfile","text":"<p>Save this as \"Dockerfile\" and follow the readme.</p> <pre><code># Readme\n# ======\n#\n# This is a Dockerfile that cross compiles an arm64 Perf from an x64\n# host. It uses Ubuntu 20 as a base which has libc 2.31, which means\n# the binary will run on any system that has libc 2.31+ (Provided there\n# are no conflicting dependencies, but Ubuntu, Debian, Fedora etc are\n# all likely to work).\n#\n# To build\n# ========\n#\n# Replace &lt;your_linux_checkout&gt; and run the following commands. The Perf\n# build and libtraceevent will be placed in the ./build folder.\n#\n# $ cd &lt;this_folder&gt;\n# $ docker build -t perf-arm64 --network=host .\n# $ docker run -v &lt;your_linux_checkout&gt;:/linux -v ./build:/build -v ./build-static:/build-static perf-arm64\n#\n# To copy and run the dynamic build\n# =================================\n#\n# $ scp ./build/perf ./build/perf-iostat ./build/perf-archive &lt;target_system&gt;:~\n# $ scp ./build/libtraceevent* &lt;target_system&gt;:/usr/lib/aarch64-linux-gnu/ # See NOTE below\n# $ ssh &lt;target_system&gt;\n# $ apt install &lt;any missing library&gt;\n# $ ~/perf record ...\n#\n# To copy and run the static build\n# ================================\n# $ scp ./build-static/perf ./build-static/perf-iostat ./build-static/perf-archive &lt;target_system&gt;:~\n# $ ssh &lt;target_system&gt;\n# $ ~/perf record ...\n#\n# NOTE:\n# If the target is more recent (Ubuntu 22.04+ for example), you should\n# skip copying libtraceevent and apt install it instead.\n#\n# TODO:\n# The Perf python library ends up with x86 stuff in the name, but this\n# isn't really used by Perf anwyay so can be ignored for now.\n#\nFROM ubuntu:20.04\n\n# Stop some packages prompting for user configuration\nENV DEBIAN_FRONTEND=noninteractive\n\n# Completely replace sources.list\n#\n# Make sure regular sources are prefixed with amd64 so it doesn't try to\n# pull arm64 packages where they don't exist. And add the ports.ubuntu\n# sources for arm64.\nRUN echo \"deb [arch=amd64] http://archive.ubuntu.com/ubuntu focal main restricted universe multiverse\" &gt; /etc/apt/sources.list &amp;&amp; \\\n    echo \"deb [arch=amd64] http://archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse\" &gt;&gt; /etc/apt/sources.list &amp;&amp; \\\n    echo \"deb [arch=amd64] http://archive.ubuntu.com/ubuntu focal-security main restricted universe multiverse\" &gt;&gt; /etc/apt/sources.list &amp;&amp; \\\n    echo \"deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports focal main restricted universe multiverse\" &gt;&gt; /etc/apt/sources.list &amp;&amp; \\\n    echo \"deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports focal-updates main restricted universe multiverse\" &gt;&gt; /etc/apt/sources.list &amp;&amp; \\\n    echo \"deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports focal-security main restricted universe multiverse\" &gt;&gt; /etc/apt/sources.list\n\nRUN dpkg --add-architecture arm64\nRUN apt-get update &amp;&amp; apt-get upgrade -y\n\n# Native build stuff\nRUN apt-get install -y \\\n    gcc-aarch64-linux-gnu g++-aarch64-linux-gnu \\\n    binutils-aarch64-linux-gnu flex \\\n    bison make \\\n    pkg-config-aarch64-linux-gnu python3 \\\n    python3-dev python3-setuptools \\\n    git dpkg-dev\n\n# Arm64 Perf dependencies\nRUN apt-get install -y \\\n    libelf-dev:arm64 libdwarf-dev:arm64 \\\n    libdw-dev:arm64 libaudit-dev:arm64 \\\n    libcap-dev:arm64 libelf-dev:arm64 \\\n    libunwind-dev:arm64 libzstd-dev:arm64 \\\n    libfl-dev:arm64 libbison-dev:arm64 \\\n    libpython3-dev:arm64 libslang2-dev:arm64 \\\n    libnuma-dev:arm64 libssl-dev:arm64 \\\n    libbz2-dev:arm64\n\n# Build and install libtraceevent since there is no package on Ubuntu 20.04\nWORKDIR /\nRUN git clone --depth=1 https://git.kernel.org/pub/scm/libs/libtrace/libtraceevent.git/\nWORKDIR /libtraceevent\nRUN make CROSS_COMPILE=aarch64-linux-gnu- prefix=/usr/aarch64-linux-gnu \\\n    libdir_relative=lib pkgconfig_dir=/usr/lib/aarch64-linux-gnu/pkgconfig install\nRUN ldconfig\n\n# Install libtraceevent to the /build dir so it can be copied to the\n# target system, then build both static and dynamic versions of Perf.\nCMD make CROSS_COMPILE=aarch64-linux-gnu- prefix=/build \\\n    libdir_relative= pkgconfig_dir=/usr/lib/aarch64-linux-gnu/pkgconfig install &amp;&amp; \\\n    cd /linux &amp;&amp; \\\n    make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=/build -C tools/perf &amp;&amp; \\\n    make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=/build-static LDFLAGS=\"-static\" EXTRA_PERFLIBS=\"-lexpat\" -C tools/perf\n</code></pre>"},{"location":"development/","title":"Development","text":""},{"location":"development/#development_1","title":"Development","text":""},{"location":"development/#installation-guide","title":"Installation Guide","text":"<p>You'll need to install <code>perf</code> in your system. <code>perf</code> uses CPU performance counters( Performance Monitoring Counters or PMCs). </p> <p>1) Install Required Packages like libelf-dev libdw-dev binutils-dev libaudit-dev by using the following command </p> <pre><code> sudo apt-get install build-essential libelf-dev libdw-dev binutils-dev \n libaudit-dev libtraceevent-dev systemtap-sdt-dev libunwind-dev libslang2-dev libperl-dev libzstd-dev libbabeltrace-ctf-dev flex bison \n</code></pre> <p>2) Download the Source code for perf-tools v6.3 using the following command</p> <pre><code> git clone https://git.kernel.org/pub/scm/linux/kernel/git/perf/perf-tools-next.git/\n</code></pre> <p>3) Install <code>perf</code>. <code>perf</code> command is available in packages linux-tools-common, linux-intel-iotg-tools-common, etc. Hence, install any of these. </p> <p>4) Run <code>make</code> command to build the project</p> <pre><code>- 4.1) It may show an error since the config file is not set and has to be changed. Run the following command.\n</code></pre> <p><code>make xconfig</code> </p> <pre><code>- 4.2) We will also need to install qt5 for this. \nInstall it using `sudo apt-get install qtbase5-dev` OR `sudo apt install qt5*` and set the path using \n```sh\nexport PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/share/pkgconfig\n```\n\n- 4.3) Check if qt5 has been installed properly using *qmake --version*\n\n- 4.4) You might need to set `kernel.perf_event_paranoid = -1` because the `perf record` command may fail due to restricted access to performance monitoring features on your system.\n```sh\nsudo sysctl -w kernel.perf_event_paranoid=-1\n```\n\nNote: this should not be done in production environment\n\n- 4.4) Now, Finally run *make xconfig* and it will work properly.\n</code></pre> <p>5) Go to the root directory of the kernel and run <code>perf test</code>. You will see tests  passing, skipping, or failing.</p>"},{"location":"development/#maintainer-trees","title":"Maintainer Trees","text":""},{"location":"development/#kernel","title":"Kernel","text":"<p>tip.git perf/core</p>"},{"location":"development/#tool","title":"Tool","text":"<p>perf-tools for the current release. Merged to linux-next.</p> <p>perf-tools-next staging for the next release.</p>"},{"location":"development/#design","title":"Design","text":"<p>design.txt</p>"},{"location":"development/#latest-source-tar-balls","title":"Latest source tar balls","text":"<p>mirror</p>"},{"location":"development/#cross-compilation","title":"Cross Compilation","text":"<p>Arm64 cross-compilation Dockerfile|Arm64 cross-compilation Dockerfile for an example of how to cross-compile for Arm on x86</p>"},{"location":"download-and-build/","title":"Downloading and building the latest perf tools","text":"<p>The example below is for a Debian-based system, specifically Ubuntu 20.04 in this case, although there is a package list also for Fedora.  We will need 4G of disk space.</p> <p><code>git</code> is needed:</p> <pre><code>$ sudo apt-get install git\n</code></pre> <p><code>perf</code> is in the Linux source tree so get that:</p> <pre><code>$ cd\n$ mkdir git\n$ cd git\n$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n</code></pre> <p>Alternatively the source code of just the perf tool, and not the whole kernel tree, is archived here.</p> <p>Get the minimum tools to build it:</p> <pre><code>$ sudo apt-get install build-essential flex bison\n</code></pre> <p>It should be possible to build <code>perf</code> at this stage but it will be missing essential features.  Add some more development libraries:</p> <pre><code>$ sudo apt-get install libelf-dev libnewt-dev libdw-dev libaudit-dev libiberty-dev libunwind-dev libcap-dev libzstd-dev libnuma-dev libssl-dev python3-dev python3-setuptools binutils-dev gcc-multilib liblzma-dev\n</code></pre> <p>Note, with v5.19 and earlier, python3-distutils was used instead of python3-setuptools, but that was changed in this commit.</p> <p>Aside: example packages for Fedora instead of Ubuntu:</p> <pre><code>sudo yum install flex bison gcc make elfutils-libelf-devel elfutils-devel libunwind-devel python-devel libcap-devel slang-devel binutils-devel numactl-devel openssl-devel\n</code></pre> <p>To build <code>perf</code> (with script bindings for python3 instead of python2) and put it in <code>~/bin/perf</code> :</p> <pre><code>$ cd ~/git/linux\n$ PYTHON=python3 make -C tools/perf install\n</code></pre> <p>To use <code>~/bin/perf</code>, ~/bin must be in $PATH.  In Ubuntu, that is added automatically when a user logs in if the ~/bin directory exists (refer ~/.bashrc). If it is not in $PATH, log out and in again.  We can echo $PATH to check:</p> <pre><code>$ echo $PATH\n/home/user/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\n$ which perf\n/home/user/bin/perf\n</code></pre>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#a","title":"A","text":""},{"location":"glossary/#amba","title":"AMBA","text":"<p>Principally an ARM term, Advanced Microcontroller Bus Architecture  (AMBA) for the connection and  management of functional blocks in a System-on-Chip (SoC).</p>"},{"location":"glossary/#axi","title":"AXI","text":"<p>Principally an ARM term, Advanced eXtensible  Interface.  There is also the AXI Coherency Extensions (ACE)</p>"},{"location":"glossary/#b","title":"B","text":""},{"location":"glossary/#beat","title":"Beat","text":"<p>A beat is the smallest single unit of data transfer within an AXI  transaction. Its size is determined by the bus width. A Burst can be comprised  of multiple beats. See the Arm  Glossary</p>"},{"location":"glossary/#bios","title":"BIOS","text":"<p>Basic Input/Output System.</p>"},{"location":"glossary/#bpf","title":"BPF","text":"<p>Berkeley Packet Filter.</p>"},{"location":"glossary/#bpf-counter","title":"BPF Counter","text":"<p>An option on <code>perf stat</code> where a BPF program reads counters to a BPF map rather than the regular <code>read</code> of a perf event file descriptor. The BPF program  reads the counter on context switches from an event in system wide mode. If the number of system wide per CPU events is less than the number of threads  or cgroups, this option can reduce file descriptor overhead.</p>"},{"location":"glossary/#c","title":"C","text":""},{"location":"glossary/#c2c","title":"C2C","text":"<p>Cache-to-cache. <code>perf c2c</code> is a builtin perf tool for analyzing shared data accesses and problems like (false sharing)[#false-sharing].</p>"},{"location":"glossary/#cake","title":"CAKE","text":"<p>Coherent AMD socKet Extender</p>"},{"location":"glossary/#ccd","title":"CCD","text":"<p>Principally an AMD term, Core Complex Dies are usually part of a CCX.</p>"},{"location":"glossary/#ccx","title":"CCX","text":"<p>Prinicpally an AMD term, Core CompleX  where dies are connected and share the L3 cache.</p>"},{"location":"glossary/#cha","title":"CHA","text":"<p>Principally an Intel term for Caching and Home Agent  (CHA).</p>"},{"location":"glossary/#chi","title":"CHI","text":"<p>Principally an ARM term for the AMBA bus Coherent Hub  Interface</p>"},{"location":"glossary/#cmn","title":"CMN","text":"<p>Principally an ARM term for Coherenet Mesh  Network.</p>"},{"location":"glossary/#core","title":"Core","text":"<ol> <li>Used to refer to events on the CPU's PMU, contrast with Uncore and Offcore.</li> <li>Part of the topology containing multiple SMT threads.</li> </ol>"},{"location":"glossary/#cpuid","title":"CPUID","text":"<p>On Intel an instruction that identifies the type and properties of the  CPU. ARM64 CPUs are generally identified from  <code>/sys/devices/system/cpu/cpu0/regs/identification/midr_el1</code>.</p>"},{"location":"glossary/#d","title":"D","text":""},{"location":"glossary/#dsb","title":"DSB","text":"<p>In modern Intel CPUs, the DSB (Decoded Stream Buffer) is a uop cache storing pre-decoded instructions in the form of micro-operations (uops).  The DSB allows the CPU to bypass the  decoding stage for frequently used instructions sequences.</p>"},{"location":"glossary/#dtg","title":"DTG","text":"<p>Termed used with Marvell CN10K chips, Lookaside Translation Group used for  regular virtual to physical memory management.</p>"},{"location":"glossary/#e","title":"E","text":""},{"location":"glossary/#events","title":"Events","text":"<p>The list of measurable events is supported by the perf tool. </p>"},{"location":"glossary/#event-selector","title":"Event Selector","text":"<p>See evsel.</p>"},{"location":"glossary/#evlist","title":"evlist","text":"<ol> <li>A perf command to list the events within a perf.data file.</li> <li>A list of event selectors. The evlist API is part of libperf.</li> </ol>"},{"location":"glossary/#evsel","title":"evsel","text":"<p>An event selector describes a <code>perf event</code> that will be opened on multiple CPUs or threads. The evsel API is part of libperf.</p>"},{"location":"glossary/#f","title":"F","text":""},{"location":"glossary/#false-sharing","title":"False Sharing","text":"<p>When a cache line is accidentally shared, and written-to, by two threads because of the layout of data being so that it is on the same cache line.</p>"},{"location":"glossary/#flexible-event","title":"Flexible Event","text":"<p>The default kind of event that can be multiplexed, contrast with pinned event.</p>"},{"location":"glossary/#free-running-counter","title":"Free Running Counter","text":"<p>A counter that runs through its full range of values before repeating.</p>"},{"location":"glossary/#g","title":"G","text":""},{"location":"glossary/#gmi","title":"GMI","text":"<p>AMD Global Memory Interconnect.</p>"},{"location":"glossary/#h","title":"H","text":""},{"location":"glossary/#hitm","title":"HITM","text":"<p>A load that Hit a Modified cacheline.</p>"},{"location":"glossary/#hwmon","title":"Hwmon","text":"<p>The Linux Hardware Monitoring kernel  API.</p>"},{"location":"glossary/#hyperthread","title":"Hyperthread","text":"<p>Intel/x86 term for SMT.</p>"},{"location":"glossary/#i","title":"I","text":""},{"location":"glossary/#ibs","title":"IBS","text":"<p>AMD Instruction-Based Sampling (IBS) allows precise a hardware performance  monitoring similar to Intel PEBS. Unlike Intel PEBS, IBS provides  separate PMUs to gather relevant data.</p>"},{"location":"glossary/#idq","title":"IDQ","text":"<p>The IDQ (Instruction Decode Queue) serves as a buffer between the instruction fetch/decode stages and the rest of the out-of-order execution engine in modern CPUs. It stores decoded instructions often in the form of micro-ops.</p>"},{"location":"glossary/#j","title":"J","text":""},{"location":"glossary/#jeclear","title":"JEClear","text":"<p>Jump Execution Clear is a kind of pipeline flush on Intel CPUs cause by branch misprediction. Article on branching in Intel CPUs.</p>"},{"location":"glossary/#json","title":"JSON","text":"<p>JavaScript Object Notation.</p>"},{"location":"glossary/#k","title":"K","text":""},{"location":"glossary/#kvm","title":"KVM","text":"<p>KVM stands for Kernel-based Virtual Machine, perf command with kvm helps us to trace/measure kvm guest os</p>"},{"location":"glossary/#l","title":"L","text":""},{"location":"glossary/#l12di","title":"L[12][DI]","text":"<p>Level 1 or 2, data or instruction cache.</p>"},{"location":"glossary/#legacy-events","title":"Legacy Events","text":"<p>Perf events are identified by a type and a config value. The type identifies  the PMU. To determine the config value, data is read from  sysfs or embedded in the perf tool via json files - the appropriate  json file data is identified via a cpuid. Initially all  hardware events had a single type and the mapping of the event to the config  value was hard coded. To allow extension, sysfs and json encodings were  added. Legacy events fail in heterogeneous systems as typically a different  core/CPU PMU is needed for each type of event. As users expect event  event names/encodings to behave in certain ways, the removal of legacy events  has proven contentious.</p>"},{"location":"glossary/#lfb","title":"LFB","text":"<p>The Line Fill Buffer is a small, temporary buffer that sits between different levels of a CPU's cache (e.g., between L1 and L2). Its purpose is to speed up data access when the CPU needs data not found in the fastest cache level (a cache miss). Instead of making the CPU wait for an entire cache line to transfer from slower memory, the LFB stores the first chunk of data, allowing the CPU to start working immediately.</p>"},{"location":"glossary/#lsd","title":"LSD","text":"<p>The Loop Stream Detector is a frontend component within Intel CPUs designed to boost performance for tight loops. It detects loops in code, pre-decodes their instructions, and stores these decoded micro-ops (uops) in a dedicated buffer.  By feeding these uops directly to the execution engine, the LSD bypasses the slower instruction fetch and decode stages for loops, resulting in speedups.</p>"},{"location":"glossary/#llc","title":"LLC","text":"<p>The Last Level Cache (LLC) before accessing memory, generally level 3. Will  generally have its own PMU</p>"},{"location":"glossary/#ltg","title":"LTG","text":"<p>Termed used with Marvell CN10K chips, Lookaside Translation Group used for  special virtual to physical memory management.</p>"},{"location":"glossary/#m","title":"M","text":""},{"location":"glossary/#metric","title":"Metric","text":"<p>Taking multiple performance counters, typically in <code>perf stat</code>, and then computing a human meaningful value like memory bandwidth.</p>"},{"location":"glossary/#mite","title":"MITE","text":"<p>The Micro-instruction Translation Engine is a legacy component within modern CPUs that acts as a secondary, simpler instruction decoder. While the primary decoder handles most instructions efficiently, the MITE is responsible for decoding specific complex instructions or instruction sequences that aren't well-suited for the main decoder.  The MITE often works alongside the microcode sequencer to break down these complex instructions into simpler micro-operations for the CPU to execute.</p>"},{"location":"glossary/#mpam","title":"MPAM","text":"<p>Principally an ARM term for Memory System Resource Partitioning and  Monitoring.</p>"},{"location":"glossary/#mpki","title":"MPKI","text":"<p>Cache, TLB or branch Misses Per Kilo (1,000) Instructions.</p>"},{"location":"glossary/#ms","title":"MS","text":"<p>The microcode sequencer is a specialized unit that handles the execution of complex instructions not directly supported as a single hardware operation. It breaks down these instructions into sequences of simpler micro-operations (microcode) that the CPU's execution units can directly understand.</p>"},{"location":"glossary/#multiplexing","title":"Multiplexing","text":"<p>When the number of events is greater than the hardware counters the kernel will multiplex the events. Each event is scheduled for a period of time (by default 1kHz) and then rotated.</p>"},{"location":"glossary/#o","title":"O","text":""},{"location":"glossary/#offcore","title":"Offcore","text":"<p>Devices and buses outside of the core CPU.</p>"},{"location":"glossary/#off-cpu","title":"Off-CPU","text":"<p>Off-CPU is data collected when a task gets context switched. Brendan Gregg discusses Off-CPU analysis. Combining on-CPU time, measured with a performance  counter, with off-CPU time will give wall clock time. Linux perf 5.20 adds a command line option to ''perf record'' to gather off-CPU data.</p>"},{"location":"glossary/#p","title":"P","text":""},{"location":"glossary/#pebs","title":"PEBS","text":"<p>Intel Processor Event-Based Sampling (PEBS) is a hardware mechanism that  enables precise performance profiling by capturing specific processor events  and their associated instruction pointers. Unlike traditional sampling methods  that rely on periodic interrupts, PEBS allows developers to collect performance  data with minimal overhead and pinpoint performance bottlenecks with high  accuracy. When a predefined event occurs, such as a cache miss or branch  misprediction, PEBS records the instruction pointer and other relevant  information in a dedicated buffer. This data can then be analyzed to identify  performance hotspots and optimize code for improved efficiency. PEBS is a  powerful tool for software developers and performance analysts seeking to  understand and optimize application performance on Intel processors.</p>"},{"location":"glossary/#perfdata","title":"perf.data","text":"<p>By default output from various perf commands is stored in a file named perf.data.</p>"},{"location":"glossary/#perf-event","title":"perf-event","text":"<p>A kernel abstraction used to reference data being gathered about a particular kind of kernel event.</p>"},{"location":"glossary/#perf-evlist","title":"perf-evlist","text":"<p>See man1/perf-evlist.1.</p>"},{"location":"glossary/#pinned-event","title":"Pinned Event","text":"<p>Pinned events are scheduled at a higher priority to flexible events. If they can't be scheduled within the kernel they don't multiplex and enter an error state.</p>"},{"location":"glossary/#pmu","title":"PMU","text":"<p>A Performance Monitoring Unit is a device within the Linux kernel that the perf tool interacts with initially through the perf_event_open system call.</p>"},{"location":"glossary/#precise-event","title":"Precise Event","text":"<p>When sampling an interrupt is triggered and the sample gathered in the  kernel. There is typically a delay between the interrupt and the sample,  leading the accuracy of the sample to be limited and skid. CPU  extensions like PEBS, IBS and SPE can be used to  reduce this. Placing the modifier 'p' after an event modifies its  precision/skid:</p> <ol> <li>SAMPLE_IP can have arbitrary skid</li> <li>'p' -SAMPLE_IP must have constant skid</li> <li>'pp' - SAMPLE_IP requested to have 0 skid</li> <li>'ppp' -SAMPLE_IP must have 0 skid, or uses randomization to avoid sample shadowing effects.</li> </ol>"},{"location":"glossary/#q","title":"Q","text":""},{"location":"glossary/#qpi","title":"QPI","text":"<p>Intel Quick Path Interconnect.</p>"},{"location":"glossary/#r","title":"R","text":""},{"location":"glossary/#rat","title":"RAT","text":"<p>In modern CPUs, a Resource Allocation Table (RAT) is a structure that renames architectural registers to a larger set of physical registers during the out-of-order execution process. This renaming breaks false dependencies caused by register naming limitations, allowing instructions to execute in parallel and boosting performance. The RAT also tracks which physical registers hold the results of in-flight instructions, ensuring that data is used at the correct time.</p>"},{"location":"glossary/#rob","title":"ROB","text":"<p>Reorder Buffer, tracks in-flight instructions and their results in out-of-order CPUs.</p>"},{"location":"glossary/#rs","title":"RS","text":"<p>Reservation Station, buffers instructions awaiting resources (functional units, data) before execution.</p>"},{"location":"glossary/#s","title":"S","text":""},{"location":"glossary/#sdf","title":"SDF","text":"<p>Scalable Data  Fabric.</p>"},{"location":"glossary/#skid","title":"Skid","text":"<p>The distance between where a sample is, an instruction, and where the sampling event was actually triggered. Ideally there would be no skid on samples.</p>"},{"location":"glossary/#slc","title":"SLC","text":"<p>System Level Cache generally used interchangeably with Last Level Cache  but may incorporate caches outside of the processor.</p>"},{"location":"glossary/#smi","title":"SMI","text":"<p>System Management Interrupts trasition the CPU into System Management   Mode to hanle high privilege events.</p>"},{"location":"glossary/#smm","title":"SMM","text":"<p>On x86 generally System Management  Mode, on ARM Secure  Monitor Mode, is a highly privileged firmware/BIOS code.</p>"},{"location":"glossary/#smt","title":"SMT","text":"<p>Simultaneous multithreading.</p>"},{"location":"glossary/#software-event","title":"Software Event","text":"<p>They are kernel/os-based low-level counters. To identify the list of supported  software events use the command: perf list software</p>"},{"location":"glossary/#spe","title":"SPE","text":"<p>ARM's Statistical Profiling Extension is an optional ARM v8  feature that provides precise sampling. Currently the feature is common on  server ARM CPUs.</p>"},{"location":"glossary/#sysfs","title":"sysfs","text":"<p>A filesystem for exporting kernel  objects.</p>"},{"location":"glossary/#t","title":"T","text":""},{"location":"glossary/#tad","title":"TAD","text":"<p>Last-Level cache Tag-and-data Units on Marvell CN10K family silicon.</p>"},{"location":"glossary/#tlb","title":"TLB","text":"<p>TLB stands for Translation Lookaside Buffer. It is a specialized cache that  stores the recent translations, via the page table, of virtual memory addresses  to physical memory addresses.</p>"},{"location":"glossary/#tpebs","title":"TPEBS","text":"<p>Timed Process Event Based Sampling on newer Intel processors adds retirement  latency information to samples. The retirement latency is the number of cycles  between the sampled and the previous instructions retiring. One use is to avoid  having hard coded constants in top-down analysis metrics,  so that overheads are more reflective of the actual workload.</p>"},{"location":"glossary/#tor","title":"TOR","text":"<p>The Table-of-Requests (TOR) is a data structure within Intel's Integrated Memory Controller (IMC) that stores and tracks in-flight memory requests made by CPU cores.</p>"},{"location":"glossary/#task","title":"Task","text":"<p>Kernel term for a process (if just 1 thread) or thread.</p>"},{"location":"glossary/#tsx","title":"TSX","text":"<p>Principally an Intel term, Transactional Synchronization  Extensions</p>"},{"location":"glossary/#u","title":"U","text":""},{"location":"glossary/#uncore","title":"Uncore","text":"<p>Functions of the microprocessor not in the core.</p>"},{"location":"glossary/#uop","title":"UOp","text":"<p>Abbreviation for micro-operation commonly used by Intel.</p>"},{"location":"glossary/#upi","title":"UPI","text":"<p>Intel Ultra Path  Interconnect.</p>"},{"location":"glossary/#v","title":"V","text":""},{"location":"glossary/#vma","title":"VMA","text":"<p>Virtual Memory Area used by the kernel to manage process memory.</p>"},{"location":"glossary/#x","title":"X","text":""},{"location":"glossary/#xgmi","title":"xGMI","text":"<p>eXternal GMI link is a socket-to-socket interconnect that is part of AMD's  Infinity Fabric.</p>"},{"location":"hardware-reference/","title":"Hardware Reference","text":"<p>The capabilities of perf depends on the features of the CPU. The following list the features of common modern architectures.</p>"},{"location":"hardware-reference/#manuals","title":"Manuals","text":"<ul> <li>Intel PMU event tables, in particular Appendix B of the Intel\u00ae 64 and IA-32 Architectures Optimization Reference Manual</li> <li>AMD PMU event table, the Processor Programming Reference Manual for AMD 17h family see Section 2.1.15 Performance Monitor Counters.</li> <li>ARM PMU event tables, see Chapter D7. The Performance Monitors Extension, of the Arm Architecture Reference Manual Armv8, for Armv8-A architecture profile.</li> <li>ARM Neovese N2 PMU guide.</li> </ul>"},{"location":"hardware-reference/#legacy","title":"Legacy","text":"<ul> <li>Intel(TM) Itanium(TM) 2 PMU</li> <li>Intel(TM) Nehalem</li> </ul>"},{"location":"itanium-manuals-iiasdmanual/","title":"Intel\u00ae Itanium\u00ae Architecture","text":""},{"location":"itanium-manuals-iiasdmanual/#software-developers-manual","title":"Software developer's manual","text":"<p>This is a four-volume set of the Intel\u00ae Itanium\u00ae Architecture Software Developer's Manual, which provides a comprehensive guide to Intel's 64-bit architecture. Electronic versions of these documents allow you to quickly get to the information you need and print only the pages you want. At present, downloadable PDFs of combined and separate Volumes 1 through 4 are at Revision 2.3.</p>"},{"location":"itanium-manuals-iiasdmanual/#volumes-1-4-combined-reference-set-revision-23","title":"Volumes 1 - 4: Combined Reference Set, Revision 2.3","text":"<p>This document contains all four-volumes of the Intel\u00ae Itanium\u00ae Architecture Software Developer's Manual, which provides a comprehensive guide to Intel's 64-bit architecture. This document allows for easy navigation of the SDM through functional cross-volume references and a cross-volume index.</p> <p>Download</p>"},{"location":"itanium-manuals-iiasdmanual/#volume-1-application-architecture-revision-23","title":"Volume 1: Application Architecture, Revision 2.3","text":"<p>This document defines the Itanium application architecture, including application level resources, programming environment, and the IA-32 application interface. This volume also describes optimization techniques used to generate high performance software.</p> <p>Download</p>"},{"location":"itanium-manuals-iiasdmanual/#volume-2-system-architecture-revision-23","title":"Volume 2: System Architecture, Revision 2.3","text":"<p>This document defines the Itanium system architecture, including system level resources, and programming state, interrupt model, and processor firmware interface. This volume also provides a useful system programmer's guide for writing high performance system software.</p> <p>Download</p>"},{"location":"itanium-manuals-iiasdmanual/#volume-3-intel-itanium-instruction-set-revision-23","title":"Volume 3: Intel\u00ae Itanium\u00ae Instruction Set, Revision 2.3","text":"<p>This document is a comprehensive reference to the Intel\u00ae Itanium\u00ae instruction set, including instruction format/encoding.</p> <p>Download</p>"},{"location":"itanium-manuals-iiasdmanual/#volume-4-ia-32-instruction-set-revision-23","title":"Volume 4: IA-32 Instruction Set, Revision 2.3","text":"<p>This document is a comprehensive reference to the IA-32 instruction set, including instruction format/encoding.</p> <p>Download</p>"},{"location":"itanium-manuals-iiasdmanual/#intel-itanium-architecture-software-developers-manual-specification-update","title":"Intel\u00ae Itanium\u00ae Architecture Software Developer's Manual Specification Update","text":"<p>Specification update of device and documentation errata, specification clarifications, and changes to the Intel\u00ae Itanium\u00ae Architecture Software Developer's Manual.</p> <p>Download</p>"},{"location":"jolsa/","title":"Jolsa","text":"<ul> <li>perf doc</li> </ul>"},{"location":"jolsa_docs_annotations/","title":"Jolsa docs annotations","text":""},{"location":"jolsa_docs_annotations/#annotations","title":"ANNOTATIONS","text":"<p>TODO: description &amp; examples</p> <p>The perf annotations is based on objdump tool from binutils package.</p>"},{"location":"jolsa_docs_annotations/#binutils-restrictions","title":"BINUTILS RESTRICTIONS","text":"<p>Annotations are based on debuginfo, which on most (Fedora) distributions come in separated -debuginfo packages. Unfortunately objdump* does not connect binaries with its debuginfo counterparts.</p> <p>The result is that for binaries with separated debuginfo you'll not see annotations in perf.</p>"},{"location":"jolsa_docs_annotations/#workaround","title":"WORKAROUND","text":"<p>There's a following workaround, that merges debuginfo back to the binary. Such binary will display proper annotations in perf.</p> <p>The binary we want to annotate properly is ls.</p> <ul> <li>find out the debuginfo holder:</li> </ul> <pre><code>$ rpm -ql coreutils-debuginfo | grep ls.debug\n/usr/lib/debug/usr/bin/ls.debug\n</code></pre> <ul> <li>OPTIONAL if your distribution uses prelink, you need to undo it:</li> </ul> <pre><code>$ cp /bin/ls .\n$ prelink -u ls\n</code></pre> <ul> <li>create the ls-di binary with debuginfo merged:</li> </ul> <pre><code>$ eu-unstrip -o ls-di ./ls /usr/lib/debug/usr/bin/ls.debug\n$ file ls-di\nls-di: ELF 64-bit LSB executable, x86-64, version 1 (SYSV) [SNIP] not stripped\n</code></pre> <ul> <li>clean the build-id cache, since the ls share same build-id with ls-di:</li> </ul> <pre><code>$ perf buildid-cache -r ls\n# or more efectively:\n$ rm -rf ~/.debug/\n</code></pre> <ul> <li>enjoy your annotations via:</li> </ul> <pre><code>$ perf record ./ls-di [SNIP]\n$ perf annotate [FUNC]\n$ perf report\n</code></pre>"},{"location":"jolsa_docs_event/","title":"EVENT","text":"<p>To get list of all supported events:</p> <pre><code>$ perf list\n</code></pre>"},{"location":"jolsa_docs_event/#types","title":"TYPES","text":""},{"location":"jolsa_docs_event/#hardware","title":"HARDWARE","text":""},{"location":"jolsa_docs_event/#software","title":"SOFTWARE","text":""},{"location":"jolsa_docs_event/#tracepoints","title":"TRACEPOINTS","text":""},{"location":"jolsa_features_multiple_file_storage/","title":"Jolsa features multiple file storage","text":""},{"location":"jolsa_features_multiple_file_storage/#description","title":"Description","text":"<p>This feature adds the possibility to store perf record data into multiple files.</p> <ul> <li>new version of perf.data file was added (v3)</li> <li><code>-M/--multi</code> option was added into perf record</li> </ul> <p>example:</p> <pre><code>  $ perf record -M 5M yes &gt; /dev/null\n  ^C[ perf record: Woken up 228 times to write data ]\n  [ perf record: Captured and wrote 20.246 MB perf.data-[0-4](~884542 samples) ]\n  yes: Interrupt\n  $ ls -l perf.data-0*\n  -rw------- 1 jolsa jolsa 5289856 Aug 16 16:07 perf.data-00000\n  -rw------- 1 jolsa jolsa 5296008 Aug 16 16:08 perf.data-00001\n  -rw------- 1 jolsa jolsa 5344968 Aug 16 16:09 perf.data-00002\n  -rw------- 1 jolsa jolsa 5309144 Aug 16 16:09 perf.data-00003\n  -rw------- 1 jolsa jolsa 2358268 Aug 16 16:09 perf.data-00004\n  $ ./perf diff perf.data-0000*\n  # Event 'cycles'\n  #\n  # Data files:\n  #  [0] perf.data-00000 (Baseline)\n  #  [1] perf.data-00001\n  #  [2] perf.data-00002\n  #  [3] perf.data-00003\n  #  [4] perf.data-00004\n  #\n  # Baseline/0  Delta/1  Delta/2  Delta/3  Delta/4      Shared Object                                      Symbol\n  # ..........  .......  .......  .......  .......  .................  ..........................................\n  #\n        37.70%   -0.17%   -0.42%   -0.24%   -0.31%  libc-2.15.so       [.] _IO_file_xsputn@@GLIBC_2.2.5        \n        30.31%   +0.28%   +0.22%   +0.07%   +0.06%  yes                [.] main                                \n        16.73%   +0.02%   +0.10%   -0.03%   +0.11%  libc-2.15.so       [.] __strlen_sse2                       \n        14.22%   -0.30%   -0.10%   -0.31%   -0.14%  libc-2.15.so       [.] fputs_unlocked                      \n         0.39%                              -0.01%  yes                [.] fputs_unlocked@plt                  \n         0.06%                                      [kernel.kallsyms]  [k] system_call                         \n         0.06%                     +0.01%           [kernel.kallsyms]  [k] __srcu_read_lock                    \n         0.05%                     +0.01%           [kernel.kallsyms]  [k] __srcu_read_unlock                  \n  ...\n\n</code></pre> <ul> <li><code>-M/--multi</code> option accepts size and time parameters, distinguished by following terminal character:<ul> <li>s - seconds   (-M 10s)</li> <li>m - minutes   (-M 10m)</li> <li>h - hours     (-M 10h)</li> <li>B - bytes     (-M 10B)</li> <li>K - kilobytes (-M 10K)</li> <li>M - megabytes (-M 10M)</li> </ul> </li> </ul>"},{"location":"jolsa_features_multiple_file_storage/#limitations","title":"Limitations","text":"<ul> <li>minimal file size is 100K</li> <li>each file is started with initiall COMM/MMAP events, this could race with SAMPLE storage leaving some SAMPLES w/o process/mmap translations</li> </ul>"},{"location":"jolsa_features_multiple_file_storage/#todo","title":"TODO","text":"<ul> <li>move file storing into special thread inorder not to abuse main polling thread</li> <li>keep live COMM/MMAP info to save some time when creating new file and limit the race window described above</li> </ul>"},{"location":"jolsa_features_multiple_file_storage/#branch","title":"Branch","text":"<ul> <li>perf/core_file*</li> </ul>"},{"location":"jolsa_features_stat_formulas/","title":"Jolsa features stat formulas","text":""},{"location":"jolsa_features_stat_formulas/#description","title":"Description","text":"<p>This feature adds the possibility to define specific counters by using arithmetic formulas and use them via stat command.</p> <ul> <li>Formula config file looks like:</li> </ul> <pre><code>set {\n     events {\n             CY = cycles\n             IN = instructions\n             BR = branches\n     }   \n     cpi      = CY / IN\n     bdensity = IN / BR\n\n     print cpi \n     print bdensity\n}\n</code></pre> <p>The set defines set of counter that share same events. Each set defines:</p> <ul> <li>events   - event string that would go into stat -e option</li> <li>counters - any number of counters based on above events</li> </ul> <p>Each event and counter is defined as an assignment (via =) to the name(tag), which could be later used within counter formulas.</p> <p>Each counter defines formula that produces the counter number.</p> <ul> <li>Formula grammar:</li> </ul> <pre><code>expr: '-' expr       | \n      expr '+' expr  | \n      expr '-' expr  | \n      expr '*' expr  | \n      expr '/' expr  | \n      value          | \n      name\n</code></pre> <p>where name could be any event or counter name(tag), like: (considering the architectural events name patchset is included)</p> <pre><code>set { \n      events { \n              IN = instructions\n              R0 = cpu/OFFCORE_RESPONSE_0,offcore_rsp=OFFCORE_RESPONSE.(DMND_IFETCH|LLC_MISS_LOCAL)/\n      } \n\n      kinst     = IN / 1000\n      llc_imiss = R0 / kinst\n\n      print llc_imiss\n} \n</code></pre> <p>It's possible to enable counter to be displayed via print label on separate line. Only counters marked like that will be displayed to the user.</p> <ul> <li>Default configuration file is provided within perf installation:</li> </ul> <pre><code>cpi {\n        events {\n                CY = cycles:u\n                IN = instructions:u\n        }\n\n        cpi = CY / IN\n\n        print cpi\n}\n\nbranch {\n        events {\n                IN = instructions:u\n                BI = branch-instructions:u\n                BM = branch-misses:u\n        }\n\n        branch-rate       = BI / IN\n        branch-miss-rate  = BM / IN\n        branch-miss-ratio = BM / BI\n\n        print branch-rate\n        print branch-miss-rate\n        print branch-miss-ratio\n}\n</code></pre> <ul> <li>perf stat allows to specify formula configuration file via -f option</li> <li>user needs to specify set via -e option via formula keyword like formula-set</li> </ul> <pre><code>$ perf stat -e formula-cpi ls\n</code></pre>"},{"location":"jolsa_features_stat_formulas/#example","title":"Example","text":"<ul> <li>krava.conf</li> </ul> <pre><code>cpi {\n        events {\n                CY = cycles:u\n                IN = instructions:u\n        }\n\n        cpi = CY / IN\n\n        print cpi\n}\n\nbranch {\n        events {\n                IN = instructions:u\n                BI = branch-instructions:u\n                BM = branch-misses:u\n        }\n\n        branch-rate       = BI / IN\n        branch-miss-rate  = BM / IN\n        branch-miss-ratio = BM / BI\n\n        print branch-rate\n        print branch-miss-rate\n        print branch-miss-ratio\n}\n</code></pre> <ul> <li>get cpi set formulas:</li> </ul> <pre><code>$ ./perf stat -f ./krava.conf -e formula-cpi yes &gt; /dev/null\n^Cyes: Interrupt\n\n Performance counter stats for 'yes':\n\n     5,504,661,193  cycles:u                 #    0.000 GHz                    \n    15,795,271,321  instructions:u           #    2.87  insns per cycle        \n\n       1.656520050 seconds time elapsed\n\n        0.34850058 cpi                      \n</code></pre> <ul> <li>get branch set formulas:</li> </ul> <pre><code>[jolsa@krava perf]$ ./perf stat -f ./krava.conf -e formula-branch yes &gt; /dev/null\n^Cyes: Interrupt\n\n Performance counter stats for 'yes':\n\n    16,081,772,528  instructions:u           #    0.00  insns per cycle        \n     2,806,823,146  branch-instructions:u                                      \n            56,618  branch-misses:u          #    0.00% of all branches        \n\n       1.688431091 seconds time elapsed\n\n        0.17453444 branch-rate              \n        0.00000352 branch-miss-rate         \n        0.00002017 branch-miss-ratio        \n</code></pre>"},{"location":"jolsa_features_togle_event/","title":"Jolsa features togle event","text":""},{"location":"jolsa_features_togle_event/#branch","title":"Branch","text":"<ul> <li>perf/core_toggle</li> </ul>"},{"location":"jolsa_features_togle_event/#description","title":"Description","text":"<p>Adding perf interface that allows to create toggle events, which can enable or disable another event. Whenever the toggle event is triggered (has overflow), it toggles another event state and either starts or stops it.</p> <p>The goal is to be able to create toggling tracepoint events to enable and disable HW counters, but the interface is generic enough to be used for any kind of event.</p>"},{"location":"jolsa_features_togle_event/#interface","title":"Interface","text":"<p>There are changes for both kernel and perf tool part.</p>"},{"location":"jolsa_features_togle_event/#kernel","title":"Kernel","text":"<p>The interface to create a toggle event is similar as the one for defining event group. Use perf syscall with:</p> <pre><code>int sys_perf_event_open(struct perf_event_attr *attr,\n                        pid_t pid, int cpu, int group_fd,\n                        unsigned long flags)\n\nflags    - PERF_FLAG_TOGGLE_ON or PERF_FLAG_TOGGLE_OFF\ngroup_fd - event (or group) fd to be toggled\n</code></pre> <p>Created event will toggle ON(start) or OFF(stop) the event specified via group_fd.</p> <p>Obviously this way it's not possible for toggle event to be part of group other than group leader. This is where you need to use PERF_EVENT_IOC_SET_TOGGLE ioctl.</p> <p>This ioctl has 2 goals:</p> <ul> <li>allowing the toggle event being part of the group</li> <li>allowing to define toggle setting after event is created</li> </ul> <pre><code>u64 args[2] = { toggled_fd, flag };\nerr = ioctl(fd, PERF_EVENT_IOC_SET_TOGGLE, args);\n</code></pre> <p>Where:</p> <pre><code>toggled_fd - is file description of the event we want to toggle\nflag       - is one of PERF_FLAG_TOGGLE_ON|PERF_FLAG_TOGGLE_OFF\nerr        -  0 when successful\n             -1 otherwise with errno:\n                EBUSY  - event has already toggled event defined\n                EFAULT - could not copy user data\n                EINVAL - wrong data\n</code></pre>"},{"location":"jolsa_features_togle_event/#perf-tool","title":"Perf Tool","text":"<p>The support for toggling events is added into record and stat commands.</p> <p>The toggling events are defined via on/off terms, assigned with the name of the event they should toggle.</p> <p>Toggling events are define within -e option using on/off terms, like</p> <pre><code>-e 'cycles,irq_entry/on=cycles/,irq_exit/off=cycles/'\n</code></pre> <p>Meaning:</p> <ul> <li>irq_entry toggles on (starts) cycles, and irq_exit toggled off (stops) cycles.</li> <li>cycles is started as paused</li> </ul>"},{"location":"jolsa_features_togle_event/#examples","title":"Examples","text":""},{"location":"jolsa_features_togle_event/#example-using-kretprobes","title":"Example - using k(ret)probes","text":"<ul> <li>Define toggle(on/off) events:</li> </ul> <pre><code># perf probe -a fork_entry=do_fork\n# perf probe -a fork_exit=do_fork%return\n</code></pre> <ul> <li>Following record session samples only within do_fork function:</li> </ul> <pre><code># perf record -g -e '{cycles,cache-misses}:k,probe:fork_entry/on=cycles/,probe:fork_exit/off=cycles/' \\ \n  perf bench sched messaging\n</code></pre> <ul> <li>Following stat session measure cycles within do_fork function:</li> </ul> <pre><code># perf stat -e '{cycles,cache-misses}:k,probe:fork_entry/on=cycles/,probe:fork_exit/off=cycles/' \\ \n  perf bench sched messaging\n\n# Running sched/messaging benchmark...\n# 20 sender and receiver processes per group\n# 1 groups == 40 processes run\n\n     Total time: 0.073 [sec]\n\n Performance counter stats for './perf bench sched messaging -g 1':\n\n        20,935,464 cycles                    #    0.000 GHz\n            18,897 cache-misses\n                40 probe:fork_entry\n                40 probe:fork_exit\n\n       0.086319682 seconds time elapsed\n\n</code></pre>"},{"location":"jolsa_features_togle_event/#example-using-uretprobes","title":"Example - using u(ret)probes","text":"<ul> <li>Sample program:</li> </ul> <pre><code>void krava(void)\n{\n        asm volatile (\"nop; nop\");\n}\n\nint main(void)\n{\n        krava();\n        return 0;\n}\n</code></pre> <ul> <li>Define toggle(on/off) events:</li> </ul> <pre><code># perf probe -x ./ex entry=krava\n# perf probe -x ./ex exit=krava%return\n</code></pre> <ul> <li>Following stat session measure instructions within krava function:</li> </ul> <pre><code># perf stat -e instructions:u,probe_ex:entry/on=instructions/,probe_ex:exit/off=instructions/ ./ex\n\n    Performance counter stats for './ex':\n\n                 9 instructions:u            #    0.00  insns per cycle \n                 1 probe_ex:entry\n                 1 probe_ex:exit\n\n       0.000556743 seconds time elapsed\n</code></pre> <ul> <li>Following stat session measure cycles, instructions and cache-misses within krava function:</li> </ul> <pre><code># perf stat -e '{cycles,instructions,cache-misses}:u,probe_ex:entry/on=cycles/,probe_ex:exit/off=cycles/' ./ex\n\n     Performance counter stats for './ex':\n\n           2,068 cycles                    #    0.000 GHz\n               9 instructions              #    0.00  insns per cycle \n               0 cache-misses\n               1 probe_ex:entry\n               1 probe_ex:exit\n\n     0.000557504 seconds time elapsed\n</code></pre>"},{"location":"jolsa_features_togle_event/#example-measure-interrupts-cycles","title":"Example - Measure interrupts cycles","text":"<pre><code># ./perf stat -e 'cycles,cycles/name=cycles_irq/,irq:irq_handler_entry/on=cycles_irq/,irq:irq_handler_exit/off=cycles_irq/' -a sleep 10\n\n   Performance counter stats for 'sleep 10':\n\n      50,680,084,994 cycles                    #    0.000 GHz                     [100.00%]\n             652,690 cycles_irq                #    0.000 GHz\n                  33 irq:irq_handler_entry                                        [100.00%]\n                  33 irq:irq_handler_exit\n\n        10.002084400 seconds time elapsed\n</code></pre>"},{"location":"jolsa_howto_install/","title":"Jolsa howto install","text":"<p>perf tool comes as a single package, on Fedora run:</p> <pre><code>$ sudo yum install perf\nResolving Dependencies\n--&gt; Running transaction check\n---&gt; Package perf.x86_64 0:3.8.13-100.fc17 will be installed\n--&gt; Finished Dependency Resolution\n\nDependencies Resolved\n\n==================================================================================================================================\n Package                   Arch                        Version                                 Repository                    Size\n==================================================================================================================================\nInstalling:\n perf                      x86_64                      3.8.13-100.fc17                         updates                      588 k\n\nTransaction Summary\n==================================================================================================================================\nInstall  1 Package\n\nTotal download size: 588 k\nInstalled size: 1.3 M\nIs this ok [y/N]: y\nDownloading Packages:\nperf-3.8.13-100.fc17.x86_64.rpm                                                                            | 588 kB  00:00:00     \nRunning Transaction Check\nRunning Transaction Test\nTransaction Test Succeeded\nRunning Transaction\n  Installing : perf-3.8.13-100.fc17.x86_64                                                                                    1/1 \n  Verifying  : perf-3.8.13-100.fc17.x86_64                                                                                    1/1 \n\nInstalled:\n  perf.x86_64 0:3.8.13-100.fc17\n\nComplete!\n\n$ which perf\n/bin/perf\n</code></pre>"},{"location":"jolsa_howto_install_sources/","title":"Jolsa howto install sources","text":""},{"location":"jolsa_howto_install_sources/#sources","title":"Sources","text":"<p>Clone any kernel source git tree:</p> <pre><code># linus git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git\n# tip   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git\n# acme  git://git.kernel.org/pub/scm/linux/kernel/git/acme/linux\n# jolsa git://git.kernel.org/pub/scm/linux/kernel/git/jolsa/perf.git\n\n$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git\n</code></pre>"},{"location":"jolsa_howto_install_sources/#dependencies","title":"Dependencies","text":"<p>Packages you need to compile perf with all features (Fedora based):</p> <ul> <li><code>gcc</code></li> <li><code>glibc-devel</code></li> <li><code>glibc-headers</code></li> <li><code>binutils-devel</code></li> <li><code>elfutils-libelf-devel</code></li> <li><code>elfutils-devel</code></li> <li><code>libunwind-devel</code></li> <li><code>audit-libs-devel</code></li> <li><code>slang-devel</code></li> <li><code>gtk2-devel</code></li> <li><code>numa-libs-devel</code></li> <li><code>python-devel</code></li> <li><code>perl-devel</code></li> <li><code>perl-ExtUtils-Embed</code></li> <li><code>numactl-devel</code></li> <li><code>asciidoc</code></li> <li><code>xmlto</code></li> <li><code>flex</code></li> <li><code>bison</code></li> </ul> <pre><code>$ sudo yum install gcc binutils-devel elfutils-libelf-devel \\\n  elfutils-devel libunwind-devel audit-libs-devel slang-devel \\\n  gtk2-devel python-devel perl-devel perl-ExtUtils-Embed numactl-devel \\\n  asciidoc xmlto flex bison glibc-devel\n\n...\n</code></pre>"},{"location":"jolsa_howto_install_sources/#build-install","title":"Build &amp; Install","text":"<pre><code>$ cd linux-2.6.git/tools/perf\n$ make &amp;&amp; make install\n</code></pre>"},{"location":"jolsa_howto_install_sources/#binaries","title":"Binaries","text":"<p>The perf is by default installed under user's $(HOME)</p> <pre><code>[jolsa@krava perf]$ ls -l ~/bin/perf \n-rwxr-xr-x 1 jolsa jolsa 8383047 Jun 20 15:43 /home/jolsa/bin/perf\n[jolsa@krava perf]$ ls -l ~/libexec/perf-core/ ~/share/man/man1/\n\n...\n</code></pre>"},{"location":"jolsa_howto_measure_child_functions_cycles/","title":"Jolsa howto measure child functions cycles","text":""},{"location":"jolsa_howto_measure_child_functions_cycles/#example-program","title":"Example program","text":"<ul> <li>ex.c</li> </ul> <pre><code>#define FOO(__f)        \\\nstatic int __f(int i)   \\\n{                       \\\n        while (i--);    \\\n}\n\nFOO(krava_a);\nFOO(krava_b);\nFOO(krava_c);\nFOO(krava_d);\n\nstatic void krava_g(void)\n{\n        krava_a(50);\n        krava_b(50);\n        krava_c(50);\n        krava_d(50);\n}\n\nint main(int argc, char **argv)\n{\n        while (1) {\n                krava_a(200);\n                krava_b(200);\n                krava_c(200);\n                krava_d(200);\n                krava_g();\n        }\n}\n</code></pre> <ul> <li>Makefile</li> </ul> <pre><code>ex: ex.o\n</code></pre>"},{"location":"jolsa_howto_measure_child_functions_cycles/#measurements","title":"Measurements","text":"<ul> <li>krava_[abcd] functions are taking 25% of the load</li> </ul> <pre><code>$ perf record  ./ex\n^C[ perf record: Woken up 5 times to write data ]\n[ perf record: Captured and wrote 1.200 MB perf.data (~52446 samples) ]\n./ex: Interrupt\n$ perf report --stdio\n...\n# Overhead  Command      Shared Object                                Symbol\n# ........  .......  .................  ....................................\n#\n    26.41%       ex  ex                 [.] krava_d                         \n    25.16%       ex  ex                 [.] krava_b                         \n    24.03%       ex  ex                 [.] krava_a                         \n    23.95%       ex  ex                 [.] krava_c                         \n     0.18%       ex  ex                 [.] krava_g                         \n\n</code></pre> <ul> <li>but how much krava_g function takes?</li> <li>we need parent info - callchains, so let's record them with -g</li> </ul> <pre><code>$ perf record -g -- ./ex\n^C[ perf record: Woken up 7 times to write data ]\n[ perf record: Captured and wrote 1.554 MB perf.data (~67889 samples) ]\n./ex: Interrupt\n</code></pre> <ul> <li>and say we want to report parent symbol with -p krava_g</li> </ul> <pre><code>$ perf report -p krava_g\nSamples: 19K of event 'cycles', Event count (approx.): 17010569690\n+  22.39%  ex  ex                 [.] krava_d                              [other]\n+  20.11%  ex  ex                 [.] krava_c                              [other]\n+  20.00%  ex  ex                 [.] krava_b                              [other]\n+  18.80%  ex  ex                 [.] krava_a                              [other]\n+   4.90%  ex  ex                 [.] krava_a                              krava_g\n+   4.71%  ex  ex                 [.] krava_b                              krava_g\n+   4.39%  ex  ex                 [.] krava_c                              krava_g\n+   4.28%  ex  ex                 [.] krava_d                              krava_g\n+   0.14%  ex  ex                 [.] krava_g                              krava_g\n+   0.08%  ex  ex                 [.] main                                 [other]\n</code></pre> <p>Previous:</p> <ul> <li>parent symbol is displayed in the last column in above listing</li> <li>you can see load gets separated by parent krava_g and the rest [other]</li> <li>main based krava_[abcd] functions now eat only 20% now</li> <li>krava_g based krava_[abcd] functions eat ~20% as well (+- other trash)</li> </ul> <p>Next:</p> <ul> <li>we can make the numbers more obvious and sort it by parent with -s parent</li> </ul> <pre><code>$ perf report -p krava_g -s parent --stdio\n# Overhead  Parent symbol\n# ........  .............\n#\n    81.54%  [other]      \n            |          \n            |--27.46%-- krava_d\n            |          |          \n            |          |--98.60%-- main\n            |          |          __libc_start_main\n            |          |          \n            |           --1.40%-- __libc_start_main\n            |          \n            |--24.66%-- krava_c\n            |          |          \n            |          |--98.77%-- main\n            |          |          __libc_start_main\n            |          |          \n            |           --1.23%-- __libc_start_main\n            |          \n            |--24.52%-- krava_b\n            |          |          \n            |          |--98.61%-- main\n            |          |          __libc_start_main\n            |          |          \n            |           --1.39%-- __libc_start_main\n            |          \n            |--23.06%-- krava_a\n            |          |          \n            |          |--99.22%-- main\n            |          |          __libc_start_main\n            |          |          \n            |           --0.78%-- __libc_start_main\n             --0.30%-- [...]\n\n    18.46%  krava_g      \n            |          \n            |--26.57%-- krava_a\n            |          krava_g\n            |          main\n            |          __libc_start_main\n            |          \n            |--25.54%-- krava_b\n            |          krava_g\n            |          main\n            |          __libc_start_main\n            |          \n            |--23.80%-- krava_c\n            |          krava_g\n            |          main\n            |          __libc_start_main\n            |          \n            |--23.20%-- krava_d\n            |          krava_g\n            |          main\n            |          __libc_start_main\n            |          \n            |--0.74%-- krava_g\n            |          __libc_start_main\n             --0.16%-- [...]\n</code></pre> <ul> <li>krava_g takes ~20% plus we can see the load distribution for its child functions</li> </ul>"},{"location":"lock-contention/","title":"perf lock contention","text":"<p>The <code>perf lock</code> command is to trace kernel lock tracepoints. <code>CONFIG_LOCKDEP</code> enables a couple of lock tracepoints but it's for debugging and adds a lot of overheads.  So  most distros don't ship the kernel with the config.  Another set of tracepoints are focusing on the contended locks and it's always available and has lower overhead. The <code>perf lock contention</code> command is to deal with the contention tracepoints only.</p>"},{"location":"lock-contention/#analyzing-kernel-lock-contention","title":"Analyzing kernel lock contention","text":"<p>The <code>perf lock contention</code> (shortly <code>perf lock con</code>) can run with or without BPF.  Without BPF it requires two steps to record the data and to analyze the data.  That is, you must save all tracepoints data to a file first using <code>perf lock record</code> command.  This might be good when users want to analyze the data multiple times probably in different ways.</p> <p>Running it with BPF (<code>-b</code> option) enables you to do live analysis without the data copying.  The BPF aggregates the data in the kernel and the tool just displays the result.  Also BPF can do more things like accessing the owner info (if available) and symbolizing lock addresses (in some cases).</p> <p>There are 3 modes in the tool to aggregate the result by stack trace, task or the lock.  Newer versions of the tool will likely have more features.  This document will use BPF and tool version 6.2.</p>"},{"location":"lock-contention/#common-options","title":"Common options","text":"<p>These options are to control the collection target.</p> <ul> <li><code>-a</code> (<code>--all-cpus</code>) : enable system-wide collection from all-CPUs.</li> <li><code>-C</code> (<code>--cpu</code>) NUM : collect lock contention from the given CPUs only.</li> <li><code>-p</code> (<code>--pid</code>) NUM : collect lock contention from the given process only.</li> <li><code>--tid</code> NUM : collect lock contention from the given thread only.     Unfortunately the <code>-t</code> option was already taken.</li> <li><code>-G</code> (<code>--cgroup-filter</code>) NAME : collect lock contention from the given cgroup only. (from v6.7)</li> </ul> <p>These options are used for all aggregation modes.</p> <ul> <li><code>-b</code> (<code>--use-bpf</code>) : use BPF programs to collect lock contention stats.</li> <li><code>-E</code> (<code>--entries</code>) NUM : limit the output by this many entries</li> <li><code>-F</code> (<code>--field</code>) NAMES : select the output columns (comma-separate values).     Users can customize the output.  Available values are <code>contended</code>, <code>wait_total</code>,     <code>wait_max</code>, <code>wait_min</code>, <code>avg_wait</code>.  The default values are     \u201ccontended,wait_total,wait_max,avg_wait\u201d.</li> <li><code>-k</code> (<code>--key</code>) NAME<code>: select the key to sort the entries.  Available values     are the same with the</code>-F` option.  The default value is \u201cwait_total\u201d.</li> <li><code>-v</code> (<code>--verbose</code>) : show verbose output including debug stats.</li> </ul> <p>There are filter options when you have information on target locks (usually from the previous runs).</p> <ul> <li><code>-L</code> (<code>--lock-filter</code>) ADDR : limit collection for the given lock only.     It also accepts a symbolic name if the lock has a symbol (for global locks).     Note that \u2018mmap_lock\u2019, \u2018rq_lock\u2019 and \u2018siglock\u2019 are not global locks (they got     the symbol by post-processing) so they cannot be used for the filter option.</li> <li><code>-Y</code> (<code>--type-filter</code>) FLAGS : collect contention stats for the given lock     (access) types.  Available values are <code>spinlock</code>, <code>rwlock</code>, <code>rwlock:R</code>,     <code>rwlock:W</code>, <code>mutex</code>, <code>rwsem</code>, <code>rwsem:R</code>, <code>rwsem:W</code>, <code>semaphore</code>, \u2026     (anything that appears in the type column).</li> </ul>"},{"location":"lock-contention/#by-stack-trace","title":"By stack trace","text":"<p>The default behavior of the tool collects the contention stat by stack trace (in kernel only) and shows the key function for each entry.</p> <pre><code># perf lock con -ab sleep 1\n contended   total wait     max wait     avg wait         type   caller\n\n         2     27.49 us     15.86 us     13.74 us     spinlock   raw_spin_rq_lock_nested+0x1b\n         2     24.58 us     14.10 us     12.29 us     rwlock:W   ep_done_scan+0x2d\n         1     19.18 us     19.18 us     19.18 us     rwlock:W   do_epoll_wait+0x47b\n         1     16.65 us     16.65 us     16.65 us     spinlock   tick_do_update_jiffies64+0x25\n         1     13.82 us     13.82 us     13.82 us     spinlock   __queue_work+0x174\n         2     12.80 us      9.55 us      6.40 us     spinlock   process_one_work+0x1f0\n         1     10.31 us     10.31 us     10.31 us     rwlock:R   ep_poll_callback+0x2d\n</code></pre> <p>It uses system wide mode (<code>-a</code>) with BPF (<code>-b</code>).  I think these are options you want to use mostly.  The \u2018sleep 1\u2019 part is just to run the tool for 1 second.  It\u2019s a common pattern for the perf tools.</p> <p>The first entry is a spinlock from <code>raw_spin_rq_lock_nested()</code> kernel function and it\u2019s contended twice.  The caller was chosen after collecting the stack trace.  It skips internal lock functions and picks whatever follows them immediately.</p> <p>The following command shows the whole stack traces (<code>-v</code>) for top 3 lock contentions (<code>-E 3</code>).</p> <pre><code># perf lock con -abv -E3 sleep 1\nLooking at the vmlinux_path (8 entries long)\nsymsrc__init: cannot get elf header.\nUsing /proc/kcore for kernel data\nUsing /proc/kallsyms for symbols\n contended   total wait     max wait     avg wait         type   caller\n\n         1     26.10 us     26.10 us     26.10 us     spinlock   raw_spin_rq_lock_nested+0x1b\n                        0xffffffff9d0407c0  _raw_spin_lock+0x30\n                        0xffffffff9c6d9cfb  raw_spin_rq_lock_nested+0x1b\n                        0xffffffff9c6e3437  _raw_spin_rq_lock_irqsave+0x17\n                        0xffffffff9c6f1de2  _nohz_idle_balance.isra.0+0x1a2\n                        0xffffffff9c6f7c48  do_idle+0x38\n                        0xffffffff9c6f8099  cpu_startup_entry+0x19\n                        0xffffffff9d02eaeb  rest_init+0xcb\n                        0xffffffff9e673da2  arch_call_rest_init+0xa\n         1     22.52 us     22.52 us     22.52 us     spinlock   tick_do_update_jiffies64+0x25\n                        0xffffffff9d0407c0  _raw_spin_lock+0x30\n                        0xffffffff9c7657c5  tick_do_update_jiffies64+0x25\n                        0xffffffff9c765903  tick_sched_do_timer+0x93\n                        0xffffffff9c765943  tick_sched_timer+0x33\n                        0xffffffff9c75237f  __hrtimer_run_queues+0x10f\n                        0xffffffff9c75333e  hrtimer_interrupt+0xfe\n                        0xffffffff9c6693fc  __sysvec_apic_timer_interrupt+0x7c\n                        0xffffffff9d02d0d9  sysvec_apic_timer_interrupt+0x99\n         1     22.37 us     22.37 us     22.37 us     rwlock:R   ep_poll_callback+0x2d\n                        0xffffffff9d040555  _raw_read_lock_irqsave+0x45\n                        0xffffffff9c9bc81d  ep_poll_callback+0x2d\n                        0xffffffff9c702813  __wake_up_common+0x73\n                        0xffffffff9c7029a2  __wake_up_common_lock+0x82\n                        0xffffffff9cf10f25  unix_write_space+0x55\n                        0xffffffff9cda6343  sock_wfree+0x93\n                        0xffffffff9cf17af4  unix_destruct_scm+0x84\n                        0xffffffff9cdaecc0  skb_release_head_state+0x20\n\n=== output for debug ===\n\nbad: 0, total: 14\nbad rate: 0.00 %\nhistogram of failure reasons\n       task: 0\n      stack: 0\n       time: 0\n       data: 0\n</code></pre> <p>The debug output at the end might look different as it\u2019s changed recently.</p> <p>Here is the list of relevant options:</p> <ul> <li><code>--max-stack</code> NUM : maximum depth of stack trace to collect.  The default value is 8.</li> <li><code>--stack-skip</code> NUM : how many entries to skip before collecting the stack trace.  The default value is 4.</li> </ul> <p>If you know a specific lock is very contended, you can use the lock filter (<code>-L ffff9f88c0248000</code>) to see the contention for the lock only. To get the address or symbol name (if available), run the tool with <code>-l</code> option to output them first.  See below (\u201cBy lock\u201d section).</p> <pre><code># perf lock con -ab -L ffff9f88c0248000 sleep 1\n contended   total wait     max wait     avg wait         type   caller\n\n     39412      1.58 s     123.50 us     40.15 us     spinlock   __cache_free_alien+0x6c\n</code></pre> <p>In this example, all the contention came from the same stack trace and that\u2019s why it showed a single entry.  But it could have multiple entries if the contention has diverse paths.</p> <p>Or you can pass a lock name (<code>-L jiffies_lock</code>).</p> <pre><code># perf lock con -ab -L jiffies_lock sleep 1\n contended   total wait     max wait     avg wait         type   caller\n\n         3     24.47 us     12.09 us      8.16 us     spinlock   tick_irq_enter+0xf0\n</code></pre>"},{"location":"lock-contention/#by-task","title":"By task","text":"<p>It\u2019s possible to collect lock stats by task using the <code>-t</code> (<code>--threads</code>) option.</p> <pre><code># perf lock con -abt sleep 1\n contended   total wait     max wait     avg wait          pid   comm\n\n         6    173.91 us    114.87 us     28.99 us         7738   chrome\n         1    124.70 us    124.70 us    124.70 us        54858   kworker/4:0\n         1     41.45 us     41.45 us     41.45 us         7740   ThreadPoolForeg\n         1     19.41 us     19.41 us     19.41 us         7742   ThreadPoolForeg\n         1      4.25 us      4.25 us      4.25 us            0   swapper\n         1      2.25 us      2.25 us      2.25 us         7733   Chrome_ChildIOT\n         1      2.24 us      2.24 us      2.24 us         5516   pipewire-pulse\n         1       900 ns       900 ns       900 ns        56628   kworker/4:1\n</code></pre> <p>You can only see contentions for mutex using the <code>-Y mutex</code> option.</p> <pre><code># perf lock con -abt -Y mutex sleep 1\n contended   total wait     max wait     avg wait          pid   comm\n\n         2    346.15 us    203.47 us    173.08 us        60409   kworker/7:0\n         2    294.77 us    164.66 us    147.38 us        55417   kworker/7:2\n</code></pre> <p>The perf tool v6.3 added the <code>-o</code> option to track lock owners instead of waiters.  This is only available with BPF.</p> <pre><code># perf lock con -abto -Y mutex sleep 1\n contended   total wait     max wait     avg wait          pid   comm\n\n         1    199.45 us    199.45 us    199.45 us      1091507   kworker/2:0\n         1    149.16 us    149.16 us    149.16 us         3583   NetworkManager\n       146     63.42 us     12.50 us       434 ns           -1   Unknown\n</code></pre> <p>You can get the stack trace of the owner using PID like with this script.</p> <pre><code># perf lock con -abtoq -Y mutex -x, sleep 1 2&gt;&amp;1 | cut -d, -f5 | tr -d ' ' | \\\n  awk '{ system(\u201ccat /proc/$$1/stack\u201d); }'\n</code></pre>"},{"location":"lock-contention/#by-lock","title":"By lock","text":"<p>Also you can get per-lock contention stats using the <code>-l</code> (lower L, also with <code>--lock-addr</code>) option.</p> <pre><code># perf lock con -abl sleep 1\n contended   total wait     max wait     avg wait            address   symbol\n\n        15      2.57 ms    187.89 us    171.09 us   ffffa64fdb3f11b8    (mutex)\n         9     66.01 us     10.37 us      7.33 us   ffffa105becb45c0   mmap_lock (rwsem)\n         7     43.95 us      9.12 us      6.28 us   ffffa105bf7f45c0   mmap_lock (rwsem)\n        12      3.28 us       740 ns       273 ns   ffff9f88cf26a660   mmap_lock (rwsem)\n         1      2.27 us      2.27 us      2.27 us   ffffa105bda345c0    (rwlock)\n         2      2.03 us      1.46 us      1.01 us   ffff9f88cf26a160    (mutex)\n         1      1.91 us      1.91 us      1.91 us   ffffffff92a06e00   jiffies_lock (spinlock)\n         1      1.78 us      1.78 us      1.78 us   ffffa0060d8745c0    (mutex)\n         1      1.50 us      1.50 us      1.50 us   ffffffff92ecdad0   input_pool (spinlock)\n         1      1.16 us      1.16 us      1.16 us   ffffa0060e7345c0    (spinlock)\n         1       240 ns       240 ns       240 ns   ffffffff92e99800   kernfs_open_file_mutex (mutex)\n         1       220 ns       220 ns       220 ns   ffff9f88cf9c53e0    (spinlock)\n</code></pre> <p>The symbols are displayed when found in the kallsysms and followed by lock type name.  This output can be useful to apply filters for other modes.</p> <p>The perf tool v6.3 added more symbols for dynamic locks like \"mmap_lock\" and \"siglock\" as well as some global locks which lack symbols like \"rq_lock\".  This is done by BPF so you need the <code>-b</code> option.</p>"},{"location":"lock-contention/#by-cgroup","title":"By cgroup","text":"<p>You can also get per-cgroup lock contention stats using <code>--lock-cgroup</code> option.</p> <pre><code># perf lock con -ab --lock-cgroup -E 2 sleep 3\n   contended   total wait     max wait     avg wait   cgroup\n\n         214      9.24 ms    338.39 us     43.18 us   /\n         782      1.56 ms     23.21 us      2.00 us   /sys\n</code></pre> <p>You can also use other filter options (like <code>-L</code> or <code>-Y</code>) together to limit the target lock if needed.</p> <p>The perf tool v6.7 added this option.  Please check if you are using the recent version.</p>"},{"location":"lock-contention/#with-vs-without-bpf","title":"With vs. without BPF","text":"<p>Using BPF for lock contention analysis is good for quick live debugging since it\u2019d be more efficient.  But as it doesn\u2019t save the result, each run might report different data depending on the system characteristics.  And the BPF can give more detailed information about the lock because it can access kernel internals.  But the BPF programs should be written with care to handle multiple kernel versions properly since some kernel data structure it accesses (like owner) changed over time.</p> <p>These options work only when BPF is used:</p> <ul> <li><code>--map-nr-entries</code> NUM : max number of BPF map entries.     This controls memory usage of BPF maps.  The default is 16384     (which means around 2~3MB of memory is used by the BPF maps with     the default options).</li> </ul> <p>To use this tool without BPF, you need to run perf lock record command first.  But it\u2019d cause some disk IO unless it\u2019s directed to a pipe. Also saving the trace data in a ring buffer and then to a file can cause data loss.  Running perf lock contention command on the save data would give a consistent result but it has a limited functionality than the BPF.</p> <p>Note that perf lock record and perf lock report used to work with lockdep - kernel lock dependency checker - which uses a different set of tracepoints.  It\u2019d not be recommended to run this command when the kernel enabled the lockdep because it can confuse the tool.</p> <p>The collection target options like <code>-a</code>, <code>-C</code>, <code>-p</code> and <code>--tid</code> should be used during the record.  Then the rest will work just like the BPF case.</p>"},{"location":"man-pages/","title":"Man Pages","text":"<p>The kernel API is documented in the manual page for perf_event_open.</p> <p>These are the links to the <code>man-pages</code> for the <code>perf</code> tool:</p> <ul> <li>perf</li> <li>perf annotate</li> <li>perf archive</li> <li>perf arm-spe</li> <li>perf bench</li> <li>perf buildid-cache</li> <li>perf buildid-list</li> <li>perf c2c</li> <li>perf config</li> <li>perf daemon</li> <li>perf data</li> <li>perf diff</li> <li>perf dlfilter</li> <li>perf evlist</li> <li>perf ftrace</li> <li>perf help</li> <li>perf inject</li> <li>perf intel-pt</li> <li>perf iostat</li> <li>perf kallsyms</li> <li>perf kmem</li> <li>perf kvm</li> <li>perf kwork</li> <li>perf list</li> <li>perf lock</li> <li>perf mem</li> <li>perf probe</li> <li>perf record</li> <li>perf report</li> <li>perf sched</li> <li>perf script</li> <li>perf script-perl</li> <li>perf script-python</li> <li>perf stat</li> <li>perf test</li> <li>perf timechart</li> <li>perf top</li> <li>perf trace</li> <li>perf version</li> </ul>"},{"location":"man-pages/#latest-man-pages","title":"Latest Man Pages","text":"<p>The latest source is available in the perf-tools-next tree under <code>tools/perf/Documents</code>.</p> <ul> <li>perf</li> <li>perf annotate</li> <li>perf archive</li> <li>perf arm-spe</li> <li>perf bench</li> <li>perf buildid-cache</li> <li>perf buildid-list</li> <li>perf c2c</li> <li>perf config</li> <li>perf daemon</li> <li>perf data</li> <li>perf diff</li> <li>perf dlfilter</li> <li>perf evlist</li> <li>perf ftrace</li> <li>perf help</li> <li>perf inject</li> <li>perf intel-pt</li> <li>perf iostat</li> <li>perf kallsyms</li> <li>perf kmem</li> <li>perf kvm</li> <li>perf kwork</li> <li>perf list</li> <li>perf lock</li> <li>perf mem</li> <li>perf probe</li> <li>perf record</li> <li>perf report</li> <li>perf sched</li> <li>perf script</li> <li>perf script-perl</li> <li>perf script-python</li> <li>perf stat</li> <li>perf test</li> <li>perf timechart</li> <li>perf top</li> <li>perf trace</li> <li>perf version</li> <li>perf amd-ibs</li> </ul>"},{"location":"man-pages/#others","title":"Others:","text":"<ul> <li>arm-coresight.txt?h=perf-tools-next</li> <li>android.txt?h=perf-tools-next</li> <li>build-xed.txt?h=perf-tools-next</li> <li>perf.data-file-format.txt?h=perf-tools-next</li> <li>examples.txt?h=perf-tools-next</li> <li>guest-files.txt?h=perf-tools-next</li> <li>jitdump-specification.txt?h=perf-tools-next</li> <li>intel-pt.txt?h=perf-tools-next</li> <li>cat-texi.perl</li> <li>intel-bts.txt?h=perf-tools-next</li> <li>Build.txt?h=perf-tools-next</li> <li>intel-hybrid.txt?h=perf-tools-next</li> <li>perfconfig.example</li> <li>topdown.txt?h=perf-tools-next</li> <li>security.txt?h=perf-tools-next</li> <li>callchain-overhead-calculation.txt?h=perf-tools-next</li> <li>perf.data-directory-format.txt?h=perf-tools-next</li> <li>jit-interface.txt?h=perf-tools-next</li> <li>tips.txt?h=perf-tools-next</li> <li>itrace.txt?h=perf-tools-next</li> <li>guestmount.txt?h=perf-tools-next</li> <li>db-export.txt?h=perf-tools-next</li> </ul>"},{"location":"man-pages/#kernel-version","title":"Kernel Version","text":"<p>This page links the each document to the <code>linux-next</code> kernel branch.</p>"},{"location":"montecito/","title":"Montecito","text":""},{"location":"montecito/#intel-itanium-2-montecito-processor-pmu","title":"Intel\u00ae Itanium\u00ae 2 Montecito\u00ae processor PMU","text":""},{"location":"montecito/#introduction","title":"Introduction","text":"<p>Intel defines the architected PMU in the 'Intel IA-64 Architecture Software Developer's Manual'. However the architected PMU is a bare bone version of what is actually implemented. It is noteworthy that the Itanium 2 PMU has not changed too much, so support of the whole familly does not require rewriting the tools for each member of the familly. Therefore readers interrested in the capabilities of the Itanium PMU should go directly to the model specific updated documentation of a processor's functionality.</p> <p>The Itanium-1 (Merced) is obsolete, so there's two PMU implementations that are available: The McKinley class PMU (with 4 counters), and the Montecito class PMU (with 12 counters). The Montecito processor supports hardware threads (hyperthreading), so the 4 architected counters allow monitoring of activity of the whole core or the hardware thread, while the 8 new counters can only monitor thread activity.</p>"},{"location":"montecito/#overview","title":"Overview","text":"<p>Itanium defines configuration and data registers: PMC, PMDs. Counting registers are paired PMC/PMD, where you program what the counter will count in the PMC and read the actual counter in the PMD. Other PMC/PMDs that are not be counters may not be paired-up.</p> <p>The Itanium PMU is a synchronized subsystem with a global state, where all counters can be started or stopped synchronously. When a counter wraps around, it can trigger a PMU overflow interrupt and freeze the whole PMU, which allows for consistent measurment of multiple events. The state of the PMU can be read in the overflow PMCs. Counters are 47bits physically but presented as a 64-bit sign extended entity.</p> <p>The PMU can filter events through multiple mechanisms to focus on specific areas. It can filter by privilege level with a counter's plm bitmaks. It can filter by instruction op-codes, by virtual address range using the debug registers.</p> <p>The PMU also has an '''EAR''', event address registers which are special PMCs &amp; PMDs to collect address traces and memory latencies; and the ETB, the event trace buffer, to collect branch history.</p> <p></p> <p>Montecito control registers go beyond controlling event counters. The following picture shows the bit field configuration for the control registers.</p> <p></p> <p>Brief description:</p> <ul> <li>CNT: regular performance counters configuration</li> <li>OVF: overflow bitmask. A bit set to 1 indicates the associated event counter overflowed. PMC0.fr indicates that the whole PMU was frozen by an overflowing counter.</li> <li>IARC: filter event collection to a range of instruction addresses. Events happening while instructions are outside that range will be ignored.</li> <li>OM: filter event collection to specific instruction op-codes.</li> <li>MPEC: filter event collection to specific memory events.</li> <li>IEAR: gather a trace sample for specific instruction events into the EAR.</li> <li>DEAR: gather a trace sample specific data event into the EAR.</li> <li>BTB: collect a trace stack of branches into the ETB buffer.</li> </ul>"},{"location":"montecito/#external-links","title":"External links","text":"<ul> <li>Wikipedia Intel Itanium</li> <li>Wikipedia Montecito processor</li> <li>Intel (Intel\u00ae Itanium\u00ae Architecture)</li> <li>Intel (Introduction to Microarchitectural Optimization for Itanium2 Processors)</li> <li>Intel (Dual-Core Update to the Intel\u00ae Itanium\u00ae 2 Processor Reference Manual) (PDF 2.29MB)</li> </ul> <p>Last edit by: --Dantruong 01:48, 28 August 2009 (UTC)</p>"},{"location":"nehalem/","title":"Nehalem","text":""},{"location":"nehalem/#intel-x86-64-pmu-nehalem","title":"Intel x86-64 PMU (Nehalem)","text":"<p>The x86-64 PMUs are specific to each underlying architecture. The Netburst architecture of the Pentium-4 has given way to the Core architecture, in use in Nehalem, i7 processors.</p> <p>The recent PMUs seem to be somewhat structured similarly across Core and Atom CPU models.</p>"},{"location":"nehalem/#pmu-overview","title":"PMU overview","text":"<p>The diagram of PMU registers shows the registers available depending on which processor family you are using. You are offered at least 4 counters.</p> <p></p> <p>The Nehalem PMU supports a hardware bufering scheme to collect multiple samples from the PMU. When a counter overflows, the CPU interrupts into firmware, which in turn copies the counters into a PEBS buffer record. The following graph shows the indirection levels and the content of each record.</p> <p></p>"},{"location":"pcl-internals/","title":"PCL core kernel internals","text":""},{"location":"pcl-struct/","title":"PCL core kernel data structures","text":""},{"location":"perf-tool-internals/","title":"perf internals","text":""},{"location":"perf-tools-support-for-intel-processor-trace/","title":"Perf tools support for Intel\u00ae Processor Trace","text":""},{"location":"perf-tools-support-for-intel-processor-trace/#introduction","title":"Introduction","text":""},{"location":"perf-tools-support-for-intel-processor-trace/#what-is-intel-processor-trace","title":"What is Intel\u00ae Processor Trace","text":"<p>Intel processors (Broadwell or newer, or Apollo Lake or newer) have a performance analysis and debugging feature called Intel\u00ae Processor Trace, or Intel\u00ae PT for short. Intel PT essentially provides control flow tracing, and you can get all the technical details in the Intel Processor Trace chapter in the Intel SDM.</p> <p>Control flow tracing is different from other kinds of performance analysis and debugging.  It provides fine-grained information on branches taken in a program, but that means there can be a vast amount of trace data.  Such an enormous amount of trace data creates a number of challenges, but it raises the central question: how to reduce the amount of trace data that needs to be captured.  That inverts the way performance analysis is normally done.  Instead of taking a test case and creating a trace of it, you need first to create a test case that is suitable for tracing.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#reducing-and-handling-the-massive-amount-of-trace-data","title":"Reducing and handling the massive amount of trace data","text":"<p>Intel PT can potentially produce hundreds of megabytes of trace data per CPU per second.  That can be at a faster rate than it can be recorded to file (resulting in trace data loss), and sometimes faster even than can be recording to memory (resulting in overflow packets).</p> <p><code>perf</code> tools support output to memory buffers.  CPU overhead is low, but memory bandwidth consumption can be significant.  <code>perf</code> tools do not support output of Intel PT to Intel\u00ae Trace Hub.</p> <p>Here are some ways for reducing and handling the massive amount of trace data:</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#shorten-the-tracing-time","title":"Shorten the tracing time","text":"<p>Whereas statistical sampling can generally handle arbitrarily large test cases, to reduce the massive amount Intel PT trace data, test cases need to be created that provide a small representative set of operations to trace.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#kernel-only-tracing","title":"Kernel-only tracing","text":"<p>Typically, the kernel does not do particularly CPU intensive operations, making it possible to trace for longer periods.  Tracing the kernel-only can be useful for analyzing latencies.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#snapshots","title":"Snapshots","text":"<p><code>perf</code> tools support the ability to make snapshots of Intel PT trace.  A snapshot can be made at any time during recording by sending signal USR2 to <code>perf</code>.  The snapshot size is configurable.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#sampling","title":"Sampling","text":"<p><code>perf</code> tools support adding Intel PT traces (up to 60 KiB per sample) onto samples of other events.  The makes it possible, for example, to get extended call chains or branch stacks.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#address-filtering","title":"Address filtering","text":"<p><code>perf</code> tools support specifying Intel PT address filters, refer to the <code>--filter</code> option of <code>perf record</code>.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#process-only-a-fraction-of-the-data-collected","title":"Process only a fraction of the data collected","text":"<p>It is possible to decode only a fraction of a recorded trace by setting time ranges (<code>--time</code> option of <code>perf script</code> or <code>perf report</code>) or specifying CPUs (<code>--cpu</code> option of <code>perf script</code> or <code>perf report</code>).</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-pt-in-context","title":"Intel PT in context","text":"<p>The following paragraphs provide some context for Intel PT:</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-pt-vs-performance-counters","title":"Intel PT vs Performance Counters","text":"<p>Normal performance analysis is done using performance counters and performance monitoring events.  Counters can be used to provide overall statistics, which is what the <code>perf stat</code> tool does, or to provide statistical sampling which is what <code>perf record</code> / <code>perf report</code> do.</p> <p>There are lots and lots of different performance events, not to mention software events, probes and tracepoints.</p> <p>By comparison, Intel PT fills a niche.  People unfamiliar with normal performance analysis and debugging, perhaps should not start their learning with Intel PT.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-pt-vs-function-profiling","title":"Intel PT vs Function Profiling","text":"<p>Function profiling records function entry and exit, but usually requires programs to be re-compiled for that purpose.  It has the advantages of flexible filtering and sophisticated tools.</p> <p>Intel PT can be used to provide a call trace without re-compiling a program, and can trace both user space and kernel space, but with the challenges of massive trace data described above.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-pt-vs-last-branch-record-lbr","title":"Intel PT vs Last Branch Record (LBR)","text":"<p>LBR can store branches, filtering different branch types, and providing finer timing than Intel PT.  LBR can provide additional information that Intel PT does not, such as branch prediction \"misses\".  Intel PT, however, can record significantly longer branch traces.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-pt-vs-branch-trace-store-bts","title":"Intel PT vs Branch Trace Store (BTS)","text":"<p>BTS could be considered the predecessor to Intel PT.  It records taken branches and other changes in control flow such as interrupts and exceptions, but it has much greater overhead than Intel PT, and does not provide timing information.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-pt-miscellaneous-abilities","title":"Intel PT miscellaneous abilities","text":"<p>Intel PT also has some miscellaneous abilities.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#virtualization","title":"Virtualization","text":"<p>Intel PT can trace through VM Entries / Exits, <code>perf</code> tools have support for tracing a host and guests. Refer [[#Intel_PT_man_page |Intel PT man page]]</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-transactional-synchronization-extensions-intel-tsx","title":"Intel\u00ae Transactional Synchronization Extensions (Intel\u00ae TSX)","text":"<p>Intel PT traces transactions including aborted transactions.  That is Intel PT will show the instructions in the incomplete transaction and the subsequent transaction abort.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#power-events-and-c-states","title":"Power events and C-States","text":"<p>Some Intel Atom\u00ae processors support reporting C-state changes.  All Intel PT implementations support reporting of CPU frequency changes.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#pebs-via-pt","title":"PEBS-via-PT","text":"<p>Some Intel Atom\u00ae processors support recording adaptive PEBS records into the Intel PT trace.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#ptwrite","title":"PTWRITE","text":"<p>Hardware that supports it can write directly to the Intel PT trace using an instruction,  'ptwrite'.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#can-i-use-intel-pt","title":"Can I use Intel PT","text":"<p>Because Intel PT is a hardware feature, you need hardware that supports it, and also a Linux kernel that has support. Support was added to Linux in version 4.2 and nowadays, most Linux distributions have a kernel more recent than that, so the simple way to tell whether you can use Intel PT is to check whether the directory /sys/devices/intel_pt exists.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-pt-man-page","title":"Intel PT man page","text":"<p>The online perf Intel PT man page is not necessarily the latest version, howeverthe wiki has a copy that may be more up-to-date: perf Intel PT man page.  Also the man page source in the Linux repository is quite readable: perf Intel PT man page source</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#other-tools","title":"Other tools","text":"<p>It is not necessary to use <code>perf</code> to use Intel PT. Here are some other tools.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#gdb","title":"GDB","text":"<p>Get Intel PT branch traces within the GNU Debugger GDB</p> <p>Note GDB needs to be built with libipt (can be checked with \"ldd <code>which gdb</code> | grep ipt\"), unfortunately many are still not, but there is an Intel version of GDB in Intel\u00ae System Studio for linux.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#fuzzers","title":"Fuzzers","text":"<p>Some feedback-driven fuzzers (such as honggfuzz) utilize Intel PT.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#libipt","title":"libipt","text":"<p>libipt is an Intel\u00ae Processor Trace decoder library that lets you build your own tools.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-vtunetm","title":"Intel\u00ae VTune\u2122","text":"<p>Intel\u00ae VTune\u2122 Profiler for Linux.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#satt","title":"SATT","text":"<p>SATT Software Analyze Trace Tool This tool requires building and installing a custom kernel module</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#other-resources","title":"Other resources","text":"<ul> <li>Cheat sheet for Intel Processor Trace with Linux perf and gdb</li> <li>perf Intel PT man page, perf Intel PT man page (wiki version) and</li> <li>perf Intel PT man page source</li> <li>LWN article: Adding Processor Trace support to Linux</li> </ul>"},{"location":"perf-tools-support-for-intel-processor-trace/#getting-set-up","title":"Getting set up","text":"<p><code>perf</code> tools are packaged based on the kernel version, which means the version of <code>perf</code> provided by Linux distributions is always quite old, whereas updates to Intel PT support are happening all the time. That means, for the latest Intel PT features, we really need to download and build that latest <code>perf</code>.</p> <p>For other purposes, <code>perf</code> on modern Linux is usually fine.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#permissions-and-limits","title":"Permissions and limits","text":"<p>Typically regular userids do not have permission to trace the kernel or other processes.  It is '''essential''' to understand <code>Perf Events and tool security</code>.</p> <p>Intel PT benefits from large buffers which is controlled by the RLIMIT_MEMLOCK limit or the perf_event_mlock_kb setting or the CAP_IPC_LOCK capability.  For kernel tracing with Intel PT, <code>perf</code> benefits from access to /proc/kcore.</p> <p>The examples on this page use <code>perf</code> with extra privileges.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#adding-capabilities-to-perf","title":"Adding capabilities to <code>perf</code>","text":"<p>To give <code>perf</code> extra privileges (refer to Perf Events and tool security), we can add capabilities to the perf executable.  Note these capabilities are not inherited by programs started by perf.</p> <p>First, we can create a new group and add ourself.  This only needs to be done once.</p> <pre><code>$ sudo groupadd perf_users\n$ sudo usermod -a -G perf_users $(whoami)\n</code></pre> <p>We will need to logout and login again to pick up the new <code>perf_users</code> group.</p> <p>Now we can add capabilities, making <code>perf</code> executable by only <code>root</code> and <code>perf_users</code>.</p> <pre><code>$ sudo chown root ~/bin/perf\n$ sudo chgrp perf_users ~/bin/perf\n$ sudo chmod 550 ~/bin/perf\n$ sudo setcap \"cap_ipc_lock,cap_sys_ptrace,cap_sys_admin,cap_syslog=ep\" ~/bin/perf\n$ getcap ~/bin/perf\n~/bin/perf = cap_ipc_lock,cap_sys_ptrace,cap_sys_admin,cap_syslog+ep\n</code></pre> <p>When not using <code>perf</code>, we can remove the capabilities:</p> <pre><code>$ sudo setcap -r ~/bin/perf\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#updating-perf-tools","title":"Updating perf tools","text":"<p>To fetch and update the tools again in the future, we can do the following:</p> <pre><code>$ cd ~/git/linux\n$ git pull\n$ rm tools/perf/PERF-VERSION-FILE\n$ make -C tools/perf install\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#getting-debug-packages","title":"Getting debug packages","text":"<p>Debug packages are necessary to map addresses to function names.  Ubuntu provides -dbg and -dbgsym style packages, refer Debug Symbol Packages - Ubuntu Wiki.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-tracing-your-own-code-hello-world","title":"Example: Tracing your own code : Hello World","text":"<p>Before we start, if we haven't done it already, we will need to install Intel X86 Encoder Decoder (XED)</p> <pre><code>$ cd ~/git\n$ git clone https://github.com/intelxed/mbuild.git mbuild\n$ git clone https://github.com/intelxed/xed\n$ cd xed\n$ ./mfile.py --share\n$ ./mfile.py examples\n$ sudo ./mfile.py --prefix=/usr/local install\n$ sudo ldconfig\n$ find . -type f -name xed\n./obj/wkit/examples/obj/xed\n$ cp ./obj/wkit/examples/obj/xed /usr/local/bin\n</code></pre> <p>Then, we can start with a trivial \"Hello World\" program:</p> <pre><code>$ cat hello.c \n#include &lt;stdio.h&gt;\n\nint main()\n{\n        printf(\"Hello World!\\n\");\n        return 0;\n}\n</code></pre> <p>We can compile it with debugging information:</p> <pre><code>$ gcc -g -o hello hello.c\n</code></pre> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt/cyc,noretcomp/u</code> to get Intel PT with cycle-accurate mode. We can add <code>noretcomp</code> to get a timing information at RET instructions.</li> <li><code>--filter 'filter main @ ./hello'</code> specifies an address filter to trace only main()</li> <li><code>./hello</code> is the workload.</li> </ul> <pre><code>$ perf record -e intel_pt/cyc,noretcomp/u --filter 'filter main @ ./hello' ./hello\nHello World!\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.012 MB perf.data ]\n</code></pre> <p>We can display an instruction trace with source line information and source code:</p> <pre><code>$ perf script --insn-trace --xed -F+srcline,+srccode\n           hello 20444 [003] 28111.955861407:      5635beeae149 main+0x0 (/home/ahunter/git/linux/hello)\n  hello.c:4             nop %edi, %edx\n|4        {\n           hello 20444 [003] 28111.955861407:      5635beeae14d main+0x4 (/home/ahunter/git/linux/hello)\n  hello.c:4             pushq  %rbp\n           hello 20444 [003] 28111.955861407:      5635beeae14e main+0x5 (/home/ahunter/git/linux/hello)\n  hello.c:4             mov %rsp, %rbp\n           hello 20444 [003] 28111.955861407:      5635beeae151 main+0x8 (/home/ahunter/git/linux/hello)\n  hello.c:5             leaq  0xeac(%rip), %rdi\n|5              printf(\"Hello World!\\n\");\n           hello 20444 [003] 28111.955861407:      5635beeae158 main+0xf (/home/ahunter/git/linux/hello)\n  hello.c:5             callq  0xfffffffffffffef8\n           hello 20444 [003] 28111.955902827:      5635beeae15d main+0x14 (/home/ahunter/git/linux/hello)\n  hello.c:6             mov $0x0, %eax\n|6              return 0;\n           hello 20444 [003] 28111.955902827:      5635beeae162 main+0x19 (/home/ahunter/git/linux/hello)\n  hello.c:7             popq  %rbp\n|7        }\n           hello 20444 [003] 28111.955902938:      5635beeae163 main+0x1a (/home/ahunter/git/linux/hello)\n  hello.c:7             retq  \n</code></pre> <p>We can tidy that up a bit with awk:</p> <pre><code>$ perf script --insn-trace --xed -F-dso,+srcline,+srccode | awk '/hello / {printf(\"\\n%-85s\",$0)} /hello.c:/ {ln=$0;gsub(\"\\t\",\"  \",ln);printf(\"%-58s\",ln)} /^\\|/ {printf(\"%s\",$0)}' \n\n           hello 20444 [003] 28111.955861407:      5635beeae149 main+0x0               hello.c:4     nop %edi, %edx                            |4        {\n           hello 20444 [003] 28111.955861407:      5635beeae14d main+0x4               hello.c:4     pushq  %rbp                               \n           hello 20444 [003] 28111.955861407:      5635beeae14e main+0x5               hello.c:4     mov %rsp, %rbp                            \n           hello 20444 [003] 28111.955861407:      5635beeae151 main+0x8               hello.c:5     leaq  0xeac(%rip), %rdi                   |5               printf(\"Hello World!\\n\");\n           hello 20444 [003] 28111.955861407:      5635beeae158 main+0xf               hello.c:5     callq  0xfffffffffffffef8                 \n           hello 20444 [003] 28111.955902827:      5635beeae15d main+0x14              hello.c:6     mov $0x0, %eax                            |6               return 0;\n           hello 20444 [003] 28111.955902827:      5635beeae162 main+0x19              hello.c:7     popq  %rbp                                |7        }\n           hello 20444 [003] 28111.955902938:      5635beeae163 main+0x1a              hello.c:7     retq\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-tracing-short-running-commands","title":"Example: Tracing short-running commands","text":"<p>It is possible to trace short-running commands entirely.  A very simple example is a trace of 'ls -l'.</p> <p>First, we can get some debug symbols e.g.</p> <pre><code>$ find-dbgsym-packages `which ls`\ncoreutils-dbgsym libpcre2-8-0-dbgsym libselinux1-dbgsym\n$ sudo apt-get install coreutils-dbgsym libpcre2-8-0-dbgsym libselinux1-dbgsym libc6-dbg\n</code></pre> <p>The trace is more interesting if we can drop all file system caches which will force the test case to do I/O instead of reading from a cache.  For how to use <code>/proc/sys/vm/drop_caches</code>, refer to the <code>/proc/sys/vm/drop_caches</code> section in the manual page for /proc.</p> <pre><code>$ sudo bash -c 'echo 3 &gt; /proc/sys/vm/drop_caches'\n</code></pre> <p>This example includes kernel tracing, which requires administrator privileges.</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>--kcore</code> to copy kernel object code from the <code>/proc/kcore image</code> (helps avoid decoding errors due to kernel self-modifying code)</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt/cyc/</code> to get Intel PT with cycle-accurate mode</li> <li><code>ls -l</code> is the workload to trace</li> </ul> <pre><code>$ sudo perf record --kcore -e intel_pt/cyc/ ls -l\ntotal 832\ndrwxrwxr-x  27 user user   4096 Jun  2 11:11 arch\ndrwxrwxr-x   3 user user   4096 Jun  4 08:40 block\ndrwxrwxr-x   2 user user   4096 May 23 15:47 certs\n-rw-rw-r--   1 user user    496 May 23 15:47 COPYING\n-rw-rw-r--   1 user user  99752 Jun  2 11:11 CREDITS\ndrwxrwxr-x   4 user user   4096 Jun  2 11:11 crypto\ndrwxrwxr-x  79 user user   4096 Jun  4 08:40 Documentation\ndrwxrwxr-x 140 user user   4096 May 23 15:47 drivers\ndrwxrwxr-x  79 user user   4096 Jun  4 08:40 fs\ndrwxrwxr-x  10 user user   4096 Jun  4 08:39 heads\ndrwxrwxr-x   3 user user   4096 Jun  4 17:11 hold\ndrwxrwxr-x  30 user user   4096 Jun  2 12:37 include\ndrwxrwxr-x   2 user user   4096 Jun  4 08:40 init\ndrwxrwxr-x   2 user user   4096 Jun  4 08:40 ipc\n-rw-rw-r--   1 user user   1327 May 23 15:47 Kbuild\n-rw-rw-r--   1 user user    595 May 23 15:47 Kconfig\ndrwxrwxr-x  18 user user   4096 Jun  4 08:40 kernel\ndrwxrwxr-x  20 user user  12288 Jun  4 08:40 lib\ndrwxrwxr-x   6 user user   4096 May 23 15:47 LICENSES\n-rw-rw-r--   1 user user 556326 Jun  4 08:40 MAINTAINERS\n-rw-rw-r--   1 user user  61844 Jun  2 11:11 Makefile\ndrwxrwxr-x   3 user user   4096 Jun  4 08:40 mm\ndrwxrwxr-x  72 user user   4096 Jun  4 08:40 net\ndrwx------   3 user user   4096 Jun  4 17:30 perf.data\n-rw-rw-r--   1 user user    727 May 23 15:47 README\ndrwxrwxr-x  30 user user   4096 Jun  2 11:11 samples\ndrwxrwxr-x  16 user user   4096 Jun  4 08:40 scripts\ndrwxrwxr-x  13 user user   4096 Jun  4 08:40 security\ndrwxrwxr-x  26 user user   4096 May 23 15:47 sound\ndrwxrwxr-x  37 user user   4096 Jun  4 12:11 tools\ndrwxrwxr-x   3 user user   4096 May 23 15:47 usr\ndrwxrwxr-x   4 user user   4096 May 23 15:47 virt\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 1.041 MB perf.data ]\n</code></pre> <p>Rather than look at the trace directly, we will instead create a GUI call graph.  To do that we will use 2 python scripts.  The first, <code>export-to-sqlite.py</code> will export the trace data to a SQLite3 database.  The second <code>exported-sql-viewer.py</code> will create a GUI call graph.</p> <p>We can install support for the script <code>export-to-sqlite.py</code>, using python3 (remember we built perf with python3 support not python2) as follows:</p> <pre><code>$ sudo apt-get install sqlite3 python3-pyside2.qtsql libqt5sql5-psql\n</code></pre> <p>Refer to the script export-to-sqlite.py for more information. </p> <p>Then we can perform the export:</p> <pre><code>$ perf script --itrace=bep -s ~/libexec/perf-core/scripts/python/export-to-sqlite.py ls-example.db branches calls\n2020-06-04 17:30:59.646366 Creating database ...\n2020-06-04 17:30:59.656860 Writing records...\n2020-06-04 17:31:21.215702 Adding indexes\n2020-06-04 17:31:21.408810 Dropping unused tables\n2020-06-04 17:31:21.427048 Done\n</code></pre> <p>We can install support for the script <code>exported-sql-viewer.py</code>, using python3 (remember we built perf with python3 support not python2) as follows:</p> <pre><code>$ sudo apt-get install python3-pyside2.qtcore python3-pyside2.qtgui python3-pyside2.qtsql python3-pyside2.qtwidgets\n</code></pre> <p>We can see the call graph, running the script as below, and selecting 'Reports' then 'Context-Sensitive Call Graph'</p> <pre><code>$ python3 ~/libexec/perf-core/scripts/python/exported-sql-viewer.py ls-example.db\n</code></pre> <p>We can drill down the trace to see where most of the time is spent.  In this case, waiting on I/O in the lstat system call.</p> <pre><code>Call Path                                                                         Object         Count   Time (ns)   Time (%)   Insn Cnt   Insn Cnt (%)   Cyc Cnt   Cyc Cnt (%)    IPC   Branch Count   Branch Count (%)\n\u25b6 perf\n\u25bc ls\n  \u25bc 41672:41672\n    \u25b6 setup_new_exec                                                              [kernel]           1         290        0.0        727            0.0      1230           0.0   0.59             68                0.0\n    \u25b6 native_sched_clock                                                          [kernel]           1           0        0.0          0            0.0         0           0.0      0              1                0.0\n    \u25b6 sched_clock                                                                 [kernel]           1           0        0.0          0            0.0         0           0.0      0              1                0.0\n    \u25b6 sched_clock_cpu                                                             [kernel]           1           0        0.0          0            0.0         0           0.0      0              1                0.0\n    \u25b6 local_clock                                                                 [kernel]           1           0        0.0         48            0.0        49           0.0   0.98              1                0.0\n    \u25b6 __perf_event_header__init_id.isra.0                                         [kernel]           1           1        0.0         21            0.0         5           0.0   4.20              3                0.0\n    \u25b6 perf_event_comm_output                                                      [kernel]           1         123        0.0        506            0.0       517           0.0   0.98             73                0.0\n    \u25b6 perf_iterate_ctx                                                            [kernel]           1          65        0.0        199            0.0       273           0.0   0.73             23                0.0\n    \u25b6 perf_iterate_sb                                                             [kernel]           1           0        0.0          7            0.0         3           0.0   2.33              1                0.0\n    \u25b6 perf_event_comm                                                             [kernel]           1           0        0.0          9            0.0         8           0.0   1.13              1                0.0\n    \u25b6 __set_task_comm                                                             [kernel]           1           0        0.0          7            0.0         2           0.0   3.50              1                0.0\n    \u25b6 load_elf_binary                                                             [kernel]           1      454912        2.3     143405            1.6    255719           2.5   0.56          16318                1.6\n    \u25b6 search_binary_handler                                                       [kernel]           1          11        0.0         28            0.0        46           0.0   0.61              6                0.0\n    \u25b6 __do_execve_file.isra.0                                                     [kernel]           1         554        0.0        357            0.0      2319           0.0   0.15             38                0.0\n    \u25b6 __x64_sys_execve                                                            [kernel]           1           0        0.0          6            0.0        17           0.0   0.35              1                0.0\n    \u25b6 do_syscall_64                                                               [kernel]           1        5635        0.0       3227            0.0     23637           0.2   0.14            438                0.0\n    \u25b6 entry_SYSCALL_64_after_hwframe                                              [kernel]           1         217        0.0         48            0.0       906           0.0   0.05              4                0.0\n    \u25bc _start                                                                      ld-2.31.so         1    19015524       97.6    8862084           98.4   9861482          97.2   0.90         980661               98.3\n      \u25b6 page_fault                                                                [kernel]           1        3259        0.0       5925            0.1     13626           0.1   0.43            510                0.1\n      \u25b6 _dl_start                                                                 ld-2.31.so         1      956115        5.0     915528           10.3   1665766          16.9   0.55          94430                9.6\n      \u25b6 _dl_init                                                                  ld-2.31.so         1      298497        1.6     283430            3.2    600916           6.1   0.47          28996                3.0\n      \u25bc _start                                                                    ls                 1    17757387       93.4    7657198           86.4   7580061          76.9   1.01         856721               87.4\n        \u25b6 page_fault                                                              [kernel]           1        2073        0.0       7214            0.1      8685           0.1   0.83            566                0.1\n        \u25bc __libc_start_main                                                       libc-2.31.so       1    17754971      100.0    7649972           99.9   7569935          99.9   1.01         856153               99.9\n          \u25b6 __cxa_atexit                                                          libc-2.31.so       1        1836        0.0       5944            0.1      7699           0.1   0.77            503                0.1\n          \u25b6 __libc_csu_init                                                       ls                 1        3685        0.0      12103            0.2     15466           0.2   0.78            971                0.1\n          \u25b6 _setjmp                                                               libc-2.31.so       1         176        0.0         32            0.0       797           0.0   0.04              4                0.0\n          \u25bc main                                                                  ls                 1    17584228       99.0    7263996           95.0   7282964          96.2   1.00         815563               95.3\n            \u25b6 set_program_name                                                    ls                 1        1980        0.0       2590            0.0      8318           0.1   0.31            306                0.0\n            \u25b6 unknown                                                             ls                 1       79537        0.5     219668            3.0    332415           4.6   0.66          24704                3.0\n            \u25b6 unknown                                                             ls                 1         446        0.0        297            0.0      1866           0.0   0.16             35                0.0\n            \u25b6 unknown                                                             ls                 1         199        0.0        449            0.0       831           0.0   0.54             47                0.0\n            \u25b6 atexit                                                              ls                 1          80        0.0          9            0.0       122           0.0   0.07              8                0.0\n            \u25b6 unknown                                                             ls                 1        3420        0.0        829            0.0     14809           0.2   0.06            105                0.0\n            \u25b6 set_quoting_style                                                   ls                 1           0        0.0          0            0.0         0           0.0      0              1                0.0\n            \u25b6 unknown                                                             ls                 7        1023        0.0       3125            0.0      4292           0.1   0.73            501                0.1\n            \u25b6 unknown                                                             ls                 1         512        0.0        488            0.0      2134           0.0   0.23             60                0.0\n            \u25b6 unknown                                                             ls                 2        3091        0.0       6780            0.1     12494           0.2   0.54            642                0.1\n            \u25b6 human_options                                                       ls                 1         445        0.0       1325            0.0      1868           0.0   0.71            217                0.0\n            \u25b6 get_quoting_style                                                   ls                 1           0        0.0          0            0.0         0           0.0      0              1                0.0\n            \u25b6 clone_quoting_options                                               ls                 2         444        0.0        548            0.0      1862           0.0   0.29             58                0.0\n            \u25b6 set_char_quoting                                                    ls                 1           0        0.0          0            0.0         0           0.0      0              1                0.0\n            \u25b6 argmatch                                                            ls                 1         360        0.0        211            0.0      1489           0.0   0.14             28                0.0\n            \u25b6 hard_locale                                                         ls                 1         135        0.0         85            0.0       664           0.0   0.13              8                0.0\n            \u25b6 unknown                                                             ls                 2       14056        0.1      49612            0.7     58942           0.8   0.84           4687                0.6\n            \u25b6 abformat_init                                                       ls                 1       11578        0.1      58235            0.8     48048           0.7   1.21           6651                0.8\n            \u25b6 tzalloc                                                             ls                 1          62        0.0        224            0.0       255           0.0   0.88             19                0.0\n            \u25b6 xmalloc                                                             ls                 1        1642        0.0       2187            0.0      6877           0.1   0.32            214                0.0\n            \u25b6 clear_files                                                         ls                 1         107        0.0         22            0.0       450           0.0   0.05              2                0.0\n            \u25b6 queue_directory                                                     ls                 1         184        0.0        453            0.0       773           0.0   0.59             65                0.0\n            \u25bc print_dir                                                           ls                 1    17464204       99.3    6916440           95.2   6782904          93.1   1.02         777118               95.3\n              \u25b6 unknown                                                           ls                 1         121        0.0         39            0.0       509           0.0   0.08              2                0.0\n              \u25b6 unknown                                                           ls                 1        5298        0.0      12006            0.2     22207           0.3   0.54           1169                0.2\n              \u25b6 clear_files                                                       ls                 1           0        0.0          0            0.0         0           0.0      0              2                0.0\n              \u25b6 unknown                                                           ls                43       19841        0.1      54011            0.8     81698           1.2   0.66           5943                0.8\n              \u25bc gobble_file.constprop.0                                           ls                32    10586230       60.6    4486659           64.9   4423411          65.2   1.01         496893               63.9\n                \u25b6 needs_quoting                                                   ls                32        5639        0.1      17998            0.4     23544           0.5   0.76           2421                0.5\n                \u25b6 unknown                                                         ls                96         732        0.0       2983            0.1      3359           0.1   0.89            290                0.1\n                \u25bc unknown                                                         ls                32     8836035       83.5    3477158           77.5   2937626          66.4   1.18         382210               76.9\n                  \u25bc __lxstat64                                                    libc-2.31.so      32     8835858      100.0    3475998          100.0   2935941          99.9   1.18         382178              100.0\n                    \u25bc entry_SYSCALL_64                                            [kernel]          32     8828726       99.9    3466363           99.7   2905440          99.0   1.19         380853               99.7\n                      \u25bc do_syscall_64                                             [kernel]          32     8825966      100.0    3464667          100.0   2894453          99.6   1.20         380757              100.0\n                        \u25bc __x64_sys_newlstat                                      [kernel]          32     8816599       99.9    3462903           99.9   2866632          99.0   1.21         380458               99.9\n                          \u25bc __do_sys_newlstat                                     [kernel]          32     8816391      100.0    3460695           99.9   2854386          99.6   1.21         380330              100.0\n                            \u25bc vfs_statx                                           [kernel]          32     8814939      100.0    3453687           99.8   2848318          99.8   1.21         379722               99.8\n                              \u25bc user_path_at_empty                                [kernel]          32     8806551       99.9    3436824           99.5   2816689          98.9   1.22         377734               99.5\n                                \u25b6 getname_flags                                   [kernel]          32        3471        0.0      13785            0.4     16445           0.6   0.84           1542                0.4\n                                \u25bc filename_lookup                                 [kernel]          32     8803067      100.0    3422884           99.6   2800182          99.4   1.22         376096               99.6\n                                  \u25bc path_lookupat.isra.0                          [kernel]          32     8801121      100.0    3417967           99.9   2792250          99.7   1.22         375552               99.9\n                                    \u25b6 path_init                                   [kernel]          32         603        0.0       3784            0.1      2854           0.1   1.33            192                0.1\n                                    \u25b6 link_path_walk.part.0                       [kernel]          32         708        0.0       5794            0.2      3316           0.1   1.75            422                0.1\n                                    \u25bc walk_component                              [kernel]          32     8798631      100.0    3404427           99.6   2780753          99.6   1.22         374125               99.6\n                                      \u25b6 lookup_fast                               [kernel]          32        4016        0.0       7158            0.2     16248           0.6   0.44            663                0.2\n                                      \u25bc lookup_slow                               [kernel]          31     8793533       99.9    3392561           99.7   2760139          99.3   1.23         372807               99.6\n                                        \u25b6 down_read                               [kernel]          31         240        0.0       1009            0.0       499           0.0   2.02            186                0.0\n                                        \u25bc __lookup_slow                           [kernel]          31     8792986      100.0    3390994          100.0   2758348          99.9   1.23         372466               99.9\n                                          \u25b6 d_alloc_parallel                      [kernel]          31        5966        0.1      13928            0.4     21691           0.8   0.64           1375                0.4\n                                          \u25bc ext4_lookup                           [kernel]          31     8786755       99.9    3376539           99.6   2736392          99.2   1.23         370998               99.6\n                                            \u25b6 ext4_fname_prepare_lookup           [kernel]          31           0        0.0          0            0.0         0           0.0      0            124                0.0\n                                            \u25b6 __ext4_find_entry                   [kernel]          31       11669        0.1      59063            1.7     49644           1.8   1.19           5687                1.5\n                                            \u25b6 kfree                               [kernel]          62         426        0.0       1888            0.1      2724           0.1   0.69            124                0.0\n                                            \u25b6 __brelse                            [kernel]          31         115        0.0        117            0.0       117           0.0   1.00             31                0.0\n                                            \u25bc __ext4_iget                         [kernel]          31     8770362       99.8    3301339           97.8   2663781          97.3   1.24         363327               97.9\n                                              \u25b6 iget_locked                       [kernel]          31       12625        0.1      28525            0.9     54273           2.0   0.53           3083                0.8\n                                              \u25bc __ext4_get_inode_loc              [kernel]          31     8744348       99.7    3219494           97.5   2553678          95.9   1.26         353658               97.3\n                                                \u25b6 ext4_get_group_desc             [kernel]          31         717        0.0       2139            0.1      3006           0.1   0.71             62                0.0\n                                                \u25b6 ext4_inode_table                [kernel]          46          86        0.0          0            0.0         0           0.0      0             46                0.0\n                                                \u25b6 __getblk_gfp                    [kernel]          31       23459        0.3      77443            2.4     98450           3.9   0.79           8842                2.5\n                                                \u25b6 _cond_resched                   [kernel]          30          43        0.0         12            0.0        23           0.0   0.52            120                0.0\n                                                \u25b6 blk_start_plug                  [kernel]          15           0        0.0          0            0.0         0           0.0      0             30                0.0\n                                                \u25b6 ext4_itable_unused_count        [kernel]          15         198        0.0          0            0.0         0           0.0      0             15                0.0\n                                                \u25b6 __breadahead                    [kernel]         474      505000        5.8    2835900           88.1   2111610          82.7   1.34         310764               87.9\n                                                \u25b6 submit_bh                       [kernel]          15        4421        0.1      27069            0.8     18098           0.7   1.50           2720                0.8\n                                                \u25b6 blk_finish_plug                 [kernel]          15       42049        0.5     172041            5.3    175937           6.9   0.98          16287                4.6\n                                                \u25bc __wait_on_buffer                [kernel]          15     8167641       93.4     102309            3.2    143500           5.6   0.71          13445                3.8\n                                                  \u25b6 _cond_resched                 [kernel]          15         231        0.0        559            0.5      1122           0.8   0.50             60                0.4\n                                                  \u25bc out_of_line_wait_on_bit       [kernel]          15     8167384      100.0     101705           99.4    142275          99.1   0.71          13340               99.2\n                                                    \u25bc __wait_on_bit               [kernel]          15     8167361      100.0     101630           99.9    142183          99.9   0.71          13310               99.8\n                                                      \u25b6 prepare_to_wait           [kernel]          15         812        0.0       1211            1.2      2828           2.0   0.43            105                0.8\n                                                      \u25bc bit_wait_io               [kernel]          15     8166063      100.0      99755           98.2    137321          96.6   0.73          13055               98.1\n                                                        \u25bc io_schedule             [kernel]          15     8165721      100.0      98826           99.1    135309          98.5   0.73          12980               99.4\n                                                          \u25b6 io_schedule_prepare   [kernel]          15         461        0.0        375            0.4      1944           1.4   0.19             30                0.2\n                                                          \u25b6 schedule              [kernel]          15     8165090      100.0      98301           99.5    132656          98.0   0.74          12905               99.4\n                                                      \u25b6 finish_wait               [kernel]          15           0        0.0          0            0.0         0           0.0      0             45                0.3\n                                              \u25b6 crypto_shash_update               [kernel]          62         966        0.0       6204            0.2     12343           0.5   0.50            620                0.2\n                                              \u25b6 ext4_inode_csum.isra.0            [kernel]          31        3712        0.0      19437            0.6     15561           0.6   1.25           2697                0.7\n                                              \u25b6 make_kuid                         [kernel]          31         467        0.0          0            0.0         0           0.0      0            186                0.1\n                                              \u25b6 make_kgid                         [kernel]          31         186        0.0       4470            0.1      2661           0.1   1.68            186                0.1\n                                              \u25b6 make_kprojid                      [kernel]          31         306        0.0       1343            0.0      1313           0.0   1.02            186                0.1\n                                              \u25b6 set_nlink                         [kernel]          31         245        0.0       1017            0.0      1117           0.0   0.91             93                0.0\n                                              \u25b6 ext4_set_inode_flags              [kernel]          31         568        0.0       2213            0.1      2181           0.1   1.01            124                0.0\n                                              \u25b6 _raw_read_lock                    [kernel]          31         534        0.0         93            0.0       200           0.0   0.47             31                0.0\n                                              \u25b6 ext4_ext_check_inode              [kernel]          31        2147        0.0       9174            0.3     12353           0.5   0.74            654                0.2\n                                              \u25b6 __brelse                          [kernel]          31          73        0.0        557            0.0       670           0.0   0.83             31                0.0\n                                              \u25b6 unlock_new_inode                  [kernel]          31         608        0.0       1339            0.0      1578           0.1   0.85            248                0.1\n                                              \u25b6 ext4_set_aops                     [kernel]           7          95        0.0        384            0.0       397           0.0   0.97             21                0.0\n                                            \u25b6 d_splice_alias                      [kernel]          31        3328        0.0      10072            0.3     12639           0.5   0.80           1178                0.3\n                                        \u25b6 up_read                                 [kernel]          31         283        0.0          0            0.0         0           0.0      0             31                0.0\n                                      \u25b6 follow_managed                            [kernel]          31           0        0.0          0            0.0         0           0.0      0             31                0.0\n                                      \u25b6 dput                                      [kernel]          31         656        0.0       1890            0.1      2576           0.1   0.73            279                0.1\n                                    \u25b6 complete_walk                               [kernel]          32         312        0.0        432            0.0      1605           0.1   0.27             77                0.0\n                                    \u25b6 terminate_walk                              [kernel]          32         515        0.0       1170            0.0      2130           0.1   0.55            352                0.1\n                                  \u25b6 restore_nameidata                             [kernel]          32         530        0.0        720            0.0      2693           0.1   0.27             96                0.0\n                                  \u25b6 putname                                       [kernel]          32        1107        0.0        277            0.0       713           0.0   0.39            256                0.1\n                              \u25b6 vfs_getattr                                       [kernel]          32        4552        0.1       7924            0.2     18723           0.7   0.42            853                0.2\n                              \u25b6 path_put                                          [kernel]          32        3010        0.0       3250            0.1      5836           0.2   0.56           1007                0.3\n                            \u25b6 cp_new_stat                                         [kernel]          32         740        0.0       5834            0.2      2933           0.1   1.99            512                0.1\n                        \u25b6 fpregs_assert_state_consistent                          [kernel]          32         103        0.0        523            0.0       575           0.0   0.91             81                0.0\n                        \u25b6 switch_fpu_return                                       [kernel]          15         422        0.0          0            0.0         0           0.0      0             45                0.0\n                    \u25b6 irq_entries_start                                           [kernel]           1        6062        0.1       9283            0.3     25448           0.9   0.36           1260                0.3\n                \u25b6 rpl_lgetfilecon                                                 ls                32       45398        0.4     105988            2.4    191418           4.3   0.55          12026                2.4\n                \u25b6 unknown                                                         ls                32         257        0.0        288            0.0      1077           0.0   0.27             64                0.0\n                \u25b6 file_has_acl                                                    ls                32       47974        0.5     154946            3.5    199782           4.5   0.78          17666                3.6\n                \u25b6 human_readable                                                  ls                64        5859        0.1      17717            0.4     24550           0.6   0.72           1224                0.2\n                \u25b6 gnu_mbswidth                                                    ls                96        2885        0.0      12761            0.3     12586           0.3   1.01           1776                0.4\n                \u25b6 format_user_width                                               ls                32      511932        4.8     360256            8.0    669309          15.1   0.54          39985                8.0\n                \u25b6 getgroup                                                        ls                32     1120258       10.6     313835            7.0    321667           7.3   0.98          35905                7.2\n                \u25b6 umaxtostr                                                       ls                32         251        0.0        926            0.0       612           0.0   1.51             47                0.0\n                \u25b6 xstrdup                                                         ls                32        2645        0.0       8339            0.2     11308           0.3   0.74            986                0.2\n                \u25b6 page_fault                                                      [kernel]           2        2942        0.0       3786            0.1     12322           0.3   0.31            388                0.1\n              \u25b6 process_signals                                                   ls                42         248        0.0        688            0.0      1285           0.0   0.54            126                0.0\n              \u25b6 unknown                                                           ls                 1        3143        0.0       7469            0.1     13138           0.2   0.57            651                0.1\n              \u25b6 sort_files                                                        ls                 1        9564        0.1      47816            0.7     40449           0.6   1.18           4631                0.6\n              \u25b6 unknown                                                           ls                 1     4465654       25.6    1375195           19.9   1259338          18.6   1.09         155028               19.9\n              \u25b6 unknown                                                           ls                 2        4339        0.0       1922            0.0      6816           0.1   0.28            182                0.0\n              \u25b6 unknown                                                           ls                 2         122        0.0         61            0.0       290           0.0   0.21              6                0.0\n              \u25b6 unknown                                                           ls                 2       11181        0.1       4541            0.1     17820           0.3   0.25            561                0.1\n              \u25b6 human_readable                                                    ls                 1         641        0.0        258            0.0      1040           0.0   0.25             20                0.0\n              \u25b6 print_current_files                                               ls                 1     2356845       13.5     925664           13.4    913979          13.5   1.01         111603               14.4\n            \u25b6 unknown                                                             ls                 3         383        0.0        167            0.0       610           0.0   0.27             15                0.0\n          \u25b6 exit                                                                  libc-2.31.so       1      164956        0.9     367844            4.8    262690           3.5   1.40          39106                4.6\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-tracing-power-events-and-cpu-frequency","title":"Example: Tracing power events and CPU frequency","text":"<p>Intel PT can record changes in CPU frequency.</p> <p>This example includes kernel tracing, which requires administrator privileges.</p> <p>To trace power events, we can use <code>perf record</code> with options:</p> <ul> <li><code>-a</code> to trace system wide i.e. all tasks, all CPUs</li> <li><code>-e</code> to select which events, i.e. the following 2:</li> <li><code>intel_pt/branch=0/</code> to get Intel PT but without control flow (branch) information</li> <li><code>power:cpu_idle</code> to get the Intel CPU Idle driver tracepoint</li> <li><code>sleep 1</code> is the workload.  The tracing will stop when the workload finishes, so this is simply a way of tracing for about 1 second.</li> </ul> <p>Note, although only 2 events have been selected, we could add anything else we are interested in.</p> <pre><code>$ sudo perf record -a -e intel_pt/branch=0/,power:cpu_idle sleep 1\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.894 MB perf.data ]\n</code></pre> <p>To list the power events, use <code>perf script</code> with options:</p> <ul> <li><code>--itrace=ep</code> to show errors (e) and power events (p)</li> <li><code>-F-ip</code> to prevent showing the address i.e. instruction pointer (ip) register</li> <li><code>--ns</code> to show the timestamp to nanoseconds instead of the default microseconds</li> </ul> <p>The output shows the 10-character task command string, PID, CPU, timestamp, and event:</p> <pre><code>$ perf script --itrace=ep -F-ip --ns | head \n            perf  4355 [000] 11253.350232603:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n         swapper     0 [000] 11253.350253949:     power:cpu_idle: state=6 cpu_id=0\n            perf  4355 [001] 11253.350293104:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n         swapper     0 [001] 11253.350311546:     power:cpu_idle: state=8 cpu_id=1\n            perf  4355 [002] 11253.350350478:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n         swapper     0 [002] 11253.350369240:     power:cpu_idle: state=8 cpu_id=2\n            perf  4355 [003] 11253.350407645:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n         swapper     0 [003] 11253.350424940:     power:cpu_idle: state=6 cpu_id=3\n            perf  4355 [004] 11253.350464191:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n         swapper     0 [004] 11253.350482739:     power:cpu_idle: state=8 cpu_id=4\n</code></pre> <p>To limit the output to a particular CPU, the <code>-C</code> option can be used e.g. for CPU 1</p> <pre><code>$ perf script --itrace=ep -F-ip --ns -C 1 | head \n            perf  4355 [001] 11253.350293104:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n         swapper     0 [001] 11253.350311546:     power:cpu_idle: state=8 cpu_id=1\n         swapper     0 [001] 11253.569359111:                cbr:  cbr: 26 freq: 2612 MHz ( 96%)    \n         swapper     0 [001] 11253.569364879:     power:cpu_idle: state=4294967295 cpu_id=1\n         swapper     0 [001] 11253.569424754:     power:cpu_idle: state=8 cpu_id=1\n         swapper     0 [001] 11253.644214090:                cbr:  cbr: 23 freq: 2310 MHz ( 85%)    \n         swapper     0 [001] 11253.644220472:     power:cpu_idle: state=4294967295 cpu_id=1\n         konsole  2033 [001] 11253.644436892:                cbr:  cbr: 20 freq: 2009 MHz ( 74%)    \n         swapper     0 [001] 11253.645046629:     power:cpu_idle: state=2 cpu_id=1\n         swapper     0 [001] 11253.645074374:     power:cpu_idle: state=4294967295 cpu_id=1\n</code></pre> <p>To see some context, show context switch events (different trace to above):</p> <pre><code>$ perf script --itrace=ep -F-ip --ns -C 1 --show-switch-events | head -30\n         swapper     0 [001] 15355.259304318: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid: 17393/17393\n            perf 17393 [001] 15355.259305768: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:     0/0    \n            perf 17393 [001] 15355.259311919:                psb:  psb offs: 0                      \n            perf 17393 [001] 15355.259311919:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n            perf 17393 [001] 15355.259322862: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid:    20/20   \n     migration/1    20 [001] 15355.259323762: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid: 17393/17393\n     migration/1    20 [001] 15355.259330003: PERF_RECORD_SWITCH_CPU_WIDE OUT          next pid/tid:     0/0    \n         swapper     0 [001] 15355.259330401: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:    20/20   \n         swapper     0 [001] 15355.259333457:     power:cpu_idle: state=8 cpu_id=1\n         swapper     0 [001] 15355.349681141:                cbr:  cbr: 23 freq: 2310 MHz ( 85%)    \n         swapper     0 [001] 15355.349687604:     power:cpu_idle: state=4294967295 cpu_id=1\n         swapper     0 [001] 15355.349711470: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid: 15823/15823\n         konsole 15823 [001] 15355.349714239: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:     0/0    \n         konsole 15823 [001] 15355.349816414: PERF_RECORD_SWITCH_CPU_WIDE OUT          next pid/tid:     0/0    \n         swapper     0 [001] 15355.349817827: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid: 15823/15823\n         swapper     0 [001] 15355.349825977:     power:cpu_idle: state=8 cpu_id=1\n         swapper     0 [001] 15355.390601064:                cbr:  cbr: 16 freq: 1607 MHz ( 59%)    \n         swapper     0 [001] 15355.390608944:     power:cpu_idle: state=4294967295 cpu_id=1\n         swapper     0 [001] 15355.390649821: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid: 11264/11264\n kworker/1:0-mm_ 11264 [001] 15355.390652189: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:     0/0    \n kworker/1:0-mm_ 11264 [001] 15355.390662452: PERF_RECORD_SWITCH_CPU_WIDE OUT          next pid/tid:     0/0    \n         swapper     0 [001] 15355.390663434: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid: 11264/11264\n         swapper     0 [001] 15355.390671955:     power:cpu_idle: state=8 cpu_id=1\n         swapper     0 [001] 15355.422505769:     power:cpu_idle: state=4294967295 cpu_id=1\n         swapper     0 [001] 15355.422538477: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid:    66/66   \n      kcompactd0    66 [001] 15355.422541064: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:     0/0    \n      kcompactd0    66 [001] 15355.422549431: PERF_RECORD_SWITCH_CPU_WIDE OUT          next pid/tid:     0/0    \n         swapper     0 [001] 15355.422550337: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:    66/66   \n         swapper     0 [001] 15355.422557517:     power:cpu_idle: state=8 cpu_id=1\n         swapper     0 [001] 15355.456474916:                cbr:  cbr: 15 freq: 1507 MHz ( 56%)    \n</code></pre> <p>To see how to create a custom script refer to intel-pt-events.py</p> <p>To trace with virtual machines:</p> <pre><code>$ sudo ~/bin/perf record -a -e intel_pt/branch=0/,power:cpu_idle sleep 1\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 2.764 MB perf.data ]\n$ perf inject -i perf.data --vm-time-correlation=dry-run\nERROR: Unknown TSC Offset for VMCS 0x24bad0\nVMCS: 0x25da39  TSC Offset 0xffffd5c7e6fbb0e0\nVMCS: 0x24bad0  TSC Offset 0xffffd5c0fd708df0\nVMCS: 0x1fd127  TSC Offset 0xffffd5c7e6fbb0e0\nVMCS: 0x24bb7d  TSC Offset 0xffffd5c0fd708df0\nVMCS: 0x2659c5  TSC Offset 0xffffd5c7e6fbb0e0\nERROR: Unknown TSC Offset for VMCS 0x25dbc1\nVMCS: 0x25dbc1  TSC Offset 0xffffd5c0fd708df0\nERROR: Unknown TSC Offset for VMCS 0x213002\nVMCS: 0x213002  TSC Offset 0xffffd5c0fd708df0\nVMCS: 0x1fd374  TSC Offset 0xffffd5c7e6fbb0e0\n$ perf inject -i perf.data --vm-time-correlation=\"dry-run 0xffffd5c7e6fbb0e0:0x25da39,0x1fd127,0x2659c5,0x1fd374 0xffffd5c0fd708df0:0x24bad0,0x24bb7d,0x25dbc1,0x213002\"\n$ perf inject -i perf.data --vm-time-correlation=\"0xffffd5c7e6fbb0e0:0x25da39,0x1fd127,0x2659c5,0x1fd374 0xffffd5c0fd708df0:0x24bad0,0x24bb7d,0x25dbc1,0x213002\"\nThe input file would be updated in place, the --force option is required.\n$ perf inject -i perf.data --vm-time-correlation=\"0xffffd5c7e6fbb0e0:0x25da39,0x1fd127,0x2659c5,0x1fd374 0xffffd5c0fd708df0:0x24bad0,0x24bb7d,0x25dbc1,0x213002\" --force\n$ perf script --itrace=ep -F-ip --ns --show-switch-events\n...\n   perf 18011 [004] 17398.037394927:                psb:  psb offs: 0                      \n            perf 18011 [004] 17398.037394927:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n            perf 18011 [004] 17398.037408451: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid:    38/38   \n     migration/4    38 [004] 17398.037409609: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid: 18011/18011\n       CPU 3/KVM 17819 [005] 17398.037417897: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid: 18011/18011\n            perf 18011 [005] 17398.037421458: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid: 17809/17819\n     migration/4    38 [004] 17398.037423366: PERF_RECORD_SWITCH_CPU_WIDE OUT          next pid/tid:     0/0    \n         swapper     0 [004] 17398.037423908: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:    38/38   \n         swapper     0 [004] 17398.037426640:     power:cpu_idle: state=6 cpu_id=4\n            perf 18011 [005] 17398.037427626:                psb:  psb offs: 0                      \n            perf 18011 [005] 17398.037427626:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n            perf 18011 [005] 17398.037440808: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid:    44/44   \n     migration/5    44 [005] 17398.037441699: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid: 18011/18011\n     migration/5    44 [005] 17398.037446582: PERF_RECORD_SWITCH_CPU_WIDE OUT          next pid/tid: 17809/17819\n       CPU 3/KVM 17819 [005] 17398.037448806: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:    44/44   \n         swapper     0 [006] 17398.037483980: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid: 18011/18011\n            perf 18011 [006] 17398.037485458: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:     0/0    \n            perf 18011 [006] 17398.037491426:                psb:  psb offs: 0                      \n            perf 18011 [006] 17398.037491426:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n            perf 18011 [006] 17398.037502683: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid:    50/50   \n     migration/6    50 [006] 17398.037503350: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid: 18011/18011\n     migration/6    50 [006] 17398.037510565: PERF_RECORD_SWITCH_CPU_WIDE OUT          next pid/tid:     0/0    \n         swapper     0 [006] 17398.037510908: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:    50/50   \n         swapper     0 [006] 17398.037514870:     power:cpu_idle: state=8 cpu_id=6\n       CPU 1/KVM 17817 [000] 17398.037533765:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n       CPU 0/KVM 17816 [001] 17398.037533766:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n       CPU 3/KVM 17819 [005] 17398.037533767:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n         swapper     0 [006] 17398.037533829:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n         swapper     0 [007] 17398.037541586: PERF_RECORD_SWITCH_CPU_WIDE OUT preempt  next pid/tid: 18011/18011\n            perf 18011 [007] 17398.037544217: PERF_RECORD_SWITCH_CPU_WIDE IN           prev pid/tid:     0/0    \n            perf 18011 [007] 17398.037550910:                psb:  psb offs: 0                      \n            perf 18011 [007] 17398.037550910:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n       CPU 1/KVM 17817 [000] 17398.037572496:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n       CPU 0/KVM 17816 [001] 17398.037572496:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n       CPU 3/KVM 17819 [005] 17398.037572498:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n            perf 18011 [007] 17398.037572508:                cbr:  cbr: 42 freq: 4219 MHz (156%)    \n       CPU 3/KVM 17819 [005] 17398.037644052:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n       CPU 1/KVM 17817 [000] 17398.037644053:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n       CPU 0/KVM 17816 [001] 17398.037644054:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n            perf 18011 [007] 17398.037644064:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n         swapper     0 [002] 17398.037646332:                cbr:  cbr: 41 freq: 4118 MHz (152%)    \n         swapper     0 [002] 17398.037647762:     power:cpu_idle: state=4294967295 cpu_id=2\n...\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-tracing-the-nmi-handler","title":"Example: Tracing the NMI handler","text":"<p>It is straight forward for Intel PT to trace the NMI handler using snapshot mode.</p> <p>This example includes kernel tracing, which requires administrator privileges.</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-a</code> to trace system wide i.e. all tasks, all CPUs</li> <li><code>--kcore</code> to copy kernel object code from the /proc/kcore image (helps avoid decoding errors due to kernel self-modifying code)</li> <li><code>-Se</code> to make a snapshot when the workload ends</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt/cyc/k</code> to get Intel PT with cycle-accurate mode, tracing the kernel only</li> <li><code>--</code> is a separator, indicating that the rest of the options belong to the workload</li> </ul> <p>To get NMIs, the workload itself is another <code>perf record</code> with options:</p> <ul> <li><code>-o junk</code> to output to a file named 'junk', since we are not interested in it, and it needs to be different from the first <code>perf record</code></li> <li><code>-a</code> to trace system wide i.e. all tasks, all CPUs</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>cycles</code> to sample based on the CPU cycles counter</li> <li><code>--freq 100000</code> to specify the sampling frequency (100kHz) which ensures that PEBS samples will cause NMIs (to avoid \"large\" PEBS)</li> <li><code>sleep 0.001</code> is the workload.  The tracing will stop when the workload finishes, so this is simply a way of tracing for about 1 millisecond.</li> </ul> <pre><code>$ sudo perf record -a --kcore -Se -e intel_pt/cyc/k -- perf record -o junk -a -e cycles --freq 100000 sleep 0.001\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.915 MB junk (9 samples) ]\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 11.467 MB perf.data ]\n</code></pre> <p>We can see a call trace showing only the NMI handler with instructions-per-cycle (IPC) infomation:</p> <pre><code>$ perf script --call-trace --graph-function nmi -F+ipc,-dso\n            perf  7148 [000] 18161.939140991: nmi            IPC: 0.01 (48/2416) \n            perf  7148 [000] 18161.939140995:     paranoid_entry                             IPC: 0.19 (4/21) \n            perf  7148 [000] 18161.939141087:     do_nmi                                     IPC: 0.18 (70/383) \n            perf  7148 [000] 18161.939141183:         printk_nmi_enter                    \n            perf  7148 [000] 18161.939141226:         rcu_nmi_enter                       \n            perf  7148 [000] 18161.939141226:             rcu_dynticks_curr_cpu_in_eqs    \n            perf  7148 [000] 18161.939141229:         default_do_nmi                         IPC: 0.12 (77/594) \n            perf  7148 [000] 18161.939141229:             nmi_handle                      \n            perf  7148 [000] 18161.939141229:                 sched_clock                 \n            perf  7148 [000] 18161.939141229:                     native_sched_clock      \n            perf  7148 [000] 18161.939141229:                 __x86_indirect_thunk_rax    \n            perf  7148 [000] 18161.939141229:                     __x86_indirect_thunk_rax\n            perf  7148 [000] 18161.939141722:                         sched_clock            IPC: 0.07 (79/991) \n            perf  7148 [000] 18161.939141722:                             native_sched_clock                              \n            perf  7148 [000] 18161.939141722:                         __x86_indirect_thunk_rax                            \n            perf  7148 [000] 18161.939141722:                             __x86_indirect_thunk_rax                        \n            perf  7148 [000] 18161.939141728:                                 intel_bts_disable_local                        IPC: 0.05 (65/1093) \n            perf  7148 [000] 18161.939141894:                                 __intel_pmu_disable_all                        IPC: 0.01 (8/694) \n            perf  7148 [000] 18161.939141894:                                     native_write_msr                        \n            perf  7148 [000] 18161.939141894:                                     intel_pmu_pebs_disable_all              \n            perf  7148 [000] 18161.939141943:                                 intel_pmu_drain_bts_buffer                     IPC: 0.15 (33/207) \n            perf  7148 [000] 18161.939141943:                                 intel_bts_interrupt                         \n            perf  7148 [000] 18161.939142030:                                 native_read_msr                                IPC: 0.17 (63/362) \n            perf  7148 [000] 18161.939142030:                                 intel_pmu_lbr_read                          \n            perf  7148 [000] 18161.939142030:                                 native_write_msr                            \n            perf  7148 [000] 18161.939142193:                                 handle_pmi_common                           \n            perf  7148 [000] 18161.939142193:                                     find_first_bit                          \n            perf  7148 [000] 18161.939142220:                                     intel_pmu_save_and_restart              \n            perf  7148 [000] 18161.939142220:                                         x86_perf_event_update               \n            perf  7148 [000] 18161.939142230:                                             native_read_pmc                 \n            perf  7148 [000] 18161.939142230:                                         x86_perf_event_set_period           \n            perf  7148 [000] 18161.939142262:                                             native_write_msr                   IPC: 0.21 (210/969) \n            perf  7148 [000] 18161.939142362:                                             perf_event_update_userpage      \n            perf  7148 [000] 18161.939142362:                                                 calc_timer_values           \n            perf  7148 [000] 18161.939142362:                                                     sched_clock_cpu         \n            perf  7148 [000] 18161.939142362:                                                         sched_clock         \n            perf  7148 [000] 18161.939142362:                                                             native_sched_clock                              \n            perf  7148 [000] 18161.939142376:                                                 __x86_indirect_thunk_rax                                    \n            perf  7148 [000] 18161.939142376:                                                     __x86_indirect_thunk_rax                                \n            perf  7148 [000] 18161.939142395:                                                 arch_perf_update_userpage                                      IPC: 0.30 (170/556) \n            perf  7148 [000] 18161.939142395:                                                     using_native_sched_clock                                \n            perf  7148 [000] 18161.939142395:                                                     sched_clock_stable                                      \n            perf  7148 [000] 18161.939142395:                                                     cyc2ns_read_begin                                       \n            perf  7148 [000] 18161.939142403:                                                     cyc2ns_read_end                                            IPC: 2.00 (74/37) \n            perf  7148 [000] 18161.939142411:                                     perf_event_overflow                        IPC: 1.56 (50/32) \n            perf  7148 [000] 18161.939142411:                                         __perf_event_overflow               \n            perf  7148 [000] 18161.939142411:                                             __perf_event_account_interrupt  \n            perf  7148 [000] 18161.939142411:                                                 sched_clock_cpu             \n            perf  7148 [000] 18161.939142411:                                                     sched_clock             \n            perf  7148 [000] 18161.939142411:                                                         native_sched_clock  \n            perf  7148 [000] 18161.939142516:                                             __x86_indirect_thunk_rax           IPC: 0.19 (87/440) \n            perf  7148 [000] 18161.939142516:                                                 __x86_indirect_thunk_rax    \n            perf  7148 [000] 18161.939142599:                                                     perf_prepare_sample        IPC: 0.08 (30/346) \n            perf  7148 [000] 18161.939142599:                                                         perf_misc_flags     \n            perf  7148 [000] 18161.939142936:                                                             __x86_indirect_thunk_rax                        \n            perf  7148 [000] 18161.939142936:                                                                 __x86_indirect_thunk_rax                    \n            perf  7148 [000] 18161.939143202:                                                         __perf_event_header__init_id.isra.0                    IPC: 0.02 (74/2522) \n            perf  7148 [000] 18161.939143203:                                                             perf_event_pid_type                                IPC: 3.80 (19/5) \n            perf  7148 [000] 18161.939143203:                                                                 __task_pid_nr_ns                            \n            perf  7148 [000] 18161.939143205:                                                             perf_event_pid_type                                IPC: 3.90 (39/10) \n            perf  7148 [000] 18161.939143205:                                                                 __task_pid_nr_ns                            \n            perf  7148 [000] 18161.939143210:                                                             __x86_indirect_thunk_rax                           IPC: 3.41 (58/17) \n            perf  7148 [000] 18161.939143210:                                                                 __x86_indirect_thunk_rax                    \n            perf  7148 [000] 18161.939143211:                                                                     sched_clock_cpu                            IPC: 2.25 (9/4) \n            perf  7148 [000] 18161.939143211:                                                                         sched_clock                         \n            perf  7148 [000] 18161.939143211:                                                                             native_sched_clock              \n            perf  7148 [000] 18161.939143227:                                                         perf_instruction_pointer                               IPC: 0.97 (66/68) \n            perf  7148 [000] 18161.939143227:                                                             __x86_indirect_thunk_rax                        \n            perf  7148 [000] 18161.939143227:                                                                 __x86_indirect_thunk_rax                    \n            perf  7148 [000] 18161.939143359:                                                     perf_output_begin_forward                                  IPC: 0.11 (65/554) \n            perf  7148 [000] 18161.939143895:                                                     perf_output_sample                                         IPC: 0.03 (78/2240) \n            perf  7148 [000] 18161.939143895:                                                         perf_output_copy                                    \n            perf  7148 [000] 18161.939143895:                                                             memcpy                                          \n            perf  7148 [000] 18161.939143923:                                                         perf_output_copy                                    \n            perf  7148 [000] 18161.939143923:                                                             memcpy                                          \n            perf  7148 [000] 18161.939144052:                                                         perf_output_copy                                    \n            perf  7148 [000] 18161.939144052:                                                             memcpy                                          \n            perf  7148 [000] 18161.939144064:                                                         perf_output_copy                                       IPC: 0.23 (169/708) \n            perf  7148 [000] 18161.939144064:                                                             memcpy                                          \n            perf  7148 [000] 18161.939144076:                                                         perf_output_copy                                       IPC: 0.98 (49/50) \n            perf  7148 [000] 18161.939144076:                                                             memcpy                                          \n            perf  7148 [000] 18161.939144174:                                                         perf_output_copy                                    \n            perf  7148 [000] 18161.939144174:                                                             memcpy                                          \n            perf  7148 [000] 18161.939144207:                                                     perf_output_end                                            IPC: 0.20 (99/489) \n            perf  7148 [000] 18161.939144207:                                                         perf_output_put_handle                              \n            perf  7148 [000] 18161.939144245:                                     find_next_bit                              IPC: 0.41 (89/215) \n            perf  7148 [000] 18161.939144260:                                 native_read_msr                                IPC: 0.55 (36/65) \n            perf  7148 [000] 18161.939144284:                                 __intel_pmu_enable_all.constprop.0             IPC: 0.16 (16/99) \n            perf  7148 [000] 18161.939144284:                                     intel_pmu_pebs_enable_all               \n            perf  7148 [000] 18161.939144284:                                     intel_pmu_lbr_enable_all                \n            perf  7148 [000] 18161.939144301:                                     native_write_msr                           IPC: 0.51 (37/72) \n            perf  7148 [000] 18161.939144301:                                 intel_bts_enable_local                      \n            perf  7148 [000] 18161.939144408:                                 __x86_indirect_thunk_rax                       IPC: 0.06 (31/446) \n            perf  7148 [000] 18161.939144408:                                     __x86_indirect_thunk_rax                \n            perf  7148 [000] 18161.939144420:                                         native_write_msr                       IPC: 0.34 (10/29) \n            perf  7148 [000] 18161.939144457:                         sched_clock                                            IPC: 0.17 (31/179) \n            perf  7148 [000] 18161.939144457:                             native_sched_clock                              \n            perf  7148 [000] 18161.939144467:                         perf_sample_event_took                              \n            perf  7148 [000] 18161.939144580:                 sched_clock                                                    IPC: 0.10 (53/512) \n            perf  7148 [000] 18161.939144580:                     native_sched_clock                                      \n            perf  7148 [000] 18161.939144590:                 sched_clock                                                 \n            perf  7148 [000] 18161.939144590:                     native_sched_clock                                      \n            perf  7148 [000] 18161.939144616:                 __x86_indirect_thunk_rax                                       IPC: 0.45 (68/149) \n            perf  7148 [000] 18161.939144616:                     __x86_indirect_thunk_rax                                \n            perf  7148 [000] 18161.939144681:                         nmi_cpu_backtrace                                      IPC: 0.04 (11/275) \n            perf  7148 [000] 18161.939144954:                 sched_clock                                                    IPC: 0.02 (26/1141) \n            perf  7148 [000] 18161.939144954:                     native_sched_clock                                      \n            perf  7148 [000] 18161.939144967:         rcu_nmi_exit                           IPC: 1.10 (61/55) \n            perf  7148 [000] 18161.939144985:         printk_nmi_exit                     \n     migration/0    12 [000] 18161.939155684: nmi        IPC: 0.06 (54/805) \n</code></pre> <p>Note, that was for a v5.4.33 based kernel i.e.</p> <pre><code>$ uname -a\nLinux 5.4.0-33-generic #37-Ubuntu SMP Thu May 21 12:53:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-tracing-__switch_to","title":"Example: Tracing <code>__switch_to()</code>","text":"<p>It is straight forward for Intel PT to trace <code>__switch_to()</code>, the kernel function that switches tasks.</p> <p>Before we start, if we haven't done it already, we will need to install Intel X86 Encoder Decoder (XED)</p> <pre><code>$ cd ~/git\n$ git clone https://github.com/intelxed/mbuild.git mbuild\n$ git clone https://github.com/intelxed/xed\n$ cd xed\n$ ./mfile.py --share\n$ ./mfile.py examples\n$ sudo ./mfile.py --prefix=/usr/local install\n$ sudo ldconfig\n$ find . -type f -name xed\n./obj/wkit/examples/obj/xed\n$ cp ./obj/wkit/examples/obj/xed /usr/local/bin\n</code></pre> <p>This example includes kernel tracing, which requires administrator privileges.</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-a</code> to trace system wide i.e. all tasks, all CPUs</li> <li><code>--kcore</code> to copy kernel object code from the /proc/kcore image (helps avoid decoding errors due to kernel self-modifying code)</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt/cyc,noretcomp/k</code> to get Intel PT with cycle-accurate mode. We add <code>noretcomp</code> to get a Intel PT TIP packet from RET instructions, which has the side-effect of also getting a CYC timing packet, and consequently enables calculating IPC at that point.</li> <li><code>--filter 'filter __switch_to ,filter native_load_tls'</code> specifies address filters to trace only __switch_to() and native_load_tls()</li> <li><code>--</code> is a separator, indicating that the rest of the options belong to the workload</li> <li><code>sleep 1</code> is the workload.  The tracing will stop when the workload finishes, so this is simply a way of tracing for about 1 second.</li> </ul> <pre><code>$ sudo perf record -a --kcore -e intel_pt/cyc,noretcomp/k --filter 'filter __switch_to ,filter native_load_tls' -- sleep 1\n</code></pre> <p>We can get an instruction trace with instructions-per-cycle (IPC) information for CPU 0, as follows:</p> <pre><code>$ perf script --insn-trace --xed -C0 -F-dso,-comm,-tid,+flags,+ipc | head -130\n[000]  2336.210811381:                        ffffffff9f02fdd0 __switch_to+0x0      pushq  %rbp\n[000]  2336.210811381:                        ffffffff9f02fdd1 __switch_to+0x1      movq  %gs:0x16bc0, %rax\n[000]  2336.210811381:                        ffffffff9f02fdda __switch_to+0xa      mov %rsp, %rbp\n[000]  2336.210811381:                        ffffffff9f02fddd __switch_to+0xd      pushq  %r15\n[000]  2336.210811381:                        ffffffff9f02fddf __switch_to+0xf      leaq  0x1340(%rsi), %r15\n[000]  2336.210811381:                        ffffffff9f02fde6 __switch_to+0x16         pushq  %r14\n[000]  2336.210811381:                        ffffffff9f02fde8 __switch_to+0x18         leaq  0x1340(%rdi), %r14\n[000]  2336.210811381:                        ffffffff9f02fdef __switch_to+0x1f         pushq  %r13\n[000]  2336.210811381:                        ffffffff9f02fdf1 __switch_to+0x21         mov %rdi, %r13\n[000]  2336.210811381:                        ffffffff9f02fdf4 __switch_to+0x24         pushq  %r12\n[000]  2336.210811381:                        ffffffff9f02fdf6 __switch_to+0x26         mov %rsi, %r12\n[000]  2336.210811381:                        ffffffff9f02fdf9 __switch_to+0x29         pushq  %rbx\n[000]  2336.210811381:                        ffffffff9f02fdfa __switch_to+0x2a         sub $0x10, %rsp\n[000]  2336.210811381:                        ffffffff9f02fdfe __switch_to+0x2e         movq  (%rax), %rdx\n[000]  2336.210811381:                        ffffffff9f02fe01 __switch_to+0x31         movl  %gs:0x60fe0548(%rip), %ebx\n[000]  2336.210811381:                        ffffffff9f02fe08 __switch_to+0x38         and $0x40, %dh\n[000]  2336.210811382:   jcc                  ffffffff9f02fe0b __switch_to+0x3b         jz 0xffffffff9f0300cd    IPC: 2.83 (17/6) \n[000]  2336.210811382:                        ffffffff9f0300cd __switch_to+0x2fd        testb  $0x20, 0x26(%rax)\n[000]  2336.210811382:   jcc                  ffffffff9f0300d1 __switch_to+0x301        jnz 0xffffffff9f02fe11\n[000]  2336.210811382:                        ffffffff9f0300d7 __switch_to+0x307        leaq  0x1400(%rdi), %rcx\n[000]  2336.210811382:                        ffffffff9f0300de __switch_to+0x30e        nopl  %eax, (%rax,%rax,1)\n[000]  2336.210811382:                        ffffffff9f0300e3 __switch_to+0x313        movl  0x181715e(%rip), %r9d\n[000]  2336.210811382:                        ffffffff9f0300ea __switch_to+0x31a        leaq  0x1440(%r13), %rdi\n[000]  2336.210811382:                        ffffffff9f0300f1 __switch_to+0x321        test %r9d, %r9d\n[000]  2336.210811382:   jcc                  ffffffff9f0300f4 __switch_to+0x324        jz 0xffffffff9f030235\n[000]  2336.210811382:                        ffffffff9f0300fa __switch_to+0x32a        mov $0xffffffff, %eax\n[000]  2336.210811382:                        ffffffff9f0300ff __switch_to+0x32f        mov %eax, %edx\n[000]  2336.210811382:                        ffffffff9f030101 __switch_to+0x331        xsaves64 (%rdi)\n[000]  2336.210811382:                        ffffffff9f030105 __switch_to+0x335        xor %eax, %eax\n[000]  2336.210811382:                        ffffffff9f030107 __switch_to+0x337        test %eax, %eax\n[000]  2336.210811382:   jcc                  ffffffff9f030109 __switch_to+0x339        jnz 0xffffffff9f03022e\n[000]  2336.210811382:                        ffffffff9f03010f __switch_to+0x33f        testb  $0xe0, 0x1640(%r13)\n[000]  2336.210811382:   jcc                  ffffffff9f030117 __switch_to+0x347        jnz 0xffffffff9f030207\n[000]  2336.210811382:                        ffffffff9f03011d __switch_to+0x34d        movl  %ebx, 0x1400(%r13)\n[000]  2336.210811382:                        ffffffff9f030124 __switch_to+0x354        nopl  %eax, (%rax,%rax,1)\n[000]  2336.210811382:   jmp                  ffffffff9f030129 __switch_to+0x359        jmp 0xffffffff9f02fe11\n[000]  2336.210811382:                        ffffffff9f02fe11 __switch_to+0x41         mov %fs, %ax\n[000]  2336.210811382:                        ffffffff9f02fe14 __switch_to+0x44         movw  %ax, 0x1364(%r13)\n[000]  2336.210811382:                        ffffffff9f02fe1c __switch_to+0x4c         mov %gs, %ax\n[000]  2336.210811382:                        ffffffff9f02fe1f __switch_to+0x4f         cmpw  $0x0, 0x1364(%r13)\n[000]  2336.210811382:                        ffffffff9f02fe28 __switch_to+0x58         movw  %ax, 0x1366(%r13)\n[000]  2336.210811382:   jcc                  ffffffff9f02fe30 __switch_to+0x60         jnz 0xffffffff9f0301a3\n[000]  2336.210811382:                        ffffffff9f02fe36 __switch_to+0x66         cmpw  $0x0, 0x1366(%r13)\n[000]  2336.210811428:   jcc                  ffffffff9f02fe3f __switch_to+0x6f         jnz 0xffffffff9f030185   IPC: 0.13 (27/195) \n[000]  2336.210811428:                        ffffffff9f02fe45 __switch_to+0x75         mov %ebx, %esi\n[000]  2336.210811428:                        ffffffff9f02fe47 __switch_to+0x77         mov %r15, %rdi\n[000]  2336.210811428:   call                 ffffffff9f02fe4a __switch_to+0x7a         callq  0xffffffff9f0786c0\n[000]  2336.210811428:                        ffffffff9f0786c0 native_load_tls+0x0      movq  (%rdi), %rdx\n[000]  2336.210811428:                        ffffffff9f0786c3 native_load_tls+0x3      mov %esi, %esi\n[000]  2336.210811428:                        ffffffff9f0786c5 native_load_tls+0x5      mov $0x9000, %rax\n[000]  2336.210811428:                        ffffffff9f0786cc native_load_tls+0xc      addq  -0x5fbbb680(,%rsi,8), %rax\n[000]  2336.210811428:                        ffffffff9f0786d4 native_load_tls+0x14         movq  %rdx, 0x60(%rax)\n[000]  2336.210811428:                        ffffffff9f0786d8 native_load_tls+0x18         movq  0x8(%rdi), %rdx\n[000]  2336.210811428:                        ffffffff9f0786dc native_load_tls+0x1c         movq  %rdx, 0x68(%rax)\n[000]  2336.210811428:                        ffffffff9f0786e0 native_load_tls+0x20         movq  0x10(%rdi), %rdx\n[000]  2336.210811428:                        ffffffff9f0786e4 native_load_tls+0x24         movq  %rdx, 0x70(%rax)\n[000]  2336.210811429:   return               ffffffff9f0786e8 native_load_tls+0x28         retq     IPC: 3.25 (13/4) \n[000]  2336.210811429:                        ffffffff9f02fe4f __switch_to+0x7f         data16 nop\n[000]  2336.210811429:                        ffffffff9f02fe51 __switch_to+0x81         mov %r12, %rdi\n[000]  2336.210811429:                        ffffffff9f02fe54 __switch_to+0x84         nopl  %eax, (%rax)\n[000]  2336.210811429:                        ffffffff9f02fe5b __switch_to+0x8b         mov %es, %ax\n[000]  2336.210811429:                        ffffffff9f02fe5e __switch_to+0x8e         movw  %ax, 0x20(%r14)\n[000]  2336.210811429:                        ffffffff9f02fe63 __switch_to+0x93         movzxw  0x1360(%r12), %eax\n[000]  2336.210811429:                        ffffffff9f02fe6c __switch_to+0x9c         mov %eax, %ebx\n[000]  2336.210811429:                        ffffffff9f02fe6e __switch_to+0x9e         orw  0x1360(%r13), %bx\n[000]  2336.210811430:   jcc                  ffffffff9f02fe76 __switch_to+0xa6         jnz 0xffffffff9f030195   IPC: 4.50 (9/2) \n[000]  2336.210811430:                        ffffffff9f02fe7c __switch_to+0xac         mov %ds, %ax\n[000]  2336.210811430:                        ffffffff9f02fe7f __switch_to+0xaf         movw  %ax, 0x22(%r14)\n[000]  2336.210811430:                        ffffffff9f02fe84 __switch_to+0xb4         movzxw  0x1362(%r12), %eax\n[000]  2336.210811430:                        ffffffff9f02fe8d __switch_to+0xbd         mov %eax, %ebx\n[000]  2336.210811430:                        ffffffff9f02fe8f __switch_to+0xbf         orw  0x1362(%r13), %bx\n[000]  2336.210811430:   jcc                  ffffffff9f02fe97 __switch_to+0xc7         jnz 0xffffffff9f03019c\n[000]  2336.210811430:                        ffffffff9f02fe9d __switch_to+0xcd         movq  0x1368(%r12), %rdx\n[000]  2336.210811430:                        ffffffff9f02fea5 __switch_to+0xd5         movzxw  0x1364(%r13), %ecx\n[000]  2336.210811430:                        ffffffff9f02fead __switch_to+0xdd         movzxw  0x1364(%r12), %eax\n[000]  2336.210811430:                        ffffffff9f02feb6 __switch_to+0xe6         cmp $0x3, %ax\n[000]  2336.210811430:   jcc                  ffffffff9f02feba __switch_to+0xea         jnbe 0xffffffff9f03016e\n[000]  2336.210811430:                        ffffffff9f02fec0 __switch_to+0xf0         test %rdx, %rdx\n[000]  2336.210811430:   jcc                  ffffffff9f02fec3 __switch_to+0xf3         jz 0xffffffff9f030085\n[000]  2336.210811430:   jmp                  ffffffff9f030085 __switch_to+0x2b5        jmp 0xffffffff9f03015c\n[000]  2336.210811430:                        ffffffff9f03015c __switch_to+0x38c        or %eax, %ecx\n[000]  2336.210811430:                        ffffffff9f03015e __switch_to+0x38e        movzx %cx, %ecx\n[000]  2336.210811430:                        ffffffff9f030161 __switch_to+0x391        orq  0x1368(%r13), %rcx\n[000]  2336.210811430:   jcc                  ffffffff9f030168 __switch_to+0x398        jz 0xffffffff9f02fee2\n[000]  2336.210811430:                        ffffffff9f03016e __switch_to+0x39e        mov %ax, %fs\n[000]  2336.210811430:   jmp                  ffffffff9f030170 __switch_to+0x3a0        jmp 0xffffffff9f02fee2\n[000]  2336.210811430:                        ffffffff9f02fee2 __switch_to+0x112        movq  0x1370(%r12), %r14\n[000]  2336.210811430:                        ffffffff9f02feea __switch_to+0x11a        movzxw  0x1366(%r13), %eax\n[000]  2336.210811430:                        ffffffff9f02fef2 __switch_to+0x122        movzxw  0x1366(%r12), %ebx\n[000]  2336.210811430:                        ffffffff9f02fefb __switch_to+0x12b        cmp $0x3, %bx\n[000]  2336.210811430:   jcc                  ffffffff9f02feff __switch_to+0x12f        jnbe 0xffffffff9f03014d\n[000]  2336.210811430:                        ffffffff9f02ff05 __switch_to+0x135        test %r14, %r14\n[000]  2336.210811439:   jcc                  ffffffff9f02ff08 __switch_to+0x138        jnz 0xffffffff9f0300a3   IPC: 0.67 (27/40) \n[000]  2336.210811439:   jmp                  ffffffff9f02ff0e __switch_to+0x13e        jmp 0xffffffff9f03013b\n[000]  2336.210811439:                        ffffffff9f03013b __switch_to+0x36b        or %ebx, %eax\n[000]  2336.210811439:                        ffffffff9f03013d __switch_to+0x36d        movzx %ax, %eax\n[000]  2336.210811439:                        ffffffff9f030140 __switch_to+0x370        orq  0x1370(%r13), %rax\n[000]  2336.210811439:   jcc                  ffffffff9f030147 __switch_to+0x377        jz 0xffffffff9f02ff29\n[000]  2336.210811439:                        ffffffff9f02ff29 __switch_to+0x159        movq  %r12, %gs:0x60fe6c8f(%rip)\n[000]  2336.210811439:                        ffffffff9f02ff31 __switch_to+0x161        movq  0x18(%r12), %rax\n[000]  2336.210811439:                        ffffffff9f02ff36 __switch_to+0x166        add $0x4000, %rax\n[000]  2336.210811439:                        ffffffff9f02ff3c __switch_to+0x16c        movq  %rax, %gs:0x60fd60c8(%rip)\n[000]  2336.210811439:                        ffffffff9f02ff44 __switch_to+0x174        movl  0x161efa6(%rip), %ebx\n[000]  2336.210811439:                        ffffffff9f02ff4a __switch_to+0x17a        movq  %gs:0x16bc0, %rax\n[000]  2336.210811439:                        ffffffff9f02ff53 __switch_to+0x183        lock orb  $0x40, 0x1(%rax)\n[000]  2336.210811439:   jmp                  ffffffff9f02ff58 __switch_to+0x188        jmp 0xffffffff9f02ff99\n[000]  2336.210811439:   jmp                  ffffffff9f02ff99 __switch_to+0x1c9        jmp 0xffffffff9f02ffb1\n[000]  2336.210811439:                        ffffffff9f02ffb1 __switch_to+0x1e1        movq  (%r12), %rdx\n[000]  2336.210811439:                        ffffffff9f02ffb5 __switch_to+0x1e5        movq  (%r13), %rax\n[000]  2336.210811439:                        ffffffff9f02ffb9 __switch_to+0x1e9        nopl  %eax, (%rax,%rax,1)\n[000]  2336.210811439:                        ffffffff9f02ffbe __switch_to+0x1ee        and $0x2418620, %edx\n[000]  2336.210811439:                        ffffffff9f02ffc4 __switch_to+0x1f4        and $0x2418e20, %eax\n[000]  2336.210811439:                        ffffffff9f02ffc9 __switch_to+0x1f9        or %rax, %rdx\n[000]  2336.210811439:   jcc                  ffffffff9f02ffcc __switch_to+0x1fc        jnz 0xffffffff9f030175\n[000]  2336.210811439:   jmp                  ffffffff9f02ffd2 __switch_to+0x202        jmp 0xffffffff9f02ffec\n[000]  2336.210811439:   jmp                  ffffffff9f02ffec __switch_to+0x21c        jmp 0xffffffff9f030001\n[000]  2336.210811439:   jmp                  ffffffff9f030001 __switch_to+0x231        jmp 0xffffffff9f030073\n[000]  2336.210811439:                        ffffffff9f030073 __switch_to+0x2a3        add $0x10, %rsp\n[000]  2336.210811439:                        ffffffff9f030077 __switch_to+0x2a7        mov %r13, %rax\n[000]  2336.210811439:                        ffffffff9f03007a __switch_to+0x2aa        popq  %rbx\n[000]  2336.210811439:                        ffffffff9f03007b __switch_to+0x2ab        popq  %r12\n[000]  2336.210811439:                        ffffffff9f03007d __switch_to+0x2ad        popq  %r13\n[000]  2336.210811439:                        ffffffff9f03007f __switch_to+0x2af        popq  %r14\n[000]  2336.210811439:                        ffffffff9f030081 __switch_to+0x2b1        popq  %r15\n[000]  2336.210811439:                        ffffffff9f030083 __switch_to+0x2b3        popq  %rbp\n[000]  2336.210811468:   tr end  return       ffffffff9f030084 __switch_to+0x2b4        retq     IPC: 0.27 (33/122) \n[000]  2336.210817292:                        ffffffff9f02fdd0 __switch_to+0x0      pushq  %rbp\n[000]  2336.210817292:                        ffffffff9f02fdd1 __switch_to+0x1      movq  %gs:0x16bc0, %rax\n[000]  2336.210817292:                        ffffffff9f02fdda __switch_to+0xa      mov %rsp, %rbp\n[000]  2336.210817292:                        ffffffff9f02fddd __switch_to+0xd      pushq  %r15\n</code></pre> <p>Note, that was for a v5.4.33 based kernel i.e.</p> <pre><code>$ uname -a\nLinux 5.4.0-33-generic #37-Ubuntu SMP Thu May 21 12:53:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre> <p>We can get source line information, but first we need the kernel debug package:</p> <pre><code>$ sudo apt-get install linux-image-5.4.0-33-generic-dbgsym\n</code></pre> <p>We can use it, as follows, to see how much it differs from the running code:</p> <pre><code>$ perf script --itrace=e --vmlinux /usr/lib/debug/boot/vmlinux-5.4.0-33-generic &gt;/dev/null\nWarning:\n55 instruction trace errors\n</code></pre> <p>Really, we should be able to use kcore for object code, and /usr/lib/debug/boot/vmlinux-5.4.0-33-generic for debug information, but because we can't at present, we can reduce the decoding errors, by copying from the copy of kcore into a copy of /usr/lib/debug/boot/vmlinux-5.4.0-33-generic:</p> <pre><code>$ cp /usr/lib/debug/boot/vmlinux-5.4.0-33-generic vmlinux-5.4.0-33-generic-plus-kcore\n$ dd if=perf.data/kcore_dir/kcore of=vmlinux-5.4.0-33-generic-plus-kcore bs=4096 skip=1 seek=512 count=3585 conv=nocreat,notrunc\n3585+0 records in\n3585+0 records out\n14684160 bytes (15 MB, 14 MiB) copied, 0.0143739 s, 1.0 GB/s\n$ perf script --itrace=e --vmlinux vmlinux-5.4.0-33-generic-plus-kcore &gt;/dev/null\n</code></pre> <p>Note, 2 of the values above come from the readelf command below:</p> <ul> <li>skip=1 (4096-byte block) because that is the offset of the kernel code segment in perf.data/kcore_dir/kcore i.e. 0x1000 = 1 x 4096)</li> <li>count=3585 (4096-byte blocks) because that is the size (Filesiz) of the kernel code segment in perf.data/kcore_dir/kcore i.e. 0xe01000 = 3585 x 4096</li> </ul> <pre><code>$ readelf -l switch-example-3/kcore_dir/kcore | grep -C2 LOAD\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  LOAD           0x0000000000001000 0xffffffff9f000000 0x0000000000000000\n                 0x0000000000e01000 0x0000000000e01000  RWE    0x1000\n  LOAD           0x0000000000e02000 0xffffffffc025c000 0x0000000000000000\n                 0x0000000000c99000 0x0000000000c99000  RWE    0x1000\n</code></pre> <p>The remaining value comes from the readelf command below:</p> <ul> <li>seek=512 (4096-byte blocks) because that is the offset of the kernel code segment in vmlinux-5.4.0-33-generic-plus-kcore i.e. 0x200000 = 512 x 4096</li> </ul> <pre><code>$ readelf -l vmlinux-5.4.0-33-generic-plus-kcore | grep -C2 LOAD\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  LOAD           0x0000000000200000 0xffffffff81000000 0x0000000001000000\n                 0x00000000014d5000 0x00000000014d5000  R E    0x200000\n  LOAD           0x0000000001800000 0xffffffff82600000 0x0000000002600000\n                 0x000000000026f000 0x000000000026f000  RW     0x200000\n  LOAD           0x0000000001c00000 0x0000000000000000 0x000000000286f000\n                 0x000000000002d000 0x000000000002d000  RW     0x200000\n  LOAD           0x0000000001c9c000 0xffffffff8289c000 0x000000000289c000\n                 0x0000000000d64000 0x0000000000d64000  RWE    0x200000\n  NOTE           0x0000000001000eb4 0xffffffff81e00eb4 0x0000000001e00eb4\n</code></pre> <p>Then, we can show source line information:</p> <pre><code>$ perf script --vmlinux ./vmlinux-5.4.0-33-generic-plus-kcore --insn-trace --xed -C0 -F-dso,-comm,-tid,+flags,+ipc,+srcline | head\n[000]  2336.210811381:                        ffffffff9f02fdd0 __switch_to+0x0\n  process_64.c:505              pushq  %rbp\n[000]  2336.210811381:                        ffffffff9f02fdd1 __switch_to+0x1\n  current.h:15          movq  %gs:0x16bc0, %rax\n[000]  2336.210811381:                        ffffffff9f02fdda __switch_to+0xa\n  process_64.c:505              mov %rsp, %rbp\n[000]  2336.210811381:                        ffffffff9f02fddd __switch_to+0xd\n  process_64.c:505              pushq  %r15\n[000]  2336.210811381:                        ffffffff9f02fddf __switch_to+0xf\n  process_64.c:507              leaq  0x1340(%rsi), %r15\n</code></pre> <p>We can tidy that up a bit with awk:</p> <pre><code>$ perf script --vmlinux ./vmlinux-5.4.0-33-generic-plus-kcore --insn-trace --xed -C0 -F-dso,-comm,-tid,+flags,+ipc,+srcline | \\\n&gt; awk '/^\\[/ {printf(\"\\n%-85s\",$0)} /^ / {ln=$0;gsub(\"\\t\",\"  \",ln);printf(\"%-58s\",ln)}' | head\n\n[000]  2336.210811381:                        ffffffff9f02fdd0 __switch_to+0x0         process_64.c:505     pushq  %rbp                        \n[000]  2336.210811381:                        ffffffff9f02fdd1 __switch_to+0x1         current.h:15     movq  %gs:0x16bc0, %rax                \n[000]  2336.210811381:                        ffffffff9f02fdda __switch_to+0xa         process_64.c:505     mov %rsp, %rbp                     \n[000]  2336.210811381:                        ffffffff9f02fddd __switch_to+0xd         process_64.c:505     pushq  %r15                        \n[000]  2336.210811381:                        ffffffff9f02fddf __switch_to+0xf         process_64.c:507     leaq  0x1340(%rsi), %r15           \n[000]  2336.210811381:                        ffffffff9f02fde6 __switch_to+0x16        process_64.c:505     pushq  %r14                        \n[000]  2336.210811381:                        ffffffff9f02fde8 __switch_to+0x18        process_64.c:506     leaq  0x1340(%rdi), %r14           \n[000]  2336.210811381:                        ffffffff9f02fdef __switch_to+0x1f        process_64.c:505     pushq  %r13                        \n[000]  2336.210811381:                        ffffffff9f02fdf1 __switch_to+0x21        process_64.c:505     mov %rdi, %r13                     \n</code></pre> <p>We can add the source code as well, but first we need the matching linux kernel source, taking care to get the right version:</p> <pre><code>$ sudo apt-get install linux-source-5.4.0=5.4.0-33.37\n</code></pre> <p>We can see, from below, that the source code needs to be in directory /build/linux-3STWY5:</p> <pre><code>$ perf script --vmlinux ./vmlinux-5.4.0-33-generic-plus-kcore --insn-trace --xed -C0 -F-dso,-comm,-tid,+flags,+ipc,+srcline --full-source-path | awk '/^\\[/ {printf(\"\\n%-85s\",$0)} /^ / {ln=$0;gsub(\"\\t\",\"  \",ln);printf(\"%-58s\",ln)}' | head -4\n\n[000]  2336.210811381:                        ffffffff9f02fdd0 __switch_to+0x0         /build/linux-3STWY5/linux-5.4.0/arch/x86/kernel/process_64.c:505     pushq  %rbp\n[000]  2336.210811381:                        ffffffff9f02fdd1 __switch_to+0x1         /build/linux-3STWY5/linux-5.4.0/arch/x86/include/asm/current.h:15     movq  %gs:0x16bc0, %rax\n[000]  2336.210811381:                        ffffffff9f02fdda __switch_to+0xa         /build/linux-3STWY5/linux-5.4.0/arch/x86/kernel/process_64.c:505     mov %rsp, %rbp\n</code></pre> <p>We can unpackage the source tarball into that directory, rename it, and remove the package:</p> <pre><code>$ sudo mkdir -p /build/linux-3STWY5\n$ sudo tar -xjf  /usr/src/linux-source-5.4.0/linux-source-5.4.0.tar.bz2 --directory=/build/linux-3STWY5\n$ sudo mv /build/linux-3STWY5/linux-source-5.4.0 /build/linux-3STWY5/linux-5.4.0\n$ sudo apt-get remove linux-source-5.4.0\n</code></pre> <p>Then, we can show source code:</p> <pre><code>$ perf script --vmlinux ./vmlinux-5.4.0-33-generic-plus-kcore --insn-trace --xed -C0 -F-dso,-comm,-tid,+flags,+ipc,+srccode,+srcline | head\n[000]  2336.210811381:                        ffffffff9f02fdd0 __switch_to+0x0\n  process_64.c:505              pushq  %rbp\n|505      {\n[000]  2336.210811381:                        ffffffff9f02fdd1 __switch_to+0x1\n  current.h:15          movq  %gs:0x16bc0, %rax\n|515            if (!test_thread_flag(TIF_NEED_FPU_LOAD))\n[000]  2336.210811381:                        ffffffff9f02fdda __switch_to+0xa\n  process_64.c:505              mov %rsp, %rbp\n|505      {\n[000]  2336.210811381:                        ffffffff9f02fddd __switch_to+0xd\n</code></pre> <p>We can tidy that up a bit with awk:</p> <pre><code>$ perf script -i switch-example-3 --vmlinux ./vmlinux-5.4.0-33-generic-plus-kcore --insn-trace --xed -C0 -F-dso,-comm,-tid,+flags,+ipc,+srccode,+srcline | \\\n&gt; awk '/^\\[/ {printf(\"\\n%-85s\",$0)} /^ / {ln=$0;gsub(\"\\t\",\"  \",ln);printf(\"%-58s\",ln)} /^\\|/ {printf(\"%s\",$0)}' | head -138\n\n[000]  2336.210811381:                        ffffffff9f02fdd0 __switch_to+0x0         process_64.c:505     pushq  %rbp                        |505      {\n[000]  2336.210811381:                        ffffffff9f02fdd1 __switch_to+0x1         current.h:15     movq  %gs:0x16bc0, %rax                |515             if (!test_thread_flag(TIF_NEED_FPU_LOAD))\n[000]  2336.210811381:                        ffffffff9f02fdda __switch_to+0xa         process_64.c:505     mov %rsp, %rbp                     |505      {\n[000]  2336.210811381:                        ffffffff9f02fddd __switch_to+0xd         process_64.c:505     pushq  %r15                        \n[000]  2336.210811381:                        ffffffff9f02fddf __switch_to+0xf         process_64.c:507     leaq  0x1340(%rsi), %r15           |507             struct thread_struct *next = &amp;next_p-&gt;thread;\n[000]  2336.210811381:                        ffffffff9f02fde6 __switch_to+0x16        process_64.c:505     pushq  %r14                        |505      {\n[000]  2336.210811381:                        ffffffff9f02fde8 __switch_to+0x18        process_64.c:506     leaq  0x1340(%rdi), %r14           |506             struct thread_struct *prev = &amp;prev_p-&gt;thread;\n[000]  2336.210811381:                        ffffffff9f02fdef __switch_to+0x1f        process_64.c:505     pushq  %r13                        |505      {\n[000]  2336.210811381:                        ffffffff9f02fdf1 __switch_to+0x21        process_64.c:505     mov %rdi, %r13                     \n[000]  2336.210811381:                        ffffffff9f02fdf4 __switch_to+0x24        process_64.c:505     pushq  %r12                        \n[000]  2336.210811381:                        ffffffff9f02fdf6 __switch_to+0x26        process_64.c:505     mov %rsi, %r12                     \n[000]  2336.210811381:                        ffffffff9f02fdf9 __switch_to+0x29        process_64.c:505     pushq  %rbx                        \n[000]  2336.210811381:                        ffffffff9f02fdfa __switch_to+0x2a        process_64.c:505     sub $0x10, %rsp                    \n[000]  2336.210811381:                        ffffffff9f02fdfe __switch_to+0x2e        bitops.h:207     movq  (%rax), %rdx                     |515             if (!test_thread_flag(TIF_NEED_FPU_LOAD))\n[000]  2336.210811381:                        ffffffff9f02fe01 __switch_to+0x31        process_64.c:510     movl  %gs:0x60fe0548(%rip), %ebx   |510             int cpu = smp_processor_id();\n[000]  2336.210811381:                        ffffffff9f02fe08 __switch_to+0x38        process_64.c:515     and $0x40, %dh                     |515             if (!test_thread_flag(TIF_NEED_FPU_LOAD))\n[000]  2336.210811382:   jcc                  ffffffff9f02fe0b __switch_to+0x3b        process_64.c:515     jz 0x2c2    IPC: 2.83 (17/6)       \n[000]  2336.210811382:                        ffffffff9f0300cd __switch_to+0x2fd       internal.h:574     testb  $0x20, 0x26(%rax)             |516                     switch_fpu_prepare(prev_fpu, cpu);\n[000]  2336.210811382:   jcc                  ffffffff9f0300d1 __switch_to+0x301       internal.h:574     jnz 0xfffffffffffffd40               \n[000]  2336.210811382:                        ffffffff9f0300d7 __switch_to+0x307       process_64.c:508     leaq  0x1400(%rdi), %rcx           |508             struct fpu *prev_fpu = &amp;prev-&gt;fpu;\n[000]  2336.210811382:                        ffffffff9f0300de __switch_to+0x30e       cpufeature.h:175     nopl  %eax, (%rax,%rax,1)          |516                     switch_fpu_prepare(prev_fpu, cpu);\n[000]  2336.210811382:                        ffffffff9f0300e3 __switch_to+0x313       internal.h:327     movl  0x181715e(%rip), %r9d          \n[000]  2336.210811382:                        ffffffff9f0300ea __switch_to+0x31a       internal.h:420     leaq  0x1440(%r13), %rdi             \n[000]  2336.210811382:                        ffffffff9f0300f1 __switch_to+0x321       internal.h:327     test %r9d, %r9d                      \n[000]  2336.210811382:   jcc                  ffffffff9f0300f4 __switch_to+0x324       internal.h:327     jz 0x141                             \n[000]  2336.210811382:                        ffffffff9f0300fa __switch_to+0x32a       internal.h:329     mov $0xffffffff, %eax                \n[000]  2336.210811382:                        ffffffff9f0300ff __switch_to+0x32f       internal.h:329     mov %eax, %edx                       \n[000]  2336.210811382:                        ffffffff9f030101 __switch_to+0x331       internal.h:329     xsaves64 (%rdi)                      \n[000]  2336.210811382:                        ffffffff9f030105 __switch_to+0x335       internal.h:329     xor %eax, %eax                       \n[000]  2336.210811382:                        ffffffff9f030107 __switch_to+0x337       internal.h:332     test %eax, %eax                      \n[000]  2336.210811382:   jcc                  ffffffff9f030109 __switch_to+0x339       internal.h:332     jnz 0x125                            \n[000]  2336.210811382:                        ffffffff9f03010f __switch_to+0x33f       internal.h:426     testb  $0xe0, 0x1640(%r13)           \n[000]  2336.210811382:   jcc                  ffffffff9f030117 __switch_to+0x347       internal.h:426     jnz 0xf0                             \n[000]  2336.210811382:                        ffffffff9f03011d __switch_to+0x34d       internal.h:578     movl  %ebx, 0x1400(%r13)             \n[000]  2336.210811382:                        ffffffff9f030124 __switch_to+0x354       jump_label.h:25     nopl  %eax, (%rax,%rax,1)           \n[000]  2336.210811382:   jmp                  ffffffff9f030129 __switch_to+0x359       jump_label.h:34     jmp 0xfffffffffffffce8              \n[000]  2336.210811382:                        ffffffff9f02fe11 __switch_to+0x41        process_64.c:201     mov %fs, %ax                       |523             save_fsgs(prev_p);\n[000]  2336.210811382:                        ffffffff9f02fe14 __switch_to+0x44        process_64.c:201     movw  %ax, 0x1364(%r13)            \n[000]  2336.210811382:                        ffffffff9f02fe1c __switch_to+0x4c        process_64.c:202     mov %gs, %ax                       \n[000]  2336.210811382:                        ffffffff9f02fe1f __switch_to+0x4f        process_64.c:164     cmpw  $0x0, 0x1364(%r13)           \n[000]  2336.210811382:                        ffffffff9f02fe28 __switch_to+0x58        process_64.c:202     movw  %ax, 0x1366(%r13)            \n[000]  2336.210811382:   jcc                  ffffffff9f02fe30 __switch_to+0x60        process_64.c:164     jnz 0x373                          \n[000]  2336.210811382:                        ffffffff9f02fe36 __switch_to+0x66        process_64.c:164     cmpw  $0x0, 0x1366(%r13)           \n[000]  2336.210811428:   jcc                  ffffffff9f02fe3f __switch_to+0x6f        process_64.c:164     jnz 0x346    IPC: 0.13 (27/195)    \n[000]  2336.210811428:                        ffffffff9f02fe45 __switch_to+0x75        paravirt.h:271     mov %ebx, %esi                       |529             load_TLS(next, cpu);\n[000]  2336.210811428:                        ffffffff9f02fe47 __switch_to+0x77        paravirt.h:271     mov %r15, %rdi                       \n[000]  2336.210811428:   call                 ffffffff9f02fe4a __switch_to+0x7a        paravirt.h:271     callq  0x48876                       \n[000]  2336.210811428:                        ffffffff9f0786c0 native_load_tls+0x0     desc.h:282     movq  (%rdi), %rdx                       |282                     gdt[GDT_ENTRY_TLS_MIN + i] = t-&gt;tls_array[i];\n[000]  2336.210811428:                        ffffffff9f0786c3 native_load_tls+0x3     desc.h:57     mov %esi, %esi                            |278             struct desc_struct *gdt = get_cpu_gdt_rw(cpu);\n[000]  2336.210811428:                        ffffffff9f0786c5 native_load_tls+0x5     desc.h:57     mov $0x9000, %rax                         \n[000]  2336.210811428:                        ffffffff9f0786cc native_load_tls+0xc     desc.h:57     addq  -0x5fbbb680(,%rsi,8), %rax          \n[000]  2336.210811428:                        ffffffff9f0786d4 native_load_tls+0x14    desc.h:282     movq  %rdx, 0x60(%rax)                   |282                     gdt[GDT_ENTRY_TLS_MIN + i] = t-&gt;tls_array[i];\n[000]  2336.210811428:                        ffffffff9f0786d8 native_load_tls+0x18    desc.h:282     movq  0x8(%rdi), %rdx                    \n[000]  2336.210811428:                        ffffffff9f0786dc native_load_tls+0x1c    desc.h:282     movq  %rdx, 0x68(%rax)                   \n[000]  2336.210811428:                        ffffffff9f0786e0 native_load_tls+0x20    desc.h:282     movq  0x10(%rdi), %rdx                   \n[000]  2336.210811428:                        ffffffff9f0786e4 native_load_tls+0x24    desc.h:282     movq  %rdx, 0x70(%rax)                   \n[000]  2336.210811429:   return               ffffffff9f0786e8 native_load_tls+0x28    desc.h:283     retq      IPC: 3.25 (13/4)               |283      }\n[000]  2336.210811429:                        ffffffff9f02fe4f __switch_to+0x7f        paravirt.h:271     data16 nop                           |529             load_TLS(next, cpu);\n[000]  2336.210811429:                        ffffffff9f02fe51 __switch_to+0x81        paravirt.h:611     mov %r12, %rdi                       |536             arch_end_context_switch(next_p);\n[000]  2336.210811429:                        ffffffff9f02fe54 __switch_to+0x84        paravirt.h:611     nopl  %eax, (%rax)                   \n[000]  2336.210811429:                        ffffffff9f02fe5b __switch_to+0x8b        process_64.c:552     mov %es, %ax                       |552             savesegment(es, prev-&gt;es);\n[000]  2336.210811429:                        ffffffff9f02fe5e __switch_to+0x8e        process_64.c:552     movw  %ax, 0x20(%r14)              \n[000]  2336.210811429:                        ffffffff9f02fe63 __switch_to+0x93        process_64.c:553     movzxw  0x1360(%r12), %eax         |553             if (unlikely(next-&gt;es | prev-&gt;es))\n[000]  2336.210811429:                        ffffffff9f02fe6c __switch_to+0x9c        process_64.c:553     mov %eax, %ebx                     \n[000]  2336.210811429:                        ffffffff9f02fe6e __switch_to+0x9e        process_64.c:553     orw  0x1360(%r13), %bx             \n[000]  2336.210811430:   jcc                  ffffffff9f02fe76 __switch_to+0xa6        process_64.c:553     jnz 0x31f    IPC: 4.50 (9/2)       \n[000]  2336.210811430:                        ffffffff9f02fe7c __switch_to+0xac        process_64.c:556     mov %ds, %ax                       |556             savesegment(ds, prev-&gt;ds);\n[000]  2336.210811430:                        ffffffff9f02fe7f __switch_to+0xaf        process_64.c:556     movw  %ax, 0x22(%r14)              \n[000]  2336.210811430:                        ffffffff9f02fe84 __switch_to+0xb4        process_64.c:557     movzxw  0x1362(%r12), %eax         |557             if (unlikely(next-&gt;ds | prev-&gt;ds))\n[000]  2336.210811430:                        ffffffff9f02fe8d __switch_to+0xbd        process_64.c:557     mov %eax, %ebx                     \n[000]  2336.210811430:                        ffffffff9f02fe8f __switch_to+0xbf        process_64.c:557     orw  0x1362(%r13), %bx             \n[000]  2336.210811430:   jcc                  ffffffff9f02fe97 __switch_to+0xc7        process_64.c:557     jnz 0x305                          \n[000]  2336.210811430:                        ffffffff9f02fe9d __switch_to+0xcd        process_64.c:283     movq  0x1368(%r12), %rdx           |560             x86_fsgsbase_load(prev, next);\n[000]  2336.210811430:                        ffffffff9f02fea5 __switch_to+0xd5        process_64.c:283     movzxw  0x1364(%r13), %ecx         \n[000]  2336.210811430:                        ffffffff9f02fead __switch_to+0xdd        process_64.c:284     movzxw  0x1364(%r12), %eax         \n[000]  2336.210811430:                        ffffffff9f02feb6 __switch_to+0xe6        process_64.c:236     cmp $0x3, %ax                      \n[000]  2336.210811430:   jcc                  ffffffff9f02feba __switch_to+0xea        process_64.c:236     jnbe 0x2b4                         \n[000]  2336.210811430:                        ffffffff9f02fec0 __switch_to+0xf0        process_64.c:241     test %rdx, %rdx                    \n[000]  2336.210811430:   jcc                  ffffffff9f02fec3 __switch_to+0xf3        process_64.c:241     jz 0x1c2                           \n[000]  2336.210811430:   jmp                  ffffffff9f030085 __switch_to+0x2b5       cpufeature.h:175     jmp 0xd7                           \n[000]  2336.210811430:                        ffffffff9f03015c __switch_to+0x38c       process_64.c:262     or %eax, %ecx                      \n[000]  2336.210811430:                        ffffffff9f03015e __switch_to+0x38e       process_64.c:262     movzx %cx, %ecx                    \n[000]  2336.210811430:                        ffffffff9f030161 __switch_to+0x391       process_64.c:262     orq  0x1368(%r13), %rcx            \n[000]  2336.210811430:   jcc                  ffffffff9f030168 __switch_to+0x398       process_64.c:262     jz 0xfffffffffffffd7a              \n[000]  2336.210811430:                        ffffffff9f03016e __switch_to+0x39e       segment.h:349     mov %ax, %fs                          \n[000]  2336.210811430:   jmp                  ffffffff9f030170 __switch_to+0x3a0       segment.h:356     jmp 0xfffffffffffffd72                \n[000]  2336.210811430:                        ffffffff9f02fee2 __switch_to+0x112       process_64.c:285     movq  0x1370(%r12), %r14           \n[000]  2336.210811430:                        ffffffff9f02feea __switch_to+0x11a       process_64.c:285     movzxw  0x1366(%r13), %eax         \n[000]  2336.210811430:                        ffffffff9f02fef2 __switch_to+0x122       process_64.c:286     movzxw  0x1366(%r12), %ebx         \n[000]  2336.210811430:                        ffffffff9f02fefb __switch_to+0x12b       process_64.c:236     cmp $0x3, %bx                      \n[000]  2336.210811430:   jcc                  ffffffff9f02feff __switch_to+0x12f       process_64.c:236     jnbe 0x24e                         \n[000]  2336.210811430:                        ffffffff9f02ff05 __switch_to+0x135       process_64.c:241     test %r14, %r14                    \n[000]  2336.210811439:   jcc                  ffffffff9f02ff08 __switch_to+0x138       process_64.c:241     jnz 0x19b    IPC: 0.67 (27/40)     \n[000]  2336.210811439:   jmp                  ffffffff9f02ff0e __switch_to+0x13e       cpufeature.h:175     jmp 0x22d                          \n[000]  2336.210811439:                        ffffffff9f03013b __switch_to+0x36b       process_64.c:262     or %ebx, %eax                      \n[000]  2336.210811439:                        ffffffff9f03013d __switch_to+0x36d       process_64.c:262     movzx %ax, %eax                    \n[000]  2336.210811439:                        ffffffff9f030140 __switch_to+0x370       process_64.c:262     orq  0x1370(%r13), %rax            \n[000]  2336.210811439:   jcc                  ffffffff9f030147 __switch_to+0x377       process_64.c:262     jz 0xfffffffffffffde2              \n[000]  2336.210811439:                        ffffffff9f02ff29 __switch_to+0x159       process_64.c:565     movq  %r12, %gs:0x60fe6c8f(%rip)   |565             this_cpu_write(current_task, next_p);\n[000]  2336.210811439:                        ffffffff9f02ff31 __switch_to+0x161       process_64.c:566     movq  0x18(%r12), %rax             |566             this_cpu_write(cpu_current_top_of_stack, task_top_of_stack(next_p));\n[000]  2336.210811439:                        ffffffff9f02ff36 __switch_to+0x166       process_64.c:566     add $0x4000, %rax                  \n[000]  2336.210811439:                        ffffffff9f02ff3c __switch_to+0x16c       process_64.c:566     movq  %rax, %gs:0x60fd60c8(%rip)   \n[000]  2336.210811439:                        ffffffff9f02ff44 __switch_to+0x174       internal.h:595     movl  0x161efa6(%rip), %ebx          |568             switch_fpu_finish(next_fpu);\n[000]  2336.210811439:                        ffffffff9f02ff4a __switch_to+0x17a       current.h:15     movq  %gs:0x16bc0, %rax                \n[000]  2336.210811439:                        ffffffff9f02ff53 __switch_to+0x183       bitops.h:55     lock orb  $0x40, 0x1(%rax)              \n[000]  2336.210811439:   jmp                  ffffffff9f02ff58 __switch_to+0x188       cpufeature.h:175     jmp 0x41                           \n[000]  2336.210811439:   jmp                  ffffffff9f02ff99 __switch_to+0x1c9       cpufeature.h:175     jmp 0x18                           |571             update_task_stack(next_p);\n[000]  2336.210811439:                        ffffffff9f02ffb1 __switch_to+0x1e1       process.h:16     movq  (%r12), %rdx                     |573             switch_to_extra(prev_p, next_p);\n[000]  2336.210811439:                        ffffffff9f02ffb5 __switch_to+0x1e5       process.h:17     movq  (%r13), %rax                     \n[000]  2336.210811439:                        ffffffff9f02ffb9 __switch_to+0x1e9       jump_label.h:41     nopl  %eax, (%rax,%rax,1)           \n[000]  2336.210811439:                        ffffffff9f02ffbe __switch_to+0x1ee       process.h:36     and $0x2418620, %edx                   \n[000]  2336.210811439:                        ffffffff9f02ffc4 __switch_to+0x1f4       process.h:36     and $0x2418e20, %eax                   \n[000]  2336.210811439:                        ffffffff9f02ffc9 __switch_to+0x1f9       process.h:36     or %rax, %rdx                          \n[000]  2336.210811439:   jcc                  ffffffff9f02ffcc __switch_to+0x1fc       process.h:36     jnz 0x1a9                              \n[000]  2336.210811439:   jmp                  ffffffff9f02ffd2 __switch_to+0x202       cpufeature.h:175     jmp 0x1a                           |581             if (unlikely(static_cpu_has(X86_FEATURE_XENPV) &amp;&amp;\n[000]  2336.210811439:   jmp                  ffffffff9f02ffec __switch_to+0x21c       cpufeature.h:175     jmp 0x15                           |586             if (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) {\n[000]  2336.210811439:   jmp                  ffffffff9f030001 __switch_to+0x231       jump_label.h:41     jmp 0x72                            |615             resctrl_sched_in();\n[000]  2336.210811439:                        ffffffff9f030073 __switch_to+0x2a3       process_64.c:618     add $0x10, %rsp                    |618      }\n[000]  2336.210811439:                        ffffffff9f030077 __switch_to+0x2a7       process_64.c:618     mov %r13, %rax                     \n[000]  2336.210811439:                        ffffffff9f03007a __switch_to+0x2aa       process_64.c:618     popq  %rbx                         \n[000]  2336.210811439:                        ffffffff9f03007b __switch_to+0x2ab       process_64.c:618     popq  %r12                         \n[000]  2336.210811439:                        ffffffff9f03007d __switch_to+0x2ad       process_64.c:618     popq  %r13                         \n[000]  2336.210811439:                        ffffffff9f03007f __switch_to+0x2af       process_64.c:618     popq  %r14                         \n[000]  2336.210811439:                        ffffffff9f030081 __switch_to+0x2b1       process_64.c:618     popq  %r15                         \n[000]  2336.210811439:                        ffffffff9f030083 __switch_to+0x2b3       process_64.c:618     popq  %rbp                         \n[000]  2336.210811468:   tr end  return       ffffffff9f030084 __switch_to+0x2b4       process_64.c:618     retq      IPC: 0.27 (33/122)       \n[000]  2336.210817292:                        ffffffff9f02fdd0 __switch_to+0x0         process_64.c:505     pushq  %rbp                        |505      {\n[000]  2336.210817292:                        ffffffff9f02fdd1 __switch_to+0x1         current.h:15     movq  %gs:0x16bc0, %rax                |515             if (!test_thread_flag(TIF_NEED_FPU_LOAD))\n[000]  2336.210817292:                        ffffffff9f02fdda __switch_to+0xa         process_64.c:505     mov %rsp, %rbp                     |505      {\n[000]  2336.210817292:                        ffffffff9f02fddd __switch_to+0xd         process_64.c:505     pushq  %r15                        \n[000]  2336.210817292:                        ffffffff9f02fddf __switch_to+0xf         process_64.c:507     leaq  0x1340(%rsi), %r15           |507             struct thread_struct *next = &amp;next_p-&gt;thread;\n[000]  2336.210817292:                        ffffffff9f02fde6 __switch_to+0x16        process_64.c:505     pushq  %r14                        |505      {\n[000]  2336.210817292:                        ffffffff9f02fde8 __switch_to+0x18        process_64.c:506     leaq  0x1340(%rdi), %r14           |506             struct thread_struct *prev = &amp;prev_p-&gt;thread;\n[000]  2336.210817292:                        ffffffff9f02fdef __switch_to+0x1f        process_64.c:505     pushq  %r13                        |505      {\n[000]  2336.210817292:                        ffffffff9f02fdf1 __switch_to+0x21        process_64.c:505     mov %rdi, %r13                     \n[000]  2336.210817292:                        ffffffff9f02fdf4 __switch_to+0x24        process_64.c:505     pushq  %r12                        \n[000]  2336.210817292:                        ffffffff9f02fdf6 __switch_to+0x26        process_64.c:505     mov %rsi, %r12                     \n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-tracing-gui-program-kcalc","title":"Example: Tracing GUI program <code>kcalc</code>","text":"<p>Tracing a GUI program produces a very large trace.  In this case, a simple calculator program <code>kcalc</code> is started and immediately closed.</p> <p>First we can get some debug packages:</p> <pre><code>$ debug_packages=$(find-dbgsym-packages $(which kcalc))\ndpkg-query: no path found matching pattern /lib/x86_64-linux-gnu/libXau.so.6\nW: Cannot find debug package for /lib/x86_64-linux-gnu/libXau.so.6 (f387ef05bc753c7843a31067224d3d3e92b7190e)\ndpkg-query: no path found matching pattern /lib/x86_64-linux-gnu/libstdc++.so.6\nW: Cannot find debug package for /lib/x86_64-linux-gnu/libstdc++.so.6 (48f1a714f64ac85caa1496bcb14275c8ff0aeace)\ndpkg-query: no path found matching pattern /lib/x86_64-linux-gnu/libogg.so.0\nW: Cannot find debug package for /lib/x86_64-linux-gnu/libogg.so.0 (861e2c0ca7f6c2ddfdffaf0ea9831e9ae84a44ac)\n$ echo $debug_packages \nkcalc-dbgsym lib32stdc++6-10-dbg lib64stdc++6-10-dbg libbsd0-dbgsym libbz2-1.0-dbgsym libcanberra0-dbgsym libdbus-1-3-dbgsym libdbusmenu-qt5-2-dbgsym libdouble-conversion3-dbgsym libfam0-dbgsym libfreetype6-dbgsym libgcrypt20-dbgsym libgl1-dbgsym libglib2.0-0-dbgsym libglvnd0-dbgsym libglx0-dbgsym libgmp10-dbgsym libgpg-error0-dbgsym libgraphite2-3-dbgsym libharfbuzz0b-dbgsym libicu66-dbgsym libkf5archive5-dbgsym libkf5attica5-dbgsym libkf5authcore5-dbgsym libkf5codecs5-dbgsym libkf5configcore5-dbgsym libkf5configgui5-dbgsym libkf5configwidgets5-dbgsym libkf5coreaddons5-dbgsym libkf5crash5-dbgsym libkf5globalaccel5-dbgsym libkf5guiaddons5-dbgsym libkf5i18n5-dbgsym libkf5iconthemes5-dbgsym libkf5itemviews5-dbgsym libkf5notifications5-dbgsym libkf5widgetsaddons5-dbgsym libkf5windowsystem5-dbgsym libkf5xmlgui5-dbgsym libltdl7-dbgsym liblz4-1-dbgsym liblzma5-dbgsym libmpfr6-dbgsym libpcre2-16-0-dbgsym libpcre3-dbg libpng16-16-dbgsym libqt5core5a-dbgsym libqt5dbus5-dbgsym libqt5gui5-dbgsym libqt5network5-dbgsym libqt5printsupport5-dbgsym libqt5svg5-dbgsym libqt5texttospeech5-dbgsym libqt5widgets5-dbgsym libqt5x11extras5-dbgsym libqt5xml5-dbgsym libstdc++6-10-dbg libsystemd0-dbgsym libtdb1-dbgsym libvorbis0a-dbgsym libvorbisfile3-dbgsym libx11-6-dbgsym libx32stdc++6-10-dbg libxcb-keysyms1-dbgsym libxcb1-dbgsym libxdmcp6-dbg zlib1g-dbgsym\n</code></pre> <p>find-dbgsym-packages fails in 3 cases because Ubuntu mixes up /lib and /usr/lib, but we can find them if we put in the correct names:</p> <pre><code>$ more_debug_packages=$(find-dbgsym-packages /usr/lib/x86_64-linux-gnu/libXau.so.6 /usr/lib/x86_64-linux-gnu/libstdc++.so.6 /usr/lib/x86_64-linux-gnu/libogg.so.0)\n$ echo $more_debug_packages \nlib32stdc++6-10-dbg lib64stdc++6-10-dbg libogg-dbg libstdc++6-10-dbg libx32stdc++6-10-dbg libxau6-dbg\n</code></pre> <p>We can try to install those:</p> <pre><code>$ sudo apt-get install $debug_packages $more_debug_packages \n[sudo] password for ahunter: \nReading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nSome packages could not be installed. This may mean that you have\nrequested an impossible situation or if you are using the unstable\ndistribution that some required packages have not yet been created\nor been moved out of Incoming.\nThe following information may help to resolve the situation:\n\nThe following packages have unmet dependencies:\n lib64stdc++6-10-dbg:i386 : Depends: lib64stdc++6:i386 (&gt;= 10-20200411-0ubuntu1) but it is not going to be installed\n                            Depends: lib64gcc-s1:i386 (&gt;= 4.2) but it is not going to be installed\n                            Depends: libc6-amd64:i386 (&gt;= 2.18) but it is not going to be installed\n liblzma5-dbgsym : Depends: liblzma5 (= 5.2.4-1ubuntu1) but 5.2.4-1 is to be installed\nE: Unable to correct problems, you have held broken packages.\n</code></pre> <p>But it seems the dependencies are wrong, so we leave out those ones and get the rest:</p> <pre><code>$ sudo apt-get install kcalc-dbgsym lib32stdc++6-10-dbg libbsd0-dbgsym libbz2-1.0-dbgsym libcanberra0-dbgsym libdbus-1-3-dbgsym libdbusmenu-qt5-2-dbgsym libdouble-conversion3-dbgsym libfam0-dbgsym libfreetype6-dbgsym libgcrypt20-dbgsym libgl1-dbgsym libglib2.0-0-dbgsym libglvnd0-dbgsym libglx0-dbgsym libgmp10-dbgsym libgpg-error0-dbgsym libgraphite2-3-dbgsym libharfbuzz0b-dbgsym libicu66-dbgsym libkf5archive5-dbgsym libkf5attica5-dbgsym libkf5authcore5-dbgsym libkf5codecs5-dbgsym libkf5configcore5-dbgsym libkf5configgui5-dbgsym libkf5configwidgets5-dbgsym libkf5coreaddons5-dbgsym libkf5crash5-dbgsym libkf5globalaccel5-dbgsym libkf5guiaddons5-dbgsym libkf5i18n5-dbgsym libkf5iconthemes5-dbgsym libkf5itemviews5-dbgsym libkf5notifications5-dbgsym libkf5widgetsaddons5-dbgsym libkf5windowsystem5-dbgsym libkf5xmlgui5-dbgsym libltdl7-dbgsym liblz4-1-dbgsym libmpfr6-dbgsym libogg-dbg libpcre2-16-0-dbgsym libpcre3-dbg libpng16-16-dbgsym libqt5core5a-dbgsym libqt5dbus5-dbgsym libqt5gui5-dbgsym libqt5network5-dbgsym libqt5printsupport5-dbgsym libqt5svg5-dbgsym libqt5texttospeech5-dbgsym libqt5widgets5-dbgsym libqt5x11extras5-dbgsym libqt5xml5-dbgsym libstdc++6-10-dbg libsystemd0-dbgsym libtdb1-dbgsym libvorbis0a-dbgsym libvorbisfile3-dbgsym libx11-6-dbgsym libx32stdc++6-10-dbg libxau6-dbg libxcb1-dbgsym libxcb-keysyms1-dbgsym libxdmcp6-dbg zlib1g-dbgsym\n</code></pre> <p>This example uses <code>perf record</code> with extra privileges, as described in the Adding capabilities to <code>perf</code> section.</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-m,64M</code> to set the trace buffer size to 64 MiB.  This is needed to avoid trace data loss.  Note the comma is needed.  Also be careful setting large buffer sizes.  With per-cpu tracing (the default), one buffer per CPU will be allocated.  In our case we have 8 CPUs so that means 512 MiB.  However when tracing with per-task contexts, there will be one buffer per task, which might be far more than anticipated.</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt//u</code> to get Intel PT tracing userspace only</li> <li><code>kcalc</code> is the workload.</li> </ul> <pre><code>$ perf record -m,64M -e intel_pt//u kcalc\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 76.373 MB perf.data ]\n</code></pre> <p>Using <code>perf report</code>, we can get a profile with call chains without needing any special options:</p> <pre><code>$ perf report | head -156\n# To display the perf.data header info, please use --header/--header-only options.\n#\n#\n# Total Lost Samples: 0\n#\n# Samples: 0  of event 'intel_pt//u'\n# Event count (approx.): 0\n#\n# Children      Self  Command  Shared Object  Symbol\n# ........  ........  .......  .............  ......\n#\n\n\n# Samples: 0  of event 'dummy:u'\n# Event count (approx.): 0\n#\n# Children      Self  Command  Shared Object  Symbol\n# ........  ........  .......  .............  ......\n#\n\n\n# Samples: 0  of event 'dummy:u'\n# Event count (approx.): 0\n#\n# Children      Self  Command  Shared Object  Symbol\n# ........  ........  .......  .............  ......\n#\n\n\n# Samples: 1K of event 'instructions:u'\n# Event count (approx.): 1030926311\n#\n# Children      Self  Command          Shared Object                  Symbol                                                                                                                                                                                                                               \n# ........  ........  ...............  .............................  .....................................................................................................................................................................................................................................\n#\n    41.00%     0.00%  kcalc            libQt5Gui.so.5.12.8            [.] QFontDatabase::findFont\n            |\n            ---QFontDatabase::findFont\n               |          \n               |--36.29%--loadEngine\n               |          QFontconfigDatabase::fontEngine\n               |          |          \n               |           --35.82%--QFontconfigDatabase::setupFontEngine\n               |                     |          \n               |                     |--27.98%--FcFontMatch\n               |                     |          0x7f0068874c6d\n               |                     |          |          \n               |                     |           --27.62%--0x7f0068874b42\n               |                     |                     |          \n               |                     |                      --22.71%--0x7f0068874845\n               |                     |                                |          \n               |                     |                                |--15.92%--0x7f006887469f\n               |                     |                                |          |          \n               |                     |                                |          |--7.57%--0x7f006887c198\n               |                     |                                |          |          |          \n               |                     |                                |          |           --3.03%--0x7f006887be36\n               |                     |                                |          |                     |          \n               |                     |                                |          |                      --2.21%--__strchr_avx2\n               |                     |                                |          |          \n               |                     |                                |           --6.99%--0x7f006887c18b\n               |                     |                                |                     |          \n               |                     |                                |                      --2.70%--0x7f006887be36\n               |                     |                                |                                |          \n               |                     |                                |                                 --2.23%--__strchr_avx2\n               |                     |                                |          \n               |                     |                                |--1.75%--0x7f006887447b\n               |                     |                                |          FcStrCmpIgnoreCase\n               |                     |                                |          \n               |                     |                                 --1.36%--0x7f006887464f\n               |                     |          \n               |                      --7.84%--FcConfigSubstituteWithPat\n               |                                |          \n               |                                |--4.29%--0x7f00688639f7\n               |                                |          |          \n               |                                |          |--2.35%--0x7f006887c198\n               |                                |          |          |          \n               |                                |          |           --0.66%--0x7f006887be36\n               |                                |          |                     |          \n               |                                |          |                      --0.56%--__strchr_avx2\n               |                                |          |          \n               |                                |           --1.31%--0x7f006887c18b\n               |                                |                     |          \n               |                                |                      --0.51%--0x7f006887be36\n               |                                |                                __strchr_avx2\n               |                                |          \n               |                                 --0.54%--0x7f0068863a1c\n               |                                           FcStrStrIgnoreCase\n               |          \n                --4.71%--initializeDb\n                          QFontconfigDatabase::populateFontDatabase\n                          |          \n                          |--2.01%--FcFontList\n                          |          FcFontSetList\n                          |          |          \n                          |           --0.52%--0x7f006887c240\n                          |          \n                          |--1.66%--populateFromPattern\n                          |          |          \n                          |           --1.03%--FcLangSetHasLang\n                          |          \n                           --0.88%--0x7f006886318d\n                                     0x7f0068863157\n                                     |          \n                                      --0.51%--0x7f00688711db\n\n    36.29%     0.00%  kcalc            libQt5Gui.so.5.12.8            [.] loadEngine\n            |\n            ---loadEngine\n               QFontconfigDatabase::fontEngine\n               |          \n                --35.82%--QFontconfigDatabase::setupFontEngine\n                          |          \n                          |--27.98%--FcFontMatch\n                          |          0x7f0068874c6d\n                          |          |          \n                          |           --27.62%--0x7f0068874b42\n                          |                     |          \n                          |                      --22.71%--0x7f0068874845\n                          |                                |          \n                          |                                |--15.92%--0x7f006887469f\n                          |                                |          |          \n                          |                                |          |--7.57%--0x7f006887c198\n                          |                                |          |          |          \n                          |                                |          |           --3.03%--0x7f006887be36\n                          |                                |          |                     |          \n                          |                                |          |                      --2.21%--__strchr_avx2\n                          |                                |          |          \n                          |                                |           --6.99%--0x7f006887c18b\n                          |                                |                     |          \n                          |                                |                      --2.70%--0x7f006887be36\n                          |                                |                                |          \n                          |                                |                                 --2.23%--__strchr_avx2\n                          |                                |          \n                          |                                |--1.75%--0x7f006887447b\n                          |                                |          FcStrCmpIgnoreCase\n                          |                                |          \n                          |                                 --1.36%--0x7f006887464f\n                          |          \n                           --7.84%--FcConfigSubstituteWithPat\n                                     |          \n                                     |--4.29%--0x7f00688639f7\n                                     |          |          \n                                     |          |--2.35%--0x7f006887c198\n                                     |          |          |          \n                                     |          |           --0.66%--0x7f006887be36\n                                     |          |                     |          \n                                     |          |                      --0.56%--__strchr_avx2\n                                     |          |          \n                                     |           --1.31%--0x7f006887c18b\n                                     |                     |          \n                                     |                      --0.51%--0x7f006887be36\n                                     |                                __strchr_avx2\n                                     |          \n                                      --0.54%--0x7f0068863a1c\n                                                FcStrStrIgnoreCase\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-using-sql-to-analyze-latencies","title":"Example: Using SQL to analyze latencies","text":"<p>In this example, eMMC driver latencies are analyzed.</p> <p>On an otherwise idle test system, we can run a small test with dd and trace it with Intel PT.  In this case we will trace as root.</p> <p>The test case is reading from the eMMC because reading is faster and therefore is affected more by latencies.</p> <p>First we can drop caches:</p> <pre><code># sync\n# echo 3 &gt; /proc/sys/vm/drop_caches\n[  398.282985] sh (207): drop_caches: 3\n</code></pre> <p>We can start an open-ended trace, then run the test case <code>dd</code> command, then kill <code>perf</code> to end the trace.</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-o t4</code> to name the output t4 as it was, in fact, our the 4th test</li> <li><code>-a</code> to trace system wide i.e. all tasks, all CPUs</li> <li><code>--kcore</code> to copy kernel object code from the /proc/kcore image (helps avoid decoding errors due to kernel self-modifying code)</li> <li><code>--no-bpf-event</code> to avoid unwanted bpf events because they were making perf segfault.</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt/cyc,mtc=0/k</code> to get Intel PT with cycle-accurate mode.  We also avoid MTC packets which was found to give a better trace in this case.</li> </ul> <pre><code># perf record -o t4 -a --kcore --no-bpf-event -e intel_pt/cyc,mtc=0/k &amp;\n# dd if=/mnt/mmc/afile of=/dev/null bs=4096\n4096+0 records in\n4096+0 records out\n16777216 bytes (17 MB, 16 MiB) copied, 0.0758838 s, 221 MB/s\n# kill %1\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 1.923 MB t4 ]\n[1]+  Terminated                 perf record -o t4 -a --kcore --no-bpf-event -e intel_pt/cyc,mtc=0/k\n</code></pre> <p>Note, because the test system is otherwise idle, and the test case is small and I/O bound, the resulting trace is really quite small.</p> <p>For a kernel trace with the <code>--kcore</code> option, the output directory (called t4 in this case) and everything in it, is all that we need, so we transfer it to another machine for analysis.</p> <p>There, we can export it to a SQLite3 database:</p> <pre><code>$ perf script -i t4 --itrace=bep -s ~/libexec/perf-core/scripts/python/export-to-sqlite.py t4.db branches calls\n2020-06-09 11:17:12.507846 Creating database ...\n2020-06-09 11:17:12.512662 Writing records...\n2020-06-09 11:18:13.610538 Adding indexes\n2020-06-09 11:18:14.168248 Dropping unused tables\n2020-06-09 11:18:14.177895 Done\n</code></pre> <p>To make sense of the trace we need some kernel knowledge, as follows: - The function that performs the 'read' system call is called vfs_read - The function that issues eMMC I/O is called mmc_blk_mq_issue_rq - The function that completes eMMC I/O is called mmc_blk_mq_complete</p> <p>The database contains a table of function calls which shows the time that each function started (call_time) and the time that it ended (return_time).  That table has a 'view' named 'calls_view' which is easier to deal with.</p> <p>The SQL below is fairly straight forward, and it is likely even someone without SQL knowledge can understand most of it.  There are 2 tricks. First, sqlite3 doesn't size columns correctly so we need to artificially make the 'symbol' column wider by renaming it with a long name <code>\"symbol&amp;nbsp;name&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;\"</code>. Secondly, to show the call_time difference to the previous row, the LAG function is used.  That doesn't make sense on the first row, but on the second row, the value is 411032602702 - 411032546128 = 56574.</p> <pre><code>$ sqlite3  -column -header t4.db \\\n&gt; 'SELECT call_id,command,symbol AS \"symbol name            \",call_time,call_time - LAG(call_time,1,0) OVER (ORDER BY id) call_time_lag,\n&gt; return_time,elapsed_time,branch_count,insn_count,cyc_count,IPC,flags \n&gt; FROM calls_view WHERE (command = \"dd\" AND symbol = \"vfs_read\") OR symbol IN (\"mmc_blk_mq_issue_rq\", \"mmc_blk_mq_complete\") ORDER BY call_time;' | head -100\ncall_id     command     symbol name              call_time     call_time_lag  return_time   elapsed_time  branch_count  insn_count  cyc_count   IPC         flags     \n----------  ----------  -----------------------  ------------  -------------  ------------  ------------  ------------  ----------  ----------  ----------  ----------\n182536      dd          vfs_read                 411032546128  411032546128   411032550680  4552          293           2573        8890        0.29                  \n191117      dd          vfs_read                 411032602702  56574          411032605663  2961          285           2397        5726        0.42                  \n199364      dd          vfs_read                 411032652150  49448          411032655372  3222          282           2499        6233        0.4                   \n256863      dd          vfs_read                 411033324366  672216         411035014934  1690568       2456          19464       78746       0.25                  \n434468      kworker/3:  mmc_blk_mq_issue_rq      411034185597  861231         411034195025  9428          117           1005        18042       0.06                  \n436485      swapper     mmc_blk_mq_complete      411035001225  815628         411035009951  8726          464           3630        16785       0.22        jump      \n437997      dd          vfs_read                 411035018460  17235          411035041818  23358         2194          17360       27335       0.64                  \n440393      kworker/3:  mmc_blk_mq_issue_rq      411035034183  15723          411035038508  4325          95            727         1785        0.41                  \n441291      dd          vfs_read                 411035043009  8826           411035044052  1043          119           1169        2080        0.56                  \n441496      dd          vfs_read                 411035044594  1585           411035045478  884           119           1169        1722        0.68                  \n441701      dd          vfs_read                 411035045885  1291           411035343621  297736        3981          36177       30929       1.17                  \n445677      kworker/3:  mmc_blk_mq_issue_rq      411035061376  15491          411035065210  3834          95            848         1079        0.79                  \n447604      swapper     mmc_blk_mq_complete      411035337501  276125         411035340344  2843          340           2692        5469        0.49        jump      \n448875      dd          vfs_read                 411035344722  7221           411035345661  939           119           1169        1846        0.63                  \n449080      dd          vfs_read                 411035346106  1384           411035347080  974           119           1169        1894        0.62                  \n449285      dd          vfs_read                 411035347486  1380           411035348326  840           119           1169        1636        0.71                  \n449490      dd          vfs_read                 411035348733  1247           411035349616  883           119           1169        1724        0.68                  \n449695      dd          vfs_read                 411035350151  1418           411035350869  718           119           1169        1402        0.83                  \n449900      dd          vfs_read                 411035351288  1137           411035352137  849           119           1169        1657        0.71                  \n450105      dd          vfs_read                 411035352538  1250           411035353358  820           119           1169        1601        0.73                  \n450310      dd          vfs_read                 411035353758  1220           411035716494  362736        6102          50580       39418       1.28                  \n456386      kworker/3:  mmc_blk_mq_issue_rq      411035373641  19883          411035377812  4171          112           1078        8037        0.13                  \n457553      swapper     mmc_blk_mq_complete      411035710799  337158         411035713234  2435          368           2956        4685        0.63        jump      \n458851      dd          vfs_read                 411035717565  6766           411035718671  1106          119           1169        2207        0.53                  \n459056      dd          vfs_read                 411035719152  1587           411035719880  728           119           1169        1420        0.82                  \n459261      dd          vfs_read                 411035720292  1140           411035721143  851           119           1169        1661        0.7                   \n459466      dd          vfs_read                 411035721544  1252           411035722345  801           119           1169        1560        0.75                  \n459671      dd          vfs_read                 411035722750  1206           411035723805  1055          119           1169        2051        0.57                  \n459876      dd          vfs_read                 411035724202  1452           411035725094  892           119           1169        1738        0.67                  \n460081      dd          vfs_read                 411035725494  1292           411035726204  710           119           1169        1390        0.84                  \n460286      dd          vfs_read                 411035726612  1118           411035727364  752           119           1169        1471        0.79                  \n460491      dd          vfs_read                 411035727769  1157           411035728705  936           119           1169        1821        0.64                  \n460696      dd          vfs_read                 411035729098  1329           411035729929  831           119           1169        1621        0.72                  \n460901      dd          vfs_read                 411035730327  1229           411035731267  940           119           1169        1831        0.64                  \n461106      dd          vfs_read                 411035731667  1340           411035732415  748           119           1169        1461        0.8                   \n461311      dd          vfs_read                 411035732827  1160           411035733667  840           119           1169        1638        0.71                  \n461516      dd          vfs_read                 411035734066  1239           411035734884  818           119           1169        1598        0.73                  \n461721      dd          vfs_read                 411035735284  1218           411035736118  834           119           1169        1627        0.72                  \n461926      dd          vfs_read                 411035736515  1231           411036291139  554624        6669          60095       46591       1.29                  \n468611      kworker/3:  mmc_blk_mq_issue_rq      411035760954  24439          411035765009  4055          112           1078        7813        0.14                  \n474012      swapper     mmc_blk_mq_complete      411036285461  524507         411036288423  2962          448           3710        5697        0.65        jump      \n475391      dd          vfs_read                 411036292157  6696           411036293361  1204          121           1032        2343        0.44                  \n475598      dd          vfs_read                 411036293848  1691           411036294695  847           121           1032        1612        0.64                  \n475805      dd          vfs_read                 411036295112  1264           411036295943  831           121           1032        1578        0.65                  \n476012      dd          vfs_read                 411036296352  1240           411036297270  918           121           1032        1749        0.59                  \n476219      dd          vfs_read                 411036297672  1320           411036298519  847           121           1032        1610        0.64                  \n476426      dd          vfs_read                 411036298929  1257           411036299781  852           121           1032        1620        0.64                  \n476633      dd          vfs_read                 411036300180  1251           411036300978  798           121           1032        1515        0.68                  \n476840      dd          vfs_read                 411036301379  1199           411036302205  826           121           1032        1573        0.66                  \n477047      dd          vfs_read                 411036302605  1226           411036303510  905           121           1032        1723        0.6                   \n477254      dd          vfs_read                 411036303908  1303           411036304798  890           121           1032        1696        0.61                  \n477461      dd          vfs_read                 411036305195  1287           411036306098  903           121           1032        1718        0.6                   \n477668      dd          vfs_read                 411036306504  1309           411036307202  698           121           1032        1324        0.78                  \n477875      dd          vfs_read                 411036307618  1114           411036308522  904           121           1032        1721        0.6                   \n478082      dd          vfs_read                 411036308920  1302           411036309859  939           121           1032        1790        0.58                  \n478289      dd          vfs_read                 411036310258  1338           411036311112  854           121           1032        1624        0.64                  \n478496      dd          vfs_read                 411036311513  1255           411036312423  910           121           1032        1733        0.6                   \n478703      dd          vfs_read                 411036312822  1309           411036313592  770           121           1032        1462        0.71                  \n478910      dd          vfs_read                 411036314007  1185           411036314864  857           121           1032        1633        0.63                  \n479117      dd          vfs_read                 411036315262  1255           411036316193  931           121           1032        1773        0.58                  \n479324      dd          vfs_read                 411036316595  1333           411036317407  812           121           1032        1548        0.67                  \n479531      dd          vfs_read                 411036317809  1214           411036318730  921           121           1032        1752        0.59                  \n479738      dd          vfs_read                 411036319136  1327           411036319845  709           121           1032        1348        0.77                  \n479945      dd          vfs_read                 411036320259  1123           411036321429  1170          121           1032        2232        0.46                  \n480152      dd          vfs_read                 411036321833  1574           411036322748  915           121           1032        1744        0.59                  \n480359      dd          vfs_read                 411036323151  1318           411036323889  738           121           1032        1401        0.74                  \n480566      dd          vfs_read                 411036324307  1156           411036325164  857           121           1032        1634        0.63                  \n480773      dd          vfs_read                 411036325563  1256           411036326289  726           121           1032        1378        0.75                  \n480980      dd          vfs_read                 411036326696  1133           411036327544  848           121           1032        1614        0.64                  \n481187      dd          vfs_read                 411036328079  1383           411036328981  902           121           1032        1716        0.6                   \n481394      dd          vfs_read                 411036329382  1303           411036330224  842           121           1032        1604        0.64                  \n481601      dd          vfs_read                 411036330622  1240           411036331534  912           121           1032        1735        0.59                  \n481808      dd          vfs_read                 411036331931  1309           411036866337  534406        6223          51811       38456       1.35                  \n488019      kworker/3:  mmc_blk_mq_issue_rq      411036351419  19488          411036355435  4016          112           1078        7740        0.14                  \n489216      swapper     mmc_blk_mq_complete      411036860963  509544         411036863938  2975          437           3562        4657        0.76        jump      \n490583      dd          vfs_read                 411036867336  6373           411036868323  987           121           1032        1884        0.55                  \n490790      dd          vfs_read                 411036868742  1406           411036869660  918           121           1032        1751        0.59                  \n490997      dd          vfs_read                 411036870070  1328           411036871041  971           121           1032        1847        0.56                  \n491204      dd          vfs_read                 411036871454  1384           411036872335  881           121           1032        1678        0.62                  \n491411      dd          vfs_read                 411036872734  1280           411036873536  802           121           1032        1523        0.68                  \n491618      dd          vfs_read                 411036873936  1202           411036874802  866           121           1032        1642        0.63                  \n491825      dd          vfs_read                 411036875207  1271           411036876030  823           121           1032        1564        0.66                  \n492032      dd          vfs_read                 411036876429  1222           411036877279  850           121           1032        1619        0.64                  \n492239      dd          vfs_read                 411036877677  1248           411036878577  900           121           1032        1712        0.6                   \n492446      dd          vfs_read                 411036878976  1299           411036879801  825           121           1032        1571        0.66                  \n492653      dd          vfs_read                 411036880199  1223           411036881130  931           121           1032        1769        0.58                  \n492860      dd          vfs_read                 411036881526  1327           411036882247  721           121           1032        1326        0.78                  \n493067      dd          vfs_read                 411036882653  1127           411036883546  893           121           1032        1700        0.61                  \n493274      dd          vfs_read                 411036883946  1293           411036884759  813           121           1032        1547        0.67                  \n493481      dd          vfs_read                 411036885167  1221           411036885989  822           121           1032        1563        0.66                  \n493688      dd          vfs_read                 411036886387  1220           411036887255  868           121           1032        1651        0.63                  \n493895      dd          vfs_read                 411036887652  1265           411036888461  809           121           1032        1538        0.67                  \n494102      dd          vfs_read                 411036888862  1210           411036889721  859           121           1032        1632        0.63                  \n494309      dd          vfs_read                 411036890119  1257           411036891039  920           121           1032        1751        0.59                  \n494516      dd          vfs_read                 411036891439  1320           411036892243  804           121           1032        1528        0.68                  \n494723      dd          vfs_read                 411036892641  1202           411036893542  901           121           1032        1716        0.6                   \n494930      dd          vfs_read                 411036893941  1300           411036894625  684           121           1032        1296        0.8                   \n495137      dd          vfs_read                 411036895162  1221           411036896011  849           121           1032        1615        0.64                  \n</code></pre> <p>The number of vfs_read between each eMMC I/O increases because of readahead.  It grows to 32 because the dd block size was 4096 and 32 * 4096 = 128 KiB which is the readahead value determined on the test system as follows:</p> <pre><code># cat /sys/block/mmcblk0/queue/read_ahead_kb\n128\n</code></pre> <p>When vfs_read gets cached data, it takes less that a microsecond.  However the vfs_read that triggers I/O settles at about 550 us.  The latency between the system call and the I/O being issued is about 20 to 25 us.</p> <p>Of interest is the very first vfs_read that causes I/O.  It takes about 1.7 ms.  About half of that is spent before the I/O is even issued.  One possibility is runtime power management - resuming to a ready state from a low power state. So we can add the runtime power management function __pm_runtime_resume to the SQL query and see if that fits:</p> <pre><code>$ sqlite3  -column -header t4.db \\\n&gt; 'SELECT call_id,command,symbol AS \"symbol name            \",call_time,call_time - LAG(call_time,1,0) OVER (ORDER BY id) call_time_lag,\n&gt; return_time,elapsed_time,branch_count,insn_count,cyc_count,IPC,flags  \n&gt; FROM calls_view WHERE (command = \"dd\" AND symbol = \"vfs_read\") OR \n&gt; symbol IN (\"mmc_blk_mq_issue_rq\", \"mmc_blk_mq_complete\", \"__pm_runtime_resume\", \"sdhci_pci_runtime_resume\", \"sdhci_pci_runtime_suspend\") ORDER BY call_time;' | head -30\ncall_id     command          symbol name              call_time     call_time_lag  return_time   elapsed_time  branch_count  insn_count  cyc_count   IPC         flags     \n----------  ---------------  -----------------------  ------------  -------------  ------------  ------------  ------------  ----------  ----------  ----------  ----------\n63682       kworker/3:2-eve  __pm_runtime_resume      408067236586  408067236586   408067237097  511           13            135         1789        0.08                  \n114034      kworker/3:2-eve  __pm_runtime_resume      410051235334  1983998748     410051235411  77            13            135         245         0.55                  \n182536      dd               vfs_read                 411032546128  981310794      411032550680  4552          293           2573        8890        0.29                  \n191117      dd               vfs_read                 411032602702  56574          411032605663  2961          285           2397        5726        0.42                  \n199364      dd               vfs_read                 411032652150  49448          411032655372  3222          282           2499        6233        0.4                   \n256863      dd               vfs_read                 411033324366  672216         411035014934  1690568       2456          19464       78746       0.25                  \n259175      kworker/3:1H-kb  __pm_runtime_resume      411033363271  38905          411034184239  820968        173371        676401      1544084     0.44                  \n259256      kworker/3:1H-kb  __pm_runtime_resume      411033366884  3613           411034181988  815104        173144        674814      1532805     0.44                  \n433515      kworker/3:1H-kb  sdhci_pci_runtime_resum  411034083899  717015         411034180654  96755         658           6972        186013      0.04        jump      \n434406      kworker/3:1H-kb  __pm_runtime_resume      411034184429  100530         411034184544  115           13            101         222         0.45                  \n434468      kworker/3:1H-kb  mmc_blk_mq_issue_rq      411034185597  1168           411034195025  9428          117           1005        18042       0.06                  \n436485      swapper          mmc_blk_mq_complete      411035001225  815628         411035009951  8726          464           3630        16785       0.22        jump      \n437997      dd               vfs_read                 411035018460  17235          411035041818  23358         2194          17360       27335       0.64                  \n440326      kworker/3:1H-kb  __pm_runtime_resume      411035033461  15001          411035033692  231           13            124         444         0.28                  \n440367      kworker/3:1H-kb  __pm_runtime_resume      411035033929  468            411035034079  150           13            0           0           0.0                   \n440393      kworker/3:1H-kb  mmc_blk_mq_issue_rq      411035034183  254            411035038508  4325          95            727         1785        0.41                  \n441291      dd               vfs_read                 411035043009  8826           411035044052  1043          119           1169        2080        0.56                  \n441496      dd               vfs_read                 411035044594  1585           411035045478  884           119           1169        1722        0.68                  \n441701      dd               vfs_read                 411035045885  1291           411035343621  297736        3981          36177       30929       1.17                  \n445677      kworker/3:1H-kb  mmc_blk_mq_issue_rq      411035061376  15491          411035065210  3834          95            848         1079        0.79                  \n447604      swapper          mmc_blk_mq_complete      411035337501  276125         411035340344  2843          340           2692        5469        0.49        jump      \n448875      dd               vfs_read                 411035344722  7221           411035345661  939           119           1169        1846        0.63                  \n449080      dd               vfs_read                 411035346106  1384           411035347080  974           119           1169        1894        0.62                  \n449285      dd               vfs_read                 411035347486  1380           411035348326  840           119           1169        1636        0.71                  \n449490      dd               vfs_read                 411035348733  1247           411035349616  883           119           1169        1724        0.68                  \n449695      dd               vfs_read                 411035350151  1418           411035350869  718           119           1169        1402        0.83                  \n449900      dd               vfs_read                 411035351288  1137           411035352137  849           119           1169        1657        0.71                  \n450105      dd               vfs_read                 411035352538  1250           411035353358  820           119           1169        1601        0.73                  \n</code></pre> <p>Yes, that shows that nearly all the extra latency before the I/O is issued is due to runtime pm.</p> <p>More analysis would be needed to determine whether the rest of the 1.7 ms is due to the eMMC or interrupt latency.</p> <p>For now, we will just look at the time between the hardware interrupt, and the driver interrupt handler.  For this we need to know that the interrupt handler is called sdhci_irq and that it was running on CPU 1.</p> <p>Below we can see that the first interrupt at 411034993801 is between the first mmc_blk_mq_issue_rq (411034185597) and first mmc_blk_mq_complete (411035001225).  The previous hardware interrupt is 20 us earlier, which is a surprisingly long time, but still much less than the I/O time of 815us.</p> <pre><code>$ sqlite3 -column -header t4.db \\\n&gt; 'SELECT id,cpu,time,time - LAG (time,1,0) OVER (ORDER BY id) time_lag,symbol,sym_offset,to_symbol,to_sym_offset,branch_type_name FROM samples_view\n&gt; WHERE (cpu = 1) AND ( ( to_symbol = \"sdhci_irq\" AND to_sym_offset = 0 ) OR (branch_type_name = \"hardware interrupt\")) ;' | head -30\nid          cpu         time          time_lag      symbol                sym_offset  to_symbol             to_sym_offset  branch_type_name  \n----------  ----------  ------------  ------------  --------------------  ----------  --------------------  -------------  ------------------\n55161       1           407843243644  407843243644  tick_nohz_idle_enter  51          reschedule_interrupt  0              hardware interrupt\n63715       1           408067314572  224070928     mwait_idle            143         irq_entries_start     40             hardware interrupt\n72957       1           408347228661  279914089     mwait_idle            143         apic_timer_interrupt  0              hardware interrupt\n110047      1           409843244054  1496015393    __sched_text_start    643         reschedule_interrupt  0              hardware interrupt\n114067      1           410051312542  208068488     mwait_idle            143         irq_entries_start     40             hardware interrupt\n116528      1           410347228668  295916126     mwait_idle            143         apic_timer_interrupt  0              hardware interrupt\n436300      1           411034973294  687744626     mwait_idle            143         irq_entries_start     16             hardware interrupt\n436388      1           411034993801  20507         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n447419      1           411035311825  318024        mwait_idle            143         irq_entries_start     16             hardware interrupt\n447507      1           411035332130  20305         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n457368      1           411035685301  353171        mwait_idle            143         irq_entries_start     16             hardware interrupt\n457456      1           411035705179  19878         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n473827      1           411036260355  555176        mwait_idle            143         irq_entries_start     16             hardware interrupt\n473915      1           411036279988  19633         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n489031      1           411036835523  555535        mwait_idle            143         irq_entries_start     16             hardware interrupt\n489119      1           411036855487  19964         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n505392      1           411037410996  555509        mwait_idle            143         irq_entries_start     16             hardware interrupt\n505480      1           411037430723  19727         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n520611      1           411037986623  555900        mwait_idle            143         irq_entries_start     16             hardware interrupt\n520699      1           411038006568  19945         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n536927      1           411038562401  555833        mwait_idle            143         irq_entries_start     16             hardware interrupt\n537015      1           411038582223  19822         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n552098      1           411039137734  555511        mwait_idle            143         irq_entries_start     16             hardware interrupt\n552186      1           411039157598  19864         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n568254      1           411039712835  555237        mwait_idle            143         irq_entries_start     16             hardware interrupt\n568342      1           411039732767  19932         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n586569      1           411040288423  555656        mwait_idle            143         irq_entries_start     16             hardware interrupt\n586657      1           411040307873  19450         __x86_indirect_thunk  0           sdhci_irq             0              unconditional jump\n</code></pre> <p>We can look at the 20 us between the hardware interrupt and <code>sdhci_irq</code>.  It shows that there are 2 other interrupt handlers being serviced that consume most of that time: <code>idma64_irq</code> and <code>i801_isr</code></p> <pre><code>$ perf script -i t4 --itrace=b --time 411.034973294,411.034993801 -F-comm,-tid,-period,-cpu,-event,+flags,+callindent,+addr,-dso --ns -C 1 | \\\n&gt; grep -v \" jcc \" | \\\n&gt; awk -F: 'BEGIN {p=0} {ns=1000000000*$1;if (!p) p=ns;printf(\"%10.0f %s\\n\",ns-p,$0);p=ns}'\n         0   411.034973294:   hw int                  irq_entries_start            ffffffffa66db33f mwait_idle+0x8f =&gt; ffffffffa6800220 irq_entries_start+0x10\n         0   411.034973294:   jmp                                                  ffffffffa6800222 irq_entries_start+0x12 =&gt; ffffffffa6800a00 common_interrupt+0x0\n         0   411.034973294:   call                        interrupt_entry          ffffffffa6800a05 common_interrupt+0x5 =&gt; ffffffffa6800910 interrupt_entry+0x0\n        37   411.034973331:   return                      interrupt_entry          ffffffffa68009cf interrupt_entry+0xbf =&gt; ffffffffa6800a0a common_interrupt+0xa\n         0   411.034973331:   call                        do_IRQ                   ffffffffa6800a0a common_interrupt+0xa =&gt; ffffffffa68017e0 do_IRQ+0x0\n         0   411.034973331:   call                            irq_enter            ffffffffa68017fa do_IRQ+0x1a =&gt; ffffffffa5c6ddd0 irq_enter+0x0\n         0   411.034973331:   call                                rcu_irq_enter    ffffffffa5c6ddd0 irq_enter+0x0 =&gt; ffffffffa5cd81a0 rcu_irq_enter+0x0\n         0   411.034973331:   call                                    rcu_dynticks_eqs_exit                        ffffffffa5cd826e rcu_irq_enter+0xce =&gt; ffffffffa5cd21d0 rcu_dynticks_eqs_exit+0x0\n        80   411.034973411:   return                                  rcu_dynticks_eqs_exit                        ffffffffa5cd21f9 rcu_dynticks_eqs_exit+0x29 =&gt; ffffffffa5cd8273 rcu_irq_enter+0xd3\n         0   411.034973411:   jmp                                                                                  ffffffffa5cd8295 rcu_irq_enter+0xf5 =&gt; ffffffffa5cd8201 rcu_irq_enter+0x61\n         0   411.034973411:   return                              rcu_irq_enter                                    ffffffffa5cd821f rcu_irq_enter+0x7f =&gt; ffffffffa5c6ddd5 irq_enter+0x5\n         0   411.034973411:   call                                tick_irq_enter                                   ffffffffa5c6de09 irq_enter+0x39 =&gt; ffffffffa5cf2050 tick_irq_enter+0x0\n         0   411.034973411:   call                                    tick_check_oneshot_broadcast_this_cpu        ffffffffa5cf205c tick_irq_enter+0xc =&gt; ffffffffa5cf0ec0 tick_check_oneshot_broadcast_this_cpu+0x0\n        88   411.034973499:   return                                  tick_check_oneshot_broadcast_this_cpu        ffffffffa5cf0ee8 tick_check_oneshot_broadcast_this_cpu+0x28 =&gt; ffffffffa5cf2061 tick_irq_enter+0x11\n         0   411.034973499:   call                                    ktime_get                                    ffffffffa5cf2075 tick_irq_enter+0x25 =&gt; ffffffffa5ce46d0 ktime_get+0x0\n         0   411.034973499:   call                                        __x86_indirect_thunk_rax                 ffffffffa5ce4704 ktime_get+0x34 =&gt; ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0\n         4   411.034973503:   jmp                                                                                  ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0 =&gt; ffffffffa5c27580 read_tsc+0x0\n        21   411.034973524:   return                                      read_tsc                                 ffffffffa5c2758c read_tsc+0xc =&gt; ffffffffa5ce4709 ktime_get+0x39\n         0   411.034973524:   return                                  ktime_get                                    ffffffffa5ce4754 ktime_get+0x84 =&gt; ffffffffa5cf207a tick_irq_enter+0x2a\n         0   411.034973524:   call                                    update_ts_time_stats                         ffffffffa5cf20cc tick_irq_enter+0x7c =&gt; ffffffffa5cf1430 update_ts_time_stats+0x0\n         0   411.034973524:   call                                        nr_iowait_cpu                            ffffffffa5cf1479 update_ts_time_stats+0x49 =&gt; ffffffffa5c98170 nr_iowait_cpu+0x0\n         0   411.034973524:   return                                      nr_iowait_cpu                            ffffffffa5c98189 nr_iowait_cpu+0x19 =&gt; ffffffffa5cf147e update_ts_time_stats+0x4e\n        12   411.034973536:   jmp                                                                                  ffffffffa5cf1497 update_ts_time_stats+0x67 =&gt; ffffffffa5cf143f update_ts_time_stats+0xf\n         0   411.034973536:   return                                  update_ts_time_stats                         ffffffffa5cf1468 update_ts_time_stats+0x38 =&gt; ffffffffa5cf20d1 tick_irq_enter+0x81\n         0   411.034973536:   call                                    sched_clock_idle_wakeup_event                ffffffffa5cf20d5 tick_irq_enter+0x85 =&gt; ffffffffa5c9a220 sched_clock_idle_wakeup_event+0x0\n         0   411.034973536:   return                                  sched_clock_idle_wakeup_event                ffffffffa5c9a227 sched_clock_idle_wakeup_event+0x7 =&gt; ffffffffa5cf20da tick_irq_enter+0x8a\n         0   411.034973536:   jmp                                                                                  ffffffffa5cf20e2 tick_irq_enter+0x92 =&gt; ffffffffa5cf2083 tick_irq_enter+0x33\n        37   411.034973573:   return                              tick_irq_enter                                   ffffffffa5cf20b8 tick_irq_enter+0x68 =&gt; ffffffffa5c6de0e irq_enter+0x3e\n         0   411.034973573:   call                                _local_bh_enable                                 ffffffffa5c6de0e irq_enter+0x3e =&gt; ffffffffa5c6d760 _local_bh_enable+0x0\n         0   411.034973573:   return                              _local_bh_enable                                 ffffffffa5c6d779 _local_bh_enable+0x19 =&gt; ffffffffa5c6de13 irq_enter+0x43\n         0   411.034973573:   jmp                                                                                  ffffffffa5c6de13 irq_enter+0x43 =&gt; ffffffffa5c6ddf2 irq_enter+0x22\n         0   411.034973573:   return                          irq_enter                                            ffffffffa5c6ddfd irq_enter+0x2d =&gt; ffffffffa68017ff do_IRQ+0x1f\n         0   411.034973573:   call                            __x86_indirect_thunk_rax                             ffffffffa680181c do_IRQ+0x3c =&gt; ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0\n       193   411.034973766:   jmp                                                                                  ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0 =&gt; ffffffffa5cc6cf0 handle_fasteoi_irq+0x0\n         0   411.034973766:   call                                _raw_spin_lock                                   ffffffffa5cc6d00 handle_fasteoi_irq+0x10 =&gt; ffffffffa66dbbd0 _raw_spin_lock+0x0\n       183   411.034973949:   return                              _raw_spin_lock                                   ffffffffa66dbbdd _raw_spin_lock+0xd =&gt; ffffffffa5cc6d05 handle_fasteoi_irq+0x15\n         0   411.034973949:   call                                irq_may_run                                      ffffffffa5cc6d08 handle_fasteoi_irq+0x18 =&gt; ffffffffa5cc6a70 irq_may_run+0x0\n         0   411.034973949:   return                              irq_may_run                                      ffffffffa5cc6a81 irq_may_run+0x11 =&gt; ffffffffa5cc6d0d handle_fasteoi_irq+0x1d\n        16   411.034973965:   call                                handle_irq_event                                 ffffffffa5cc6d5c handle_fasteoi_irq+0x6c =&gt; ffffffffa5cc3090 handle_irq_event+0x0\n         0   411.034973965:   call                                    handle_irq_event_percpu                      ffffffffa5cc30ad handle_irq_event+0x1d =&gt; ffffffffa5cc3020 handle_irq_event_percpu+0x0\n         0   411.034973965:   call                                        __handle_irq_event_percpu                ffffffffa5cc3046 handle_irq_event_percpu+0x26 =&gt; ffffffffa5cc2ea0 __handle_irq_event_percpu+0x0\n         0   411.034973965:   call                                            __x86_indirect_thunk_rax             ffffffffa5cc2ed6 __handle_irq_event_percpu+0x36 =&gt; ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0\n       158   411.034974123:   jmp                                                                                  ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0 =&gt; ffffffffa60d0270 idma64_irq+0x0\n      8285   411.034982408:   call                                                _raw_spin_lock                   ffffffffa60d0339 idma64_irq+0xc9 =&gt; ffffffffa66dbbd0 _raw_spin_lock+0x0\n         0   411.034982408:   return                                              _raw_spin_lock                   ffffffffa66dbbdd _raw_spin_lock+0xd =&gt; ffffffffa60d033e idma64_irq+0xce\n         0   411.034982408:   call                                                _raw_spin_lock                   ffffffffa60d0339 idma64_irq+0xc9 =&gt; ffffffffa66dbbd0 _raw_spin_lock+0x0\n      3358   411.034985766:   return                                              _raw_spin_lock                   ffffffffa66dbbdd _raw_spin_lock+0xd =&gt; ffffffffa60d033e idma64_irq+0xce\n         0   411.034985766:   return                                          idma64_irq                           ffffffffa60d02d4 idma64_irq+0x64 =&gt; ffffffffa5cc2edb __handle_irq_event_percpu+0x3b\n       112   411.034985878:   call                                            __x86_indirect_thunk_rax             ffffffffa5cc2ed6 __handle_irq_event_percpu+0x36 =&gt; ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0\n         1   411.034985879:   jmp                                                                                  ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0 =&gt; ffffffffa6377370 i801_isr+0x0\n         0   411.034985879:   call                                                pci_read_config_word             ffffffffa637739f i801_isr+0x2f =&gt; ffffffffa6036a70 pci_read_config_word+0x0\n       191   411.034986070:   jmp                                                                                  ffffffffa6036a87 pci_read_config_word+0x17 =&gt; ffffffffa6035cb0 pci_bus_read_config_word+0x0\n         0   411.034986070:   call                                                    __x86_indirect_thunk_rax     ffffffffa6035cea pci_bus_read_config_word+0x3a =&gt; ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0\n        21   411.034986091:   jmp                                                                                  ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0 =&gt; ffffffffa6454cc0 pci_read+0x0\n         0   411.034986091:   jmp                                                                                  ffffffffa6454cde pci_read+0x1e =&gt; ffffffffa6454c80 raw_pci_read+0x0\n         2   411.034986093:   jmp                                                                                  ffffffffa6454c9b raw_pci_read+0x1b =&gt; ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0\n         2   411.034986095:   jmp                                                                                  ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0 =&gt; ffffffffa6452220 pci_conf1_read+0x0\n         0   411.034986095:   call                                                        _raw_spin_lock_irqsave   ffffffffa645226d pci_conf1_read+0x4d =&gt; ffffffffa66dbb40 _raw_spin_lock_irqsave+0x0\n         0   411.034986095:   return                                                      _raw_spin_lock_irqsave   ffffffffa66dbb55 _raw_spin_lock_irqsave+0x15 =&gt; ffffffffa6452272 pci_conf1_read+0x52\n       191   411.034986286:   jmp                                                                                  ffffffffa64522fa pci_conf1_read+0xda =&gt; ffffffffa64522c5 pci_conf1_read+0xa5\n         0   411.034986286:   call                                                        __lock_text_start        ffffffffa64522cc pci_conf1_read+0xac =&gt; ffffffffa66db980 __lock_text_start+0x0\n         0   411.034986286:   return                                                      __lock_text_start        ffffffffa66db985 __lock_text_start+0x5 =&gt; ffffffffa64522d1 pci_conf1_read+0xb1\n         0   411.034986286:   return                                                  pci_conf1_read               ffffffffa64522db pci_conf1_read+0xbb =&gt; ffffffffa6035cef pci_bus_read_config_word+0x3f\n         0   411.034986286:   return                                              pci_bus_read_config_word         ffffffffa6035d0b pci_bus_read_config_word+0x5b =&gt; ffffffffa63773a4 i801_isr+0x34\n      7363   411.034993649:   return                                          i801_isr                             ffffffffa63773f5 i801_isr+0x85 =&gt; ffffffffa5cc2edb __handle_irq_event_percpu+0x3b\n         0   411.034993649:   call                                            __x86_indirect_thunk_rax             ffffffffa5cc2ed6 __handle_irq_event_percpu+0x36 =&gt; ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0\n       152   411.034993801:   jmp                                                                                  ffffffffa6a00fc0 __x86_indirect_thunk_rax+0x0 =&gt; ffffffffa63e14a0 sdhci_irq+0x0\n         0   411.034993801:   call                                                _raw_spin_lock                   ffffffffa63e14da sdhci_irq+0x3a =&gt; ffffffffa66dbbd0 _raw_spin_lock+0x0\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-looking-at-intel-pt-trace-packets","title":"Example: Looking at Intel PT trace packets","text":"<p>There are 2 ways to see the trace packets.  To begin, for this example, we can make a trivial trace:</p> <pre><code>$ perf record -e intel_pt//u uname\nLinux\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.026 MB perf.data ]\n</code></pre> <p>The first way is to use the <code>perf script</code> option to display a dump of trace data (<code>-D</code> or <code>--dump-raw-trace</code>).  For example, to show the first 25 lines of PERF_RECORD_AUXTRACE* events:</p> <pre><code>$ perf script -D | grep -A25 PERF_RECORD_AUXTRACE \n0 0 0x2e0 [0x98]: PERF_RECORD_AUXTRACE_INFO type: 1\n  PMU Type            8\n  Time Shift          31\n  Time Muliplier      791841207\n  Time Zero           18446744057222810652\n  Cap Time Zero       1\n  TSC bit             0x400\n  NoRETComp bit       0x800\n  Have sched_switch   3\n  Snapshot mode       0\n  Per-cpu maps        1\n  MTC bit             0x200\n  TSC:CTC numerator   226\n  TSC:CTC denominator 2\n  CYC bit             0x2\n  Max non-turbo ratio 27\n  Filter string len.  0\n  Filter string       \n\n0x378 [0x28]: event: 73\n.\n. ... raw event: size 40 bytes\n.  0000:  49 00 00 00 00 00 28 00 01 00 00 00 00 00 00 00  I.....(.........\n.  0010:  08 38 00 00 00 00 00 00 00 00 00 00 00 00 00 00  .8..............\n.  0020:  00 00 00 00 00 00 00 00                          ........        \n\n--\n0 0 0x1568 [0x30]: PERF_RECORD_AUXTRACE size: 0x5390  offset: 0  ref: 0x51f87fa233f  idx: 2  tid: 14344  cpu: 2\n.\n. ... Intel Processor Trace data: size 21392 bytes\n.  00000000:  02 82 02 82 02 82 02 82 02 82 02 82 02 82 02 82 PSB\n.  00000010:  00 00 00 00 00 00                               PAD\n.  00000016:  19 1d fe e8 87 1f 05 00                         TSC 0x51f87e8fe1d\n.  0000001e:  00 00 00 00 00 00 00 00                         PAD\n.  00000026:  02 73 d9 7e 00 54 00 00                         TMA CTC 0x7ed9 FC 0x54\n.  0000002e:  00 00                                           PAD\n.  00000030:  02 03 2a 00                                     CBR 0x2a\n.  00000034:  02 23                                           PSBEND\n.  00000036:  59 dc                                           MTC 0xdc\n.  00000038:  59 dd                                           MTC 0xdd\n.  0000003a:  59 de                                           MTC 0xde\n.  0000003c:  59 df                                           MTC 0xdf\n.  0000003e:  59 e0                                           MTC 0xe0\n.  00000040:  59 e1                                           MTC 0xe1\n.  00000042:  59 e2                                           MTC 0xe2\n.  00000044:  59 e3                                           MTC 0xe3\n.  00000046:  59 e4                                           MTC 0xe4\n.  00000048:  59 e5                                           MTC 0xe5\n.  0000004a:  59 e6                                           MTC 0xe6\n.  0000004c:  59 e7                                           MTC 0xe7\n.  0000004e:  59 e8                                           MTC 0xe8\n.  00000050:  59 e9                                           MTC 0xe9\n.  00000052:  59 ea                                           MTC 0xea\n</code></pre> <p>The second way is to use <code>perf script</code> option to create a decoder debug log (<code>--itrace=d</code>).  This will create a file named <code>intel_pt.log</code> (beware it will overwrite any previous file)</p> <pre><code>$ perf script --itrace=d\n$ cat intel_pt.log | head -60\nTSC frequency 2712013000\nMaximum non-turbo ratio 27\nevent 17: cpu 0 time 0 tsc 0 PERF_RECORD_KSYMBOL addr ffffffffc0374f16 len 61 type 1 flags 0x0 name bpf_prog_6deef7357e7b4530\nevent 18: cpu 0 time 0 tsc 0 PERF_RECORD_BPF_EVENT type 1, flags 0, id 22\nevent 17: cpu 0 time 0 tsc 0 PERF_RECORD_KSYMBOL addr ffffffffc0384224 len 61 type 1 flags 0x0 name bpf_prog_6deef7357e7b4530\nevent 18: cpu 0 time 0 tsc 0 PERF_RECORD_BPF_EVENT type 1, flags 0, id 23\nevent 17: cpu 0 time 0 tsc 0 PERF_RECORD_KSYMBOL addr ffffffffc03865f9 len 61 type 1 flags 0x0 name bpf_prog_6deef7357e7b4530\nevent 18: cpu 0 time 0 tsc 0 PERF_RECORD_BPF_EVENT type 1, flags 0, id 24\nevent 17: cpu 0 time 0 tsc 0 PERF_RECORD_KSYMBOL addr ffffffffc0440ba9 len 61 type 1 flags 0x0 name bpf_prog_6deef7357e7b4530\nevent 18: cpu 0 time 0 tsc 0 PERF_RECORD_BPF_EVENT type 1, flags 0, id 25\nevent 17: cpu 0 time 0 tsc 0 PERF_RECORD_KSYMBOL addr ffffffffc045239d len 61 type 1 flags 0x0 name bpf_prog_6deef7357e7b4530\nevent 18: cpu 0 time 0 tsc 0 PERF_RECORD_BPF_EVENT type 1, flags 0, id 26\nevent 17: cpu 0 time 0 tsc 0 PERF_RECORD_KSYMBOL addr ffffffffc0454f83 len 61 type 1 flags 0x0 name bpf_prog_6deef7357e7b4530\nevent 18: cpu 0 time 0 tsc 0 PERF_RECORD_BPF_EVENT type 1, flags 0, id 27\nevent 17: cpu 0 time 0 tsc 0 PERF_RECORD_KSYMBOL addr ffffffffc068eae8 len 61 type 1 flags 0x0 name bpf_prog_6deef7357e7b4530\nevent 18: cpu 0 time 0 tsc 0 PERF_RECORD_BPF_EVENT type 1, flags 0, id 28\nevent 17: cpu 0 time 0 tsc 0 PERF_RECORD_KSYMBOL addr ffffffffc06901ce len 61 type 1 flags 0x0 name bpf_prog_6deef7357e7b4530\nevent 18: cpu 0 time 0 tsc 0 PERF_RECORD_BPF_EVENT type 1, flags 0, id 29\nevent 19: cpu 0 time 0 tsc 0 PERF_RECORD_CGROUP cgroup: 4294967297 /\nevent 3: cpu 0 time 0 tsc 0 PERF_RECORD_COMM: perf:14344/14344\ntimestamp: mtc_shift 3\ntimestamp: tsc_ctc_ratio_n 226\ntimestamp: tsc_ctc_ratio_d 2\ntimestamp: tsc_ctc_mult 113\ntimestamp: tsc_slip 0x10000\nqueue 2 getting timestamp\nqueue 2 decoding cpu 2 pid -1 tid 14344\nScanning for PSB\nGetting more data\nReference timestamp 0x51f87fa233f\nScanning for PSB\n  00000000:  02 82 02 82 02 82 02 82 02 82 02 82 02 82 02 82 PSB\n  00000010:  00 00 00 00 00 00                               PAD\n  00000016:  19 1d fe e8 87 1f 05 00                         TSC 0x51f87e8fe1d\nSetting timestamp to 0x51f87e8fe1d\n  0000001e:  00 00 00 00 00 00 00 00                         PAD\n  00000026:  02 73 d9 7e 00 54 00 00                         TMA CTC 0x7ed9 FC 0x54\nCTC timestamp 0x51f87e8fd58 last MTC 0xdb  CTC rem 0x1\n  0000002e:  00 00                                           PAD\n  00000030:  02 03 2a 00                                     CBR 0x2a\n  00000034:  02 23                                           PSBEND\nScanning for full IP\n  00000036:  59 dc                                           MTC 0xdc\nSetting timestamp to 0x51f87e900e0\n  00000038:  59 dd                                           MTC 0xdd\nSetting timestamp to 0x51f87e90468\n  0000003a:  59 de                                           MTC 0xde\nSetting timestamp to 0x51f87e907f0\n  0000003c:  59 df                                           MTC 0xdf\nSetting timestamp to 0x51f87e90b78\n  0000003e:  59 e0                                           MTC 0xe0\nSetting timestamp to 0x51f87e90f00\n  00000040:  59 e1                                           MTC 0xe1\nSetting timestamp to 0x51f87e91288\n  00000042:  59 e2                                           MTC 0xe2\nSetting timestamp to 0x51f87e91610\n  00000044:  59 e3                                           MTC 0xe3\nSetting timestamp to 0x51f87e91998\n  00000046:  59 e4                                           MTC 0xe4\nSetting timestamp to 0x51f87e91d20\n</code></pre> <p>The debug log can be very big, but it can be reduced in size by setting time ranges (<code>--time</code> option) or specifying CPUs (<code>--cpu</code>).  When tracing with per-cpu contexts (which is the default), the debug log is much easier to understand if it is limited to one CPU.  The example below shows how a 2G log can be trimmed to 681K when reduced to one CPU and a 1 ms time range, and with sideband events stripped by <code>grep -v</code>.</p> <pre><code>$ sudo ~/bin/perf record -a -e intel_pt//u -- sleep 1\n[ perf record: Woken up 3 times to write data ]\n[ perf record: Captured and wrote 12.302 MB perf.data ]\n$ sudo chgrp perf_users perf.data\n$ sudo chmod g+r perf.data\n$ perf script --itrace=d\n$ ls -lh intel_pt.log\n-rw-rw-r-- 1 user user 2.0G Jun 16 10:22 intel_pt.log\n$ perf script --itrace=d --cpu 0\n$ ls -lh intel_pt.log\n-rw-rw-r-- 1 user user 109M Jun 16 10:22 intel_pt.log\n$ perf script --itrace=i10ms\n        kwin_x11  1042 [007]  4760.598466:     922319 instructions:u:      7f54fdd1b090 QTextEngine::itemize+0x690 (/usr/lib/x86_64-linux-gnu/libQt5Gui.so.5.12.8)\n         konsole 13784 [002]  4760.617025:    4048473 instructions:u:      7f34f0282003 QString::reallocData+0x93 (/usr/lib/x86_64-linux-gnu/libQt5Core.so.5.12.8)\n            Xorg   875 [003]  4760.796426:   23859371 instructions:u:      562d6a00ab7b [unknown] (/usr/lib/xorg/Xorg)\n     plasmashell  1048 [001]  4761.155230:   15828349 instructions:u:      7f2da6ead8bb __powf_fma+0x4b (/usr/lib/x86_64-linux-gnu/libm-2.31.so)\n        kwin_x11  1042 [002]  4761.248024:   16194616 instructions:u:      7f54e56673e3 [unknown] (/usr/lib/x86_64-linux-gnu/dri/iris_dri.so)\n$ perf script --itrace=d --cpu 0 --time 4760.598,4760.599\n$ ls -lh intel_pt.log\n-rw-rw-r-- 1 user user 4.7M Jun 16 10:27 intel_pt.log\n$ grep -v \"PERF_RECORD\\|context_switch\" intel_pt.log &gt; intel_pt.log-no-sideband\n$ ls -lh intel_pt.log-no-sideband\n-rw-rw-r-- 1 user user 681K Jun 16 10:27 intel_pt.log-no-sideband\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-unknown-symbols","title":"Example: Unknown symbols","text":"<p>The current version of <code>perf</code> (v5.8-rc1) shows unknown symbols:</p> <pre><code>$ perf record -e intel_pt//u uname\nLinux\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.027 MB perf.data ]\n$ perf script --itrace=b -Fip,sym,dso | grep unknown | sort -u\n                0 [unknown] ([unknown])\n     55e2455b7304 [unknown] (/usr/bin/uname)\n     55e2455b7364 [unknown] (/usr/bin/uname)\n     55e2455b7374 [unknown] (/usr/bin/uname)\n     55e2455b7384 [unknown] (/usr/bin/uname)\n     55e2455b7394 [unknown] (/usr/bin/uname)\n     55e2455b73e4 [unknown] (/usr/bin/uname)\n     55e2455b7404 [unknown] (/usr/bin/uname)\n     55e2455b7414 [unknown] (/usr/bin/uname)\n     55e2455b7424 [unknown] (/usr/bin/uname)\n     55e2455b7464 [unknown] (/usr/bin/uname)\n     55e2455b74a4 [unknown] (/usr/bin/uname)\n     55e2455b74d4 [unknown] (/usr/bin/uname)\n     55e2455b74f4 [unknown] (/usr/bin/uname)\n     55e2455b7514 [unknown] (/usr/bin/uname)\n     55e2455b7564 [unknown] (/usr/bin/uname)\n     7f4661556006 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556314 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556334 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556394 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f46615563b4 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556424 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556454 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556464 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556474 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f46615564d4 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556514 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556574 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f4661556584 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f46615565a4 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f46615565e4 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n     7f466173f084 [unknown] (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n     7f466173f094 [unknown] (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n     7f466173f0a4 [unknown] (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n     7f466173f0c4 [unknown] (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n$ perf script --itrace=b -Faddr,sym,dso | grep unknown | sort -u\n =&gt;                0 [unknown] ([unknown])\n =&gt;     55e2455b7300 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7360 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7370 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7380 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7390 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b73e0 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7400 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7410 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7420 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7460 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b74a0 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b74d0 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b74f0 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7510 [unknown] (/usr/bin/uname)\n =&gt;     55e2455b7560 [unknown] (/usr/bin/uname)\n =&gt;     7f4661556000 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556310 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556330 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556390 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f46615563b0 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556420 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556450 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556460 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556470 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f46615564d0 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556510 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556570 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f4661556580 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f46615565a0 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f46615565e0 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n =&gt;     7f466173f080 [unknown] (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n =&gt;     7f466173f090 [unknown] (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n =&gt;     7f466173f0a0 [unknown] (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n =&gt;     7f466173f0c0 [unknown] (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n</code></pre> <p>To find out what they are we need to look at MMAP events:</p> <pre><code>$ perf script --no-itrace --show-mmap-events\n           uname  2385 [007]   291.223573: PERF_RECORD_MMAP2 2385/2385: [0x55e2455b7000(0x4000) @ 0x2000 08:02 4326740 2619663641]: r-xp /usr/bin/uname\n           uname  2385 [007]   291.223584: PERF_RECORD_MMAP2 2385/2385: [0x7f466173f000(0x23000) @ 0x1000 08:02 4332741 3243916115]: r-xp /usr/lib/x86_64-linux-gnu/ld-2.31.so\n           uname  2385 [007]   291.223591: PERF_RECORD_MMAP2 2385/2385: [0x7ffd1ef71000(0x1000) @ 0 00:00 0 0]: r-xp [vdso]\n           uname  2385 [007]   291.223674: PERF_RECORD_MMAP2 2385/2385: [0x7f4661556000(0x178000) @ 0x25000 08:02 4333341 2513837035]: r-xp /usr/lib/x86_64-linux-gnu/libc-2.31.so\n</code></pre> <p>The details of each MMAP event for a process (PID 2385 in this case) is in the form <code>[start(size) @ offset device inode generation]: protection pathname</code>.  To calculate a file offset from an address:</p> <pre><code>file_offset = address - start + offset\n</code></pre> <p>Unknown addresses in the range from 0x55e2455b7300 to 0x55e2455b7564 are from /usr/bin/uname, from file offset 0x2300 to 0x2564.  We can look at the section headers to find out more:</p> <pre><code>$ readelf -S -W /usr/bin/uname \nThere are 30 section headers, starting at offset 0x91f8:\n\nSection Headers:\n  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0\n  [ 1] .interp           PROGBITS        0000000000000318 000318 00001c 00   A  0   0  1\n  [ 2] .note.gnu.property NOTE            0000000000000338 000338 000020 00   A  0   0  8\n  [ 3] .note.gnu.build-id NOTE            0000000000000358 000358 000024 00   A  0   0  4\n  [ 4] .note.ABI-tag     NOTE            000000000000037c 00037c 000020 00   A  0   0  4\n  [ 5] .gnu.hash         GNU_HASH        00000000000003a0 0003a0 0000a8 00   A  6   0  8\n  [ 6] .dynsym           DYNSYM          0000000000000448 000448 000648 18   A  7   1  8\n  [ 7] .dynstr           STRTAB          0000000000000a90 000a90 00033a 00   A  0   0  1\n  [ 8] .gnu.version      VERSYM          0000000000000dca 000dca 000086 02   A  6   0  2\n  [ 9] .gnu.version_r    VERNEED         0000000000000e50 000e50 000060 00   A  7   1  8\n  [10] .rela.dyn         RELA            0000000000000eb0 000eb0 0003d8 18   A  6   0  8\n  [11] .rela.plt         RELA            0000000000001288 001288 000438 18  AI  6  25  8\n  [12] .init             PROGBITS        0000000000002000 002000 00001b 00  AX  0   0  4\n  [13] .plt              PROGBITS        0000000000002020 002020 0002e0 10  AX  0   0 16\n  [14] .plt.got          PROGBITS        0000000000002300 002300 000010 10  AX  0   0 16\n  [15] .plt.sec          PROGBITS        0000000000002310 002310 0002d0 10  AX  0   0 16\n  [16] .text             PROGBITS        00000000000025e0 0025e0 003492 00  AX  0   0 16\n  [17] .fini             PROGBITS        0000000000005a74 005a74 00000d 00  AX  0   0  4\n  [18] .rodata           PROGBITS        0000000000006000 006000 00114c 00   A  0   0 32\n  [19] .eh_frame_hdr     PROGBITS        000000000000714c 00714c 00028c 00   A  0   0  4\n  [20] .eh_frame         PROGBITS        00000000000073d8 0073d8 000be8 00   A  0   0  8\n  [21] .init_array       INIT_ARRAY      00000000000099d0 0089d0 000008 08  WA  0   0  8\n  [22] .fini_array       FINI_ARRAY      00000000000099d8 0089d8 000008 08  WA  0   0  8\n  [23] .data.rel.ro      PROGBITS        00000000000099e0 0089e0 000278 00  WA  0   0 32\n  [24] .dynamic          DYNAMIC         0000000000009c58 008c58 0001f0 10  WA  7   0  8\n  [25] .got              PROGBITS        0000000000009e48 008e48 0001a8 08  WA  0   0  8\n  [26] .data             PROGBITS        000000000000a000 009000 0000a0 00  WA  0   0 32\n  [27] .bss              NOBITS          000000000000a0a0 0090a0 000198 00  WA  0   0 32\n  [28] .gnu_debuglink    PROGBITS        0000000000000000 0090a0 000034 00      0   0  4\n  [29] .shstrtab         STRTAB          0000000000000000 0090d4 00011d 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  l (large), p (processor specific)\n</code></pre> <p>We can see the unknown symbols are from the .plt.got and .plt.sec sections.  If we were to look also at /usr/lib/x86_64-linux-gnu/libc-2.31.so and /usr/lib/x86_64-linux-gnu/ld-2.31.so, we would see the same thing.  That is, the unknown symbols are from the .plt, .plt.got or .plt.sec sections of those files.  <code>perf</code> has a function named dso__synthesize_plt_symbols() to get PLT symbols, but it gets it wrong.</p> <p>BFD also provides a function, named bfd_get_synthetic_symtab(), to get PLT symbols.  It is used by <code>objdump</code> when disassembling. Here are the PLT symbols from /usr/bin/uname, /usr/lib/x86_64-linux-gnu/ld-2.31.so and /usr/lib/x86_64-linux-gnu/libc.so.6:</p> <pre><code>$ objdump -d /usr/bin/uname -j .plt -j .plt.got -j .plt.sec | grep ^0\n0000000000002020 &lt;.plt&gt;:\n0000000000002300 &lt;__cxa_finalize@plt&gt;:\n0000000000002310 &lt;free@plt&gt;:\n0000000000002320 &lt;abort@plt&gt;:\n0000000000002330 &lt;__errno_location@plt&gt;:\n0000000000002340 &lt;strncmp@plt&gt;:\n0000000000002350 &lt;_exit@plt&gt;:\n0000000000002360 &lt;__fpending@plt&gt;:\n0000000000002370 &lt;textdomain@plt&gt;:\n0000000000002380 &lt;fclose@plt&gt;:\n0000000000002390 &lt;bindtextdomain@plt&gt;:\n00000000000023a0 &lt;dcgettext@plt&gt;:\n00000000000023b0 &lt;__ctype_get_mb_cur_max@plt&gt;:\n00000000000023c0 &lt;strlen@plt&gt;:\n00000000000023d0 &lt;__stack_chk_fail@plt&gt;:\n00000000000023e0 &lt;getopt_long@plt&gt;:\n00000000000023f0 &lt;mbrtowc@plt&gt;:\n0000000000002400 &lt;__overflow@plt&gt;:\n0000000000002410 &lt;strrchr@plt&gt;:\n0000000000002420 &lt;uname@plt&gt;:\n0000000000002430 &lt;lseek@plt&gt;:\n0000000000002440 &lt;memset@plt&gt;:\n0000000000002450 &lt;memcmp@plt&gt;:\n0000000000002460 &lt;fputs_unlocked@plt&gt;:\n0000000000002470 &lt;calloc@plt&gt;:\n0000000000002480 &lt;strcmp@plt&gt;:\n0000000000002490 &lt;memcpy@plt&gt;:\n00000000000024a0 &lt;fileno@plt&gt;:\n00000000000024b0 &lt;fgets_unlocked@plt&gt;:\n00000000000024c0 &lt;malloc@plt&gt;:\n00000000000024d0 &lt;fflush@plt&gt;:\n00000000000024e0 &lt;nl_langinfo@plt&gt;:\n00000000000024f0 &lt;__freading@plt&gt;:\n0000000000002500 &lt;realloc@plt&gt;:\n0000000000002510 &lt;setlocale@plt&gt;:\n0000000000002520 &lt;__printf_chk@plt&gt;:\n0000000000002530 &lt;error@plt&gt;:\n0000000000002540 &lt;fseeko@plt&gt;:\n0000000000002550 &lt;fopen@plt&gt;:\n0000000000002560 &lt;__cxa_atexit@plt&gt;:\n0000000000002570 &lt;exit@plt&gt;:\n0000000000002580 &lt;fwrite@plt&gt;:\n0000000000002590 &lt;__fprintf_chk@plt&gt;:\n00000000000025a0 &lt;mbsinit@plt&gt;:\n00000000000025b0 &lt;iswprint@plt&gt;:\n00000000000025c0 &lt;strstr@plt&gt;:\n00000000000025d0 &lt;__ctype_b_loc@plt&gt;:\n$ objdump -d /usr/lib/x86_64-linux-gnu/ld-2.31.so -j .plt -j .plt.got -j .plt.sec | grep ^0\n0000000000001000 &lt;.plt&gt;:\n0000000000001080 &lt;free@plt&gt;:\n0000000000001090 &lt;_dl_catch_exception@plt&gt;:\n00000000000010a0 &lt;malloc@plt&gt;:\n00000000000010b0 &lt;_dl_signal_exception@plt&gt;:\n00000000000010c0 &lt;calloc@plt&gt;:\n00000000000010d0 &lt;realloc@plt&gt;:\n00000000000010e0 &lt;_dl_signal_error@plt&gt;:\n00000000000010f0 &lt;_dl_catch_error@plt&gt;:\n$ objdump -d /usr/lib/x86_64-linux-gnu/libc.so.6 -j .plt -j .plt.got -j .plt.sec | grep ^0\n0000000000025000 &lt;.plt&gt;:\n0000000000025300 &lt;__libpthread_freeres@plt&gt;:\n0000000000025310 &lt;malloc@plt&gt;:\n0000000000025320 &lt;__libdl_freeres@plt&gt;:\n0000000000025330 &lt;free@plt&gt;:\n0000000000025340 &lt;*ABS*+0xa3600@plt&gt;:\n0000000000025350 &lt;*ABS*+0xa27f0@plt&gt;:\n0000000000025360 &lt;*ABS*+0xbf960@plt&gt;:\n0000000000025370 &lt;realloc@plt&gt;:\n0000000000025380 &lt;*ABS*+0xa3a20@plt&gt;:\n0000000000025390 &lt;*ABS*+0xa4e10@plt&gt;:\n00000000000253a0 &lt;*ABS*+0xbfea0@plt&gt;:\n00000000000253b0 &lt;*ABS*+0xa3870@plt&gt;:\n00000000000253c0 &lt;__tls_get_addr@plt&gt;:\n00000000000253d0 &lt;*ABS*+0xa38d0@plt&gt;:\n00000000000253e0 &lt;*ABS*+0xa2c60@plt&gt;:\n00000000000253f0 &lt;*ABS*+0xbfab0@plt&gt;:\n0000000000025400 &lt;memalign@plt&gt;:\n0000000000025410 &lt;_dl_exception_create@plt&gt;:\n0000000000025420 &lt;*ABS*+0xa3550@plt&gt;:\n0000000000025430 &lt;*ABS*+0xa39d0@plt&gt;:\n0000000000025440 &lt;*ABS*+0xabd20@plt&gt;:\n0000000000025450 &lt;__tunable_get_val@plt&gt;:\n0000000000025460 &lt;*ABS*+0xa27b0@plt&gt;:\n0000000000025470 &lt;*ABS*+0xa2280@plt&gt;:\n0000000000025480 &lt;*ABS*+0xa29a0@plt&gt;:\n0000000000025490 &lt;*ABS*+0xbf9e0@plt&gt;:\n00000000000254a0 &lt;*ABS*+0xbff30@plt&gt;:\n00000000000254b0 &lt;*ABS*+0xbff30@plt&gt;:\n00000000000254c0 &lt;*ABS*+0xc10d0@plt&gt;:\n00000000000254d0 &lt;*ABS*+0xa3ad0@plt&gt;:\n00000000000254e0 &lt;*ABS*+0xa2350@plt&gt;:\n00000000000254f0 &lt;*ABS*+0xbfe60@plt&gt;:\n0000000000025500 &lt;*ABS*+0xa3980@plt&gt;:\n0000000000025510 &lt;_dl_find_dso_for_object@plt&gt;:\n0000000000025520 &lt;*ABS*+0xa23b0@plt&gt;:\n0000000000025530 &lt;*ABS*+0xa27f0@plt&gt;:\n0000000000025540 &lt;*ABS*+0xbf960@plt&gt;:\n0000000000025550 &lt;calloc@plt&gt;:\n0000000000025560 &lt;*ABS*+0xa36c0@plt&gt;:\n0000000000025570 &lt;*ABS*+0xa22d0@plt&gt;:\n0000000000025580 &lt;*ABS*+0xa2890@plt&gt;:\n0000000000025590 &lt;*ABS*+0xa3590@plt&gt;:\n00000000000255a0 &lt;*ABS*+0xa3760@plt&gt;:\n00000000000255b0 &lt;*ABS*+0xbf9a0@plt&gt;:\n00000000000255c0 &lt;*ABS*+0xbfe60@plt&gt;:\n00000000000255d0 &lt;*ABS*+0xa4dd0@plt&gt;:\n00000000000255e0 &lt;*ABS*+0xa2960@plt&gt;:\n00000000000255f0 &lt;*ABS*+0xa2220@plt&gt;:\n0000000000025600 &lt;*ABS*+0xa3930@plt&gt;:\n0000000000025610 &lt;*ABS*+0xa2900@plt&gt;:\n0000000000025620 &lt;*ABS*+0xa3600@plt&gt;:\n</code></pre> <p>Many of the PLT symbol names in libc are not particularly meaningful, and there are also some missing from 0x7f4661556000 to 0x7f46615562ff (file offset 0x25000 to 0x25300). However, with a branch trace, we can see where they are going anyway:</p> <pre><code>$ perf script --itrace=be -F+flags,+addr,-period,-event --ns | grep -B 1 -A 2 7f4661556[012] \n           uname  2385 [007]   291.223778433:   call                     7f46616932ab _dl_addr+0x3b (/usr/lib/x86_64-linux-gnu/libc-2.31.so) =&gt;     7f4661556510 _dl_find_dso_for_object@plt+0x0 (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n           uname  2385 [007]   291.223778433:   jmp                      7f4661556514 _dl_find_dso_for_object@plt+0x4 (/usr/lib/x86_64-linux-gnu/libc-2.31.so) =&gt;     7f46615561e0 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n           uname  2385 [007]   291.223778433:   jmp                      7f46615561e9 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so) =&gt;     7f4661556000 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n           uname  2385 [007]   291.223778766:   jmp                      7f4661556006 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so) =&gt;     7f4661756bb0 _dl_runtime_resolve_xsavec+0x0 (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n           uname  2385 [007]   291.223778766:   call                     7f4661756c29 _dl_runtime_resolve_xsavec+0x79 (/usr/lib/x86_64-linux-gnu/ld-2.31.so) =&gt;     7f466174f0b0 _dl_fixup+0x0 (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n           uname  2385 [007]   291.223778766:   call                     7f466174f182 _dl_fixup+0xd2 (/usr/lib/x86_64-linux-gnu/ld-2.31.so) =&gt;     7f466174a0d0 _dl_lookup_symbol_x+0x0 (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n--\n           uname  2385 [007]   291.223797766:   call                     7f46615cd275 ptmalloc_init.part.0+0xa5 (/usr/lib/x86_64-linux-gnu/libc-2.31.so) =&gt;     7f4661556450 __tunable_get_val@plt+0x0 (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n           uname  2385 [007]   291.223797766:   jmp                      7f4661556454 __tunable_get_val@plt+0x4 (/usr/lib/x86_64-linux-gnu/libc-2.31.so) =&gt;     7f4661556120 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n           uname  2385 [007]   291.223797766:   jmp                      7f4661556129 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so) =&gt;     7f4661556000 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so)\n           uname  2385 [007]   291.223797766:   jmp                      7f4661556006 [unknown] (/usr/lib/x86_64-linux-gnu/libc-2.31.so) =&gt;     7f4661756bb0 _dl_runtime_resolve_xsavec+0x0 (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n           uname  2385 [007]   291.223797766:   call                     7f4661756c29 _dl_runtime_resolve_xsavec+0x79 (/usr/lib/x86_64-linux-gnu/ld-2.31.so) =&gt;     7f466174f0b0 _dl_fixup+0x0 (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n           uname  2385 [007]   291.223797766:   call                     7f466174f182 _dl_fixup+0xd2 (/usr/lib/x86_64-linux-gnu/ld-2.31.so) =&gt;     7f466174a0d0 _dl_lookup_symbol_x+0x0 (/usr/lib/x86_64-linux-gnu/ld-2.31.so)\n$ \n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-tracing-suspend-and-resume","title":"Example: Tracing suspend and resume","text":"<p>Tracing suspend and resume can be problematic.  For example, with a NUC runing Ubuntu 20.04 the following:</p> <ul> <li>during suspend, non-boot CPUs (CPUs 1 to 7) are disabled and Intel PT is stopped, but not restarted during resume</li> <li>on CPU 0, while suspended, Intel PT is reset and also not restarted</li> <li>TSC is reset, which would mess up the timing information, even if Intel PT had not been disabled</li> </ul> <p>The NUC and OS support \"freeze\" (suspend-to-idle) which does not have the issues above, however another alternative is to use [http://www.kernel.org/doc/html/latest/power/basic-pm-debugging.html pm_test] which is what we will do in this example.</p> <p>Before tracing, we can do a trick to reduce some trace errors.  Because there can be JIT-compiled eBPF in between modules, we need to load another module to delineate the used memory.  A good choice is zfs because it is not already loaded and it is big so it will be added at the end.</p> <pre><code>$ sudo cat /proc/kallsyms | sort | tail\nffffffffc0f7e1b8 d __UNIQUE_ID_ddebug323.71328  [rfcomm]\nffffffffc0f7e200 d __this_module        [rfcomm]\nffffffffc0f7e580 b __key.72085  [rfcomm]\nffffffffc0f7e580 b rfcomm_dlc_debugfs   [rfcomm]\nffffffffc0f7e588 b rfcomm_thread        [rfcomm]\nffffffffc0f7e590 b l2cap_ertm   [rfcomm]\nffffffffc0f7e591 b disable_cfc  [rfcomm]\nffffffffc0f7e5a0 b rfcomm_sock_debugfs  [rfcomm]\nffffffffc0f7e5b0 b rfcomm_sk_list       [rfcomm]\nffffffffc0f7e5c8 b rfcomm_tty_driver    [rfcomm]\n$ sudo modprobe zfs\n$ sudo cat /proc/kallsyms | sort | tail\nffffffffc1439980 b zvol_request_sync    [zfs]\nffffffffc1439984 b zvol_inhibit_dev     [zfs]\nffffffffc1439988 b __key.65694  [zfs]\nffffffffc1439988 b __key.65702  [zfs]\nffffffffc1439988 b __key.65999  [zfs]\nffffffffc1439990 b zvol_ida     [zfs]\nffffffffc14399a0 b zvol_htable  [zfs]\nffffffffc14399c0 b zvol_state_list      [zfs]\nffffffffc14399e0 b zvol_state_lock      [zfs]\nffffffffc1439a10 b zvol_taskq   [zfs]\n</code></pre> <p>We can enable pm_test as follows:</p> <pre><code>$ sudo cat /sys/power/pm_test\n[none] core processors platform devices freezer\n$ sudo bash -c 'echo platform &gt; /sys/power/pm_test'\n$ sudo cat /sys/power/pm_test\nnone core processors [platform] devices freezer\n</code></pre> <p>This example includes kernel tracing, which requires administrator privileges.</p> <p>We can start an open-ended trace, then run the suspend platform test, then kill <code>perf</code> to end the trace.</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-o pt-mem-test</code> to name the output pt-mem-test</li> <li><code>-a</code> to trace system wide i.e. all tasks, all CPUs</li> <li><code>--kcore</code> to copy kernel object code from the /proc/kcore image (helps avoid decoding errors due to kernel self-modifying code)</li> <li><code>-m,128M</code> to set the trace buffer size to 128 MiB.  This is needed to avoid trace data loss.  Note the comma is needed.  Also be careful setting large buffer sizes.  With per-cpu tracing (the default), one buffer per CPU will be allocated.  In our case we have 8 CPUs so that means 1024 MiB.  However when tracing with per-task contexts, there will be one buffer per task, which might be far more than anticipated.</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt//k</code> to get Intel PT tracing the kernel only</li> </ul> <pre><code>$ sudo ~/bin/perf record -o pt-mem-test -a --kcore -m,128M -e intel_pt//k &amp;\n[1] 2186\n$ sudo bash -c 'echo mem &gt; /sys/power/state'\n$ sudo kill 2186\n$ [ perf record: Woken up 9 times to write data ]\n[ perf record: Captured and wrote 148.521 MB pt-mem-test ]\n[1]+  Terminated              sudo ~/bin/perf record -o pt-mem-test -a --kcore -m,128M -e intel_pt//k\n</code></pre> <p>Now, we can disable pm_test as follows:</p> <pre><code>$ sudo bash -c 'echo none &gt; /sys/power/pm_test'\n$ sudo cat /sys/power/pm_test\n[none] core processors platform devices freezer\n</code></pre> <p>We can allow perf_users to access the trace:</p> <pre><code>$ sudo chgrp -R perf_users pt-mem-test\n$ sudo chmod -R g+r pt-mem-test\n$ sudo chmod g+rx pt-mem-test pt-mem-test/kcore_dir \n</code></pre> <p>We can check to see how many trace errors there are:</p> <pre><code>$ perf script -i pt-mem-test --itrace=e\nWarning:\n29 instruction trace errors\n instruction trace error type 1 time 2854.304038029 cpu 3 pid 0 tid 0 ip 0xffffffffae0001b0 code 10: Never-ending loop\n instruction trace error type 1 time 2854.519908646 cpu 3 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2854.615877328 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2855.951848561 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2855.971847161 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2855.983848121 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2856.391842767 cpu 2 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2856.827831320 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2857.059827217 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2857.071827844 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2857.143826938 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2857.163825205 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2857.659815892 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2857.671817186 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2857.971810190 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2858.359804569 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2858.591800132 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2858.651797933 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2858.663798894 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2858.683797160 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2858.695798454 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2858.795795122 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2858.987791818 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2859.111791073 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2859.323785703 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2859.435783331 cpu 0 pid 0 tid 0 ip 0xffffffffaded55b6 code 7: Overflow packet\n instruction trace error type 1 time 2859.474475203 cpu 0 pid 0 tid 0 ip 0xffffffffaded55a1 code 7: Overflow packet\n instruction trace error type 1 time 2859.517865726 cpu 6 pid 0 tid 0 ip 0xffffffffad547ec9 code 7: Overflow packet\n instruction trace error type 1 time 2859.519310388 cpu 4 pid 2189 tid 2189 ip 0xffffffffad4d9acc code 7: Overflow packet\n</code></pre> <p>Most of the overflows are at 0xffffffffaded55b6, which is in mwait_idle i.e.:</p> <pre><code>$ grep ffffffffaded55b6 pt-mem-test/kcore_dir/kallsyms \n$ grep ffffffffaded55b pt-mem-test/kcore_dir/kallsyms \n$ grep ffffffffaded55 pt-mem-test/kcore_dir/kallsyms \nffffffffaded5530 t mwait_idle\n$ cat pt-mem-test/kcore_dir/kallsyms | sort | grep -A 1 ffffffffaded55\nffffffffaded5530 t mwait_idle\nffffffffaded5700 T acpi_processor_ffh_cstate_enter\n</code></pre> <p>It is not uncommon to get overflows when transitioning to a C-state, so these errors are not significant.</p> <p>Overflows last relatively short periods, and there are very few errors compared with the size of the trace, so we can ignore them.</p> <p>To reduce the time ranges that we look at, we can find the time of the state_store function which got called when we did <code>'echo mem &gt; /sys/power/state'</code></p> <pre><code>$ perf script -i pt-mem-test --itrace=be --ns | grep state_store\n            bash  2189 [002]  2854.298249382:          1  branches:k:  ffffffffae200cf0 __x86_indirect_thunk_rax+0x10 ([kernel.kallsyms]) =&gt; ffffffffad507580 state_store+0x0 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298249382:          1  branches:k:  ffffffffad5075ac state_store+0x2c ([kernel.kallsyms]) =&gt; ffffffffadeb9480 memchr+0x0 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298249715:          1  branches:k:  ffffffffadeb949c memchr+0x1c ([kernel.kallsyms]) =&gt; ffffffffad5075b1 state_store+0x31 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffad5075df state_store+0x5f ([kernel.kallsyms]) =&gt; ffffffffadeb93a0 strlen+0x0 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffadeb93b4 strlen+0x14 ([kernel.kallsyms]) =&gt; ffffffffad5075e4 state_store+0x64 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffad5075f5 state_store+0x75 ([kernel.kallsyms]) =&gt; ffffffffad5075c8 state_store+0x48 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffad5075d6 state_store+0x56 ([kernel.kallsyms]) =&gt; ffffffffad5075ed state_store+0x6d ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffad5075f5 state_store+0x75 ([kernel.kallsyms]) =&gt; ffffffffad5075c8 state_store+0x48 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffad5075df state_store+0x5f ([kernel.kallsyms]) =&gt; ffffffffadeb93a0 strlen+0x0 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffadeb93b4 strlen+0x14 ([kernel.kallsyms]) =&gt; ffffffffad5075e4 state_store+0x64 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffad5075eb state_store+0x6b ([kernel.kallsyms]) =&gt; ffffffffad50761d state_store+0x9d ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffad507623 state_store+0xa3 ([kernel.kallsyms]) =&gt; ffffffffadeb9600 strncmp+0x0 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffadeb9627 strncmp+0x27 ([kernel.kallsyms]) =&gt; ffffffffad507628 state_store+0xa8 ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffad507638 state_store+0xb8 ([kernel.kallsyms]) =&gt; ffffffffad5075fa state_store+0x7a ([kernel.kallsyms])\n            bash  2189 [002]  2854.298250048:          1  branches:k:  ffffffffad5075fd state_store+0x7d ([kernel.kallsyms]) =&gt; ffffffffad508bd0 pm_suspend+0x0 ([kernel.kallsyms])\n^C$ \n</code></pre> <p>For other time ranges, we can use the kernel messages:</p> <pre><code>$ dmesg | tail -60\n[    5.553665] iwlwifi 0000:00:14.3: BIOS contains WGDS but no WRDS\n[    6.820682] Bluetooth: RFCOMM TTY layer initialized\n[    6.820688] Bluetooth: RFCOMM socket layer initialized\n[    6.820691] Bluetooth: RFCOMM ver 1.11\n[   10.290428] e1000e: eno1 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: Rx/Tx\n[   10.290585] IPv6: ADDRCONF(NETDEV_CHANGE): eno1: link becomes ready\n[ 2345.150557] usb 1-2: new low-speed USB device number 4 using xhci_hcd\n[ 2345.305251] usb 1-2: New USB device found, idVendor=1a2c, idProduct=2124, bcdDevice= 1.10\n[ 2345.305255] usb 1-2: New USB device strings: Mfr=1, Product=2, SerialNumber=0\n[ 2345.305257] usb 1-2: Product: USB Keyboard\n[ 2345.305258] usb 1-2: Manufacturer: SEM\n[ 2345.309691] input: SEM USB Keyboard as /devices/pci0000:00/0000:00:14.0/usb1/1-2/1-2:1.0/0003:1A2C:2124.0002/input/input12\n[ 2345.366828] hid-generic 0003:1A2C:2124.0002: input,hidraw1: USB HID v1.10 Keyboard [SEM USB Keyboard] on usb-0000:00:14.0-2/input0\n[ 2345.369299] input: SEM USB Keyboard Consumer Control as /devices/pci0000:00/0000:00:14.0/usb1/1-2/1-2:1.1/0003:1A2C:2124.0003/input/input13\n[ 2345.426807] input: SEM USB Keyboard System Control as /devices/pci0000:00/0000:00:14.0/usb1/1-2/1-2:1.1/0003:1A2C:2124.0003/input/input14\n[ 2345.427152] hid-generic 0003:1A2C:2124.0003: input,hidraw2: USB HID v1.10 Device [SEM USB Keyboard] on usb-0000:00:14.0-2/input1\n[ 2633.489054] zlua: loading out-of-tree module taints kernel.\n[ 2633.489058] zlua: module license 'MIT' taints kernel.\n[ 2633.489059] Disabling lock debugging due to kernel taint\n[ 2635.463839] ZFS: Loaded module v0.8.3-1ubuntu12, ZFS pool version 5000, ZFS filesystem version 5\n[ 2854.298251] PM: suspend entry (deep)\n[ 2854.302058] Filesystems sync: 0.003 seconds\n[ 2854.303263] Freezing user space processes ... (elapsed 0.001 seconds) done.\n[ 2854.305258] OOM killer disabled.\n[ 2854.305259] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.\n[ 2854.306481] printk: Suspending console(s) (use no_console_suspend to debug)\n[ 2854.307753] e1000e: EEE TX LPI TIMER: 00000011\n[ 2854.332049] sd 2:0:0:0: [sda] Synchronizing SCSI cache\n[ 2854.332204] sd 2:0:0:0: [sda] Stopping disk\n[ 2854.502891] ACPI: EC: interrupt blocked\n[ 2854.525496] ACPI: Preparing to enter system sleep state S3\n[ 2854.527608] ACPI: EC: event blocked\n[ 2854.527609] ACPI: EC: EC stopped\n[ 2854.527610] PM: Saving platform NVS memory\n[ 2854.527621] PM: suspend debug: Waiting for 5 second(s).\n[ 2859.465807] ACPI: EC: EC started\n[ 2859.465809] ACPI: Waking up from system sleep state S3\n[ 2859.472814] ACPI: EC: interrupt unblocked\n[ 2859.517524] ACPI: EC: event unblocked\n[ 2859.526934] iwlwifi 0000:00:14.3: Applying debug destination EXTERNAL_DRAM\n[ 2859.528470] sd 2:0:0:0: [sda] Starting disk\n[ 2859.675539] iwlwifi 0000:00:14.3: Applying debug destination EXTERNAL_DRAM\n[ 2859.743970] iwlwifi 0000:00:14.3: FW already configured (0) - re-configuring\n[ 2859.754123] iwlwifi 0000:00:14.3: BIOS contains WGDS but no WRDS\n[ 2859.844031] ata3: SATA link up 6.0 Gbps (SStatus 133 SControl 300)\n[ 2859.845676] ata3.00: ACPI cmd ef/10:06:00:00:00:00 (SET FEATURES) succeeded\n[ 2859.845680] ata3.00: ACPI cmd f5/00:00:00:00:00:00 (SECURITY FREEZE LOCK) filtered out\n[ 2859.845682] ata3.00: ACPI cmd b1/c1:00:00:00:00:00 (DEVICE CONFIGURATION OVERLAY) filtered out\n[ 2859.847186] ata3.00: ACPI cmd ef/10:06:00:00:00:00 (SET FEATURES) succeeded\n[ 2859.847189] ata3.00: ACPI cmd f5/00:00:00:00:00:00 (SECURITY FREEZE LOCK) filtered out\n[ 2859.847192] ata3.00: ACPI cmd b1/c1:00:00:00:00:00 (DEVICE CONFIGURATION OVERLAY) filtered out\n[ 2859.847451] ata3.00: configured for UDMA/133\n[ 2859.847457] ahci 0000:00:17.0: port does not support device sleep\n[ 2859.847570] ata3.00: Enabling discard_zeroes_data\n[ 2859.888491] acpi LNXPOWER:04: Turning OFF\n[ 2859.888592] OOM killer enabled.\n[ 2859.888593] Restarting tasks ... done.\n[ 2859.895729] video LNXVIDEO:00: Restoring backlight state\n[ 2859.895741] PM: suspend exit\n[ 2864.837431] e1000e: eno1 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: Rx/Tx\n</code></pre> <p>We can use the following times:</p> <ul> <li>suspend start time 2854.298249382 from time of state_store</li> <li>suspend end time 2854.527622 from time of \"PM: suspend debug: Waiting for 5 second(s).\" plus 1 us</li> <li>resume start time 2859.465807 from time of \"ACPI: EC: EC started\"</li> <li>resume end time 2859.895742 from time of \"PM: suspend exit\" plus 1 us</li> </ul> <p>For analysis, we can export to a database, but because we have a lot of data we will use PostgreSQL because it is faster than SQLite3 for large data sets.</p> <p>We can install PostgreSQL and add userid \"user\" as follows:</p> <pre><code>$ sudo apt-get install postgresql\n$ sudo su - postgres\n$ createuser -s user\n$ exit\n</code></pre> <p>We can stop PostgreSQL and stop it from starting at boot up:</p> <pre><code>$ sudo systemctl stop postgresql\n$ sudo systemctl disable postgresql\n</code></pre> <p>Now, we can manually start PostgreSQL when we need it:</p> <pre><code>$ sudo systemctl start postgresql\n</code></pre> <p>We can make one database for the suspend:</p> <pre><code>$ perf script -i pt-mem-test --itrace=bp --time 2854.298249382,2854.527622 -s ~/libexec/perf-core/scripts/python/export-to-postgresql.py pt_mem_test_suspend branches calls\n2020-06-20 20:12:47.806519 Creating database...\n2020-06-20 20:12:47.919280 Writing to intermediate files...\n2020-06-20 20:12:57.584499 Copying to database...\n2020-06-20 20:13:10.366941 Removing intermediate files...\n2020-06-20 20:13:10.458730 Adding primary keys\n2020-06-20 20:13:13.194662 Adding foreign keys\n2020-06-20 20:13:23.763399 Dropping unused tables\n2020-06-20 20:13:23.784527 Done\n</code></pre> <p>And one database for the resume:</p> <pre><code>$ perf script -i pt-mem-test --itrace=bp --time 2859.465807,2859.895742 -s ~/libexec/perf-core/scripts/python/export-to-postgresql.py pt_mem_test_resume branches calls\n2020-06-20 20:56:33.427551 Creating database...\n2020-06-20 20:56:33.639840 Writing to intermediate files...\n2020-06-20 20:57:54.092614 Copying to database...\n2020-06-20 20:59:45.300365 Removing intermediate files...\n2020-06-20 20:59:45.715793 Adding primary keys\n2020-06-20 21:00:36.798973 Adding foreign keys\n2020-06-20 21:01:49.617689 Dropping unused tables\n2020-06-20 21:01:49.648594 Done\n</code></pre> <p>We can do a crude analysis by aggregating and sorting by function elapsed time.  Note the elapsed time is summed across all CPUs and will be inaccurate for functions where a call or return was not found.</p> <pre><code>$ psql pt_mem_test_suspend -c 'SELECT COUNT(symbol_id),symbol_id,(SELECT name FROM symbols WHERE id = symbol_id) AS symbol,SUM(elapsed_time) AS tot_elapsed_time,SUM(branch_count) AS tot_branch_count FROM calls_view GROUP BY symbol_id ORDER BY tot_elapsed_time DESC LIMIT 140;' | cat\n count | symbol_id |               symbol                | tot_elapsed_time | tot_branch_count \n-------+-----------+-------------------------------------+------------------+------------------\n 51753 |       155 | __switch_to_asm                     |      25643692943 |          8084655\n  2247 |       118 | __schedule                          |       3384905721 |          1392743\n  1049 |       117 | schedule                            |       3073233872 |           655725\n    57 |       232 | worker_thread                       |       2251468533 |          1611634\n  2027 |       141 | __perf_event_task_sched_out         |       2179969857 |           469787\n  3657 |       142 | perf_iterate_sb                     |       2111444662 |           820888\n  7109 |       144 | perf_event_switch_output            |       2024431937 |           763784\n   765 |       161 | do_idle                             |       1801033690 |          1121148\n     8 |       162 | cpu_startup_entry                   |       1799810214 |          1117125\n   929 |       189 | cpuidle_enter_state                 |       1512404441 |           372312\n   951 |       186 | call_cpuidle                        |       1512291784 |           374355\n   929 |       187 | cpuidle_enter                       |       1512260439 |           372467\n   816 |       191 | intel_idle                          |       1506383402 |            11860\n    54 |      1572 | ret_from_fork                       |       1236671564 |           405507\n 32212 |       150 | perf_output_copy                    |       1140597616 |           236324\n 32622 |        19 | memcpy                              |       1037897766 |            98232\n 33010 |        20 | memcpy_erms                         |       1037897766 |            65712\n  6858 |       151 | __perf_event__output_id_sample      |       1020294283 |           238528\n   124 |       740 | schedule_timeout                    |        833043903 |            80630\n   333 |       234 | process_one_work                    |        818013956 |          1492462\n  1617 |       156 | __switch_to                         |        806190983 |           230558\n   302 |      1388 | async_run_entry_fn                  |        805990273 |          1332080\n   935 |      1878 | __device_suspend                    |        602465683 |           795242\n   106 |      1905 | async_suspend                       |        598335358 |           711555\n    21 |      1575 | kthread                             |        511135637 |           654753\n   453 |      1674 | wait_for_completion                 |        462718168 |            27924\n  1805 |      1896 | dpm_wait                            |        462391503 |            27536\n  2752 |      1879 | dpm_wait_for_subordinate            |        462184824 |           127442\n  6458 |       147 | __perf_event_header__init_id.isra.0 |        453504285 |           207450\n 17677 |        27 | sched_clock_cpu                     |        443029861 |           104431\n 17678 |        28 | sched_clock                         |        442861857 |            69342\n 17677 |        29 | native_sched_clock                  |        442769188 |            23308\n  6483 |       148 | local_clock                         |        442429154 |            73876\n  2765 |      1880 | device_for_each_child               |        434117232 |           106147\n  1801 |      1895 | dpm_wait_fn                         |        432735602 |            33496\n     7 |      1754 | smpboot_thread_fn                   |        383439061 |            27473\n   459 |      1891 | dpm_run_callback                    |        352449547 |          1209376\n    20 |      2179 | msleep                              |        284584388 |            15571\n   475 |       553 | schedule_hrtimeout_range_clock      |        224993536 |           303536\n   475 |       554 | schedule_hrtimeout_range            |        224959544 |           303188\n   306 |      1767 | usleep_range                        |        215422913 |           297674\n     2 |      2920 | tpm_transmit                        |        204055552 |           192763\n    15 |      2039 | pci_set_power_state                 |        203058833 |           313354\n    14 |      2257 | pci_raw_set_power_state             |        201300666 |            22320\n  6488 |       149 | perf_output_begin                   |        200342196 |            53228\n    76 |      3752 | default_idle_call                   |        197153681 |             9395\n    65 |      3754 | mwait_idle                          |        197150348 |             9130\n    64 |      3753 | arch_cpu_idle                       |        197150348 |             9250\n   914 |      3763 | __device_suspend_noirq              |        177018409 |           539319\n  6410 |       152 | perf_output_end                     |        172279083 |            26373\n  6406 |       153 | perf_output_put_handle              |        171087750 |            10655\n    97 |      3766 | async_suspend_noirq                 |        170761099 |           481677\n    19 |      3767 | pci_pm_suspend_noirq                |        169819437 |           461954\n     2 |      2377 | tpm_pm_suspend                      |        157369145 |           157176\n     1 |      2918 | tpm2_shutdown                       |        156458481 |           150632\n     1 |      2919 | tpm_transmit_cmd                    |        156456147 |           150552\n     9 |      3768 | pci_prepare_to_sleep                |        150865833 |           314568\n  1125 |       154 | enter_lazy_tlb                      |        143645190 |             8102\n    21 |      1975 | pci_pm_suspend                      |        130362569 |           672764\n   758 |       160 | schedule_idle                       |         89123399 |           466833\n     4 |      2157 | usb_port_resume                     |         68498773 |             7301\n     3 |       744 | rcu_gp_kthread                      |         68089441 |            14204\n     1 |      2372 | e1000e_pm_suspend                   |         58136474 |           509370\n    37 |      1977 | __pm_runtime_resume                 |         42501525 |            53958\n    39 |      1978 | rpm_resume                          |         42495862 |            53684\n     8 |      1981 | rpm_callback                        |         42488526 |            53097\n     8 |      1982 | __rpm_callback                      |         42488526 |            53093\n   912 |      3681 | __device_suspend_late               |         35785898 |           102222\n    95 |      3684 | async_suspend_late                  |         35475218 |            46241\n     9 |      1459 | async_synchronize_cookie_domain     |         34602552 |            16471\n     4 |      1983 | pci_pm_runtime_resume               |         31412230 |            45884\n     1 |      2398 | e1000e_pm_freeze                    |         27508908 |            20420\n  5930 |       525 | mutex_lock                          |         27491910 |            45500\n     3 |      1988 | rtnl_lock                           |         27271909 |             2585\n     2 |      2399 | __mutex_lock_slowpath               |         27270243 |             2558\n     2 |      2400 | __mutex_lock.isra.0                 |         27270243 |             2554\n     2 |      2401 | schedule_preempt_disabled           |         27270243 |             2518\n     2 |      1784 | suspend_devices_and_enter           |         26722578 |           313122\n     1 |      3111 | __e1000_shutdown                    |         26479579 |           418542\n     3 |      3679 | suspend_enter                       |         26475246 |           509770\n     7 |      2273 | scsi_bus_suspend_common             |         25100250 |             4560\n   335 |      3117 | e1000e_write_phy_reg_mdic           |         24979374 |           424874\n     2 |      2275 | scsi_device_quiesce                 |         24933585 |             1607\n     6 |      2272 | scsi_bus_suspend                    |         24932584 |             1556\n     1 |      2277 | blk_mq_freeze_queue                 |         24924917 |              823\n     1 |      2281 | blk_mq_freeze_queue_wait            |         24923584 |              768\n   595 |      2575 | delay_tsc                           |         24782071 |           483853\n   597 |      2574 | __const_udelay                      |         24782071 |           485042\n   678 |      1999 | raw_pci_read                        |         23076242 |           165159\n   659 |      1998 | pci_read                            |         23032911 |           167502\n   147 |      3121 | __e1000_write_phy_reg_hv            |         21554264 |           372409\n   579 |      2002 | pci_conf1_read                      |         21341669 |           161095\n     1 |      2368 | pci_legacy_suspend                  |         20570598 |             5401\n     1 |      2369 | rtsx_pci_suspend                    |         20570265 |             5384\n     1 |      3788 | hcd_pci_suspend_noirq               |         20541265 |            53751\n    19 |      2402 | pci_save_state                      |         19793934 |           150800\n 23936 |        33 | _raw_spin_lock_irqsave              |         19035782 |           182998\n     4 |      1984 | pci_restore_standard_config         |         18696937 |            31582\n   787 |       794 | native_queued_spin_lock_slowpath    |         18328613 |           163490\n     1 |      3680 | dpm_suspend_late                    |         18081940 |            86213\n     9 |      1927 | usb_suspend_both                    |         17712607 |            14462\n    19 |      3685 | pci_pm_suspend_late                 |         17650940 |            32293\n    25 |      3686 | pm_generic_suspend_late             |         17647941 |            31934\n     1 |      3690 | i915_pm_suspend_late                |         17642941 |            31880\n     1 |      3691 | i915_drm_suspend_late               |         17642608 |            31876\n    18 |      2121 | usb_control_msg                     |         17637609 |            14910\n    19 |      2124 | usb_start_wait_urb                  |         17631277 |            14520\n     6 |      1840 | async_synchronize_full              |         17585608 |             4762\n     6 |      2119 | generic_suspend                     |         17220276 |             5745\n     5 |      2120 | usb_port_suspend                    |         17017944 |             4109\n    20 |      2125 | usb_submit_urb                      |         16906944 |             6050\n    20 |      2126 | usb_hcd_submit_urb                  |         16903944 |             5908\n     2 |      2011 | __ieee80211_suspend                 |         16900277 |            16924\n    12 |      2159 | rh_call_control                     |         16895943 |             5360\n    12 |      2161 | xhci_hub_control                    |         16875276 |             2647\n     2 |      2287 | set_port_feature                    |         16800944 |             2587\n   459 |      1997 | pci_bus_read_config_dword           |         16082280 |           116781\n   449 |      2395 | pci_read_config_dword               |         15771950 |           115817\n   118 |      3330 | e1000_access_phy_wakeup_reg_bm      |         15113286 |           269309\n   115 |      3336 | e1000_write_phy_reg_page_hv         |         14123620 |           256960\n     5 |      2381 | crb_wait_for_reg_32.constprop.0     |         13730621 |           116395\n     1 |      2550 | ieee80211_stop_device               |         13666621 |             7922\n     1 |      2558 | drv_stop                            |         13661621 |             7674\n     1 |      2559 | iwl_mvm_mac_stop                    |         13661288 |             7666\n     1 |      2560 | __iwl_mvm_mac_stop                  |         13659621 |             7519\n     1 |      2994 | azx_runtime_resume                  |         12872624 |             8900\n     1 |      2995 | __azx_runtime_resume                |         12868957 |             8894\n     1 |      2566 | iwl_trans_pcie_stop_device          |         12811624 |             5928\n     1 |      2567 | _iwl_trans_pcie_stop_device         |         12809957 |             5902\n     2 |      2589 | iwl_trans_pcie_sw_reset             |         12121294 |             1713\n     1 |      2961 | linkwatch_event                     |         11315629 |             1838\n     1 |      2950 | e1000e_down                         |         11221963 |            15148\n 25465 |       145 | perf_event_pid_type                 |         11045680 |           166961\n 25467 |       146 | __task_pid_nr_ns                    |         10978670 |           102056\n     1 |      2441 | mei_me_pm_runtime_resume            |         10954631 |              859\n     1 |      2443 | mei_me_d0i3_exit_sync               |         10953630 |              842\n     1 |      2442 | mei_me_pg_exit_sync                 |         10953630 |              844\n     1 |         3 | state_store                         |         10033967 |           242098\n     1 |         1 | kobj_attr_store                     |         10033967 |           242099\n     1 |         7 | pm_suspend                          |         10033301 |           242064\n(140 rows)\n\n$ psql pt_mem_test_resume -c 'SELECT COUNT(symbol_id),symbol_id,(SELECT name FROM symbols WHERE id = symbol_id) AS symbol,SUM(elapsed_time) AS tot_elapsed_time,SUM(branch_count) AS tot_branch_count FROM calls_view GROUP BY symbol_id ORDER BY tot_elapsed_time DESC LIMIT 140;' | cat\n count  | symbol_id |                  symbol                   | tot_elapsed_time | tot_branch_count \n--------+-----------+-------------------------------------------+------------------+------------------\n  85530 |        91 | __switch_to_asm                           |     285351925524 |         96433888\n   6011 |        56 | __schedule                                |      14948664243 |          7784999\n   1851 |        96 | schedule                                  |      14653524942 |          6639494\n   2871 |        92 | __switch_to                               |       8977603169 |          5737396\n    178 |       193 | worker_thread                             |       6680804308 |          1576838\n   3317 |        77 | __perf_event_task_sched_out               |       4600197729 |           793879\n   6008 |        78 | perf_iterate_sb                           |       4449766476 |          1390741\n  11533 |        80 | perf_event_switch_output                  |       4094624656 |          1295510\n    627 |       703 | schedule_timeout                          |       3725284572 |           599231\n   3245 |       142 | do_idle                                   |       3470715806 |         21221047\n     11 |       264 | cpu_startup_entry                         |       3411701625 |         21217880\n  46407 |      1210 | call_cpuidle                              |       2804113112 |         11364705\n  46313 |      1212 | cpuidle_enter                             |       2803665450 |         11271883\n  46313 |      1214 | cpuidle_enter_state                       |       2803575784 |         11087380\n    488 |       194 | process_one_work                          |       2667120505 |          1326501\n    344 |       805 | async_run_entry_fn                        |       2590109758 |           820705\n   1802 |      1216 | intel_idle                                |       2453148165 |            18285\n    287 |       725 | wait_for_completion                       |       2300947973 |           102703\n    498 |       808 | dpm_wait_for_superior                     |       2300522704 |           130369\n    501 |       834 | dpm_wait                                  |       2299873032 |            98477\n  53293 |        86 | perf_output_copy                          |       2095119404 |           384340\n    944 |      1314 | device_resume                             |       1895560721 |           407787\n  11148 |        87 | __perf_event__output_id_sample            |       1876404517 |           403447\n    124 |      1326 | async_resume                              |       1659448842 |           266326\n      9 |        97 | smpboot_thread_fn                         |       1335019903 |            63663\n  69170 |        15 | memcpy_erms                               |       1259056878 |           118574\n  68671 |        14 | memcpy                                    |       1259056878 |           187115\n     50 |      1065 | kthread                                   |       1210197649 |           234278\n    124 |      1062 | ret_from_fork                             |       1119255949 |           472199\n  10741 |        83 | __perf_event_header__init_id.isra.0       |        835974127 |           361423\n      4 |      1713 | irq_thread                                |        821502272 |           135505\n 209977 |        18 | sched_clock_cpu                           |        768117692 |          1085558\n 209971 |        19 | sched_clock                               |        767738618 |           664497\n 209968 |        20 | native_sched_clock                        |        766809889 |           222311\n  10783 |        84 | local_clock                               |        763929233 |           131320\n     24 |       872 | msleep                                    |        716006959 |            70580\n    941 |       807 | device_resume_noirq                       |        689453373 |           623511\n    123 |       806 | async_resume_noirq                        |        605174322 |           485002\n  13995 |       502 | mutex_lock                                |        419992763 |           167568\n    477 |       732 | __mutex_lock_slowpath                     |        418528939 |            65987\n    477 |       733 | __mutex_lock.isra.0                       |        418528605 |            65061\n     14 |       737 | schedule_preempt_disabled                 |        416323953 |             9538\n      5 |       714 | acpi_hotplug_work_fn                      |        416319618 |            16566\n      4 |       730 | acpi_device_hotplug                       |        416307618 |            15386\n     24 |      1327 | pci_pm_resume                             |        407527495 |          2376699\n      2 |      1313 | dpm_resume                                |        368244112 |           157625\n      1 |      1805 | e1000e_pm_resume                          |        367856112 |          2264968\n  10743 |        85 | perf_output_begin                         |        360460322 |            91341\n  44514 |      1734 | poll_idle                                 |        344075848 |          9752486\n   3241 |       187 | schedule_idle                             |        341011283 |           760522\n      5 |       957 | kthreadd                                  |        334471558 |           107715\n     24 |      1466 | ata_msleep                                |        325523584 |            19652\n     18 |      2077 | __scsi_execute                            |        320628269 |            27053\n     18 |      2091 | blk_execute_rq                            |        320596603 |            23104\n     20 |      2112 | io_schedule_timeout                       |        320546936 |            15539\n     18 |      2111 | wait_for_completion_io_timeout            |        320546604 |            15342\n      1 |      2066 | scsi_dev_type_resume                      |        319120274 |             1816\n      1 |      2065 | async_sdev_resume                         |        319120274 |             1820\n      1 |      2067 | do_scsi_resume                            |        319116940 |             1689\n      1 |      2068 | sd_resume                                 |        319116940 |             1685\n      1 |      2076 | sd_start_stop_device                      |        319112274 |             1143\n      4 |      2011 | scsi_error_handler                        |        317802944 |           289791\n      4 |      2012 | ata_scsi_error                            |        317782945 |           287891\n      4 |      2015 | ata_scsi_port_error_handler               |        317759613 |           287682\n      2 |      2046 | ata_eh_recover                            |        317745944 |           288063\n      2 |      2039 | sata_pmp_error_handler                    |        317713279 |           286708\n      2 |      2038 | ahci_error_handler                        |        317712945 |           286676\n      2 |      2044 | sata_pmp_eh_recover                       |        317712279 |           286647\n      1 |      2047 | ata_eh_reset                              |        315574953 |            19949\n      1 |      2054 | ata_do_reset                              |        315560620 |            19303\n      1 |      2056 | ahci_do_hardreset                         |        315560286 |            19287\n      1 |      2055 | ahci_hardreset                            |        315560286 |            19291\n      1 |      2058 | sata_link_hardreset                       |        315554953 |            19259\n      1 |      2115 | sata_link_resume                          |        314494623 |            18406\n      1 |      2710 | __e1000_resume                            |        312765962 |          1386473\n    411 |      1264 | schedule_hrtimeout_range_clock            |        310439884 |           326474\n    409 |      1263 | schedule_hrtimeout_range                  |        310434220 |           326579\n    228 |       141 | default_idle_call                         |        309502540 |            13169\n    212 |       140 | arch_cpu_idle                             |        309499872 |            12727\n    212 |       139 | mwait_idle                                |        309499872 |            12317\n    464 |       841 | dpm_run_callback                          |        292866210 |           893629\n      2 |      2943 | rcu_gp_kthread                            |        288285043 |            10491\n    213 |      1262 | usleep_range                              |        286360633 |           179582\n   2336 |        90 | enter_lazy_tlb                            |        256199483 |            10612\n      1 |      2711 | e1000_resume_workarounds_pchlan           |        242773528 |          1209790\n      1 |      2712 | e1000_init_phy_workarounds_pchlan         |        241693198 |          1199741\n     22 |       854 | pci_power_up                              |        202384994 |           240416\n     22 |       851 | pci_pm_resume_noirq                       |        186022716 |           645188\n   2628 |        94 | finish_task_switch                        |        185356047 |           632666\n   2623 |        95 | __perf_event_task_sched_in                |        183479485 |           611197\n     21 |       861 | pci_raw_set_power_state                   |        174633751 |            89570\n   3283 |      1268 | __const_udelay                            |        156769618 |          2992055\n   3281 |      1269 | delay_tsc                                 |        156769618 |          2985493\n      3 |      1141 | async_synchronize_cookie_domain           |        132836559 |             2419\n      3 |      1140 | async_synchronize_full                    |        132836559 |             2425\n      4 |      2746 | iwl_wait_notification                     |        128951238 |             4668\n    202 |      1833 | e1000e_write_phy_reg_mdic                 |        128042966 |          2451760\n      8 |      2748 | usb_port_resume                           |        113942621 |            16391\n      1 |      3483 | sata_link_debounce                        |        108159308 |            17521\n      2 |      1749 | iwl_mvm_up                                |        106032315 |          1828345\n      4 |      1333 | i915_drm_resume                           |         96838063 |           925008\n     83 |      1933 | __e1000_write_phy_reg_hv                  |         89115984 |          1677443\n      2 |      2714 | e1000_toggle_lanphypc_pch_lpt             |         86013323 |             3235\n      1 |      2454 | intel_display_resume                      |         84957385 |           864298\n      1 |      2459 | __intel_display_resume                    |         84955051 |           863955\n      1 |      2489 | drm_atomic_helper_commit_duplicated_state |         84910385 |           858672\n      1 |      2490 | drm_atomic_commit                         |         84910051 |           858658\n      2 |      2623 | intel_atomic_commit                       |         84909051 |           858119\n      1 |      2665 | intel_atomic_commit_tail                  |         84869385 |           851826\n     11 |      1925 | i2c_transfer                              |         84185721 |           238582\n     11 |      1927 | __i2c_transfer                            |         84183386 |           238363\n     11 |      1928 | __i2c_transfer.part.0                     |         84183053 |           238334\n  10599 |        88 | perf_output_end                           |         82322046 |            44321\n  10598 |        89 | perf_output_put_handle                    |         82288381 |            17948\n      3 |      1944 | iwl_mvm_load_ucode_wait_alive             |         81495062 |           153583\n      1 |      2680 | skl_update_crtcs                          |         68021108 |           843191\n      1 |      2682 | intel_update_crtc                         |         68020774 |           843159\n      1 |      2684 | haswell_crtc_enable                       |         68002107 |           842352\n  42409 |        81 | perf_event_pid_type                       |         67962101 |           293906\n      1 |      2692 | intel_encoders_pre_enable.isra.0          |         67831108 |           835383\n      1 |      2693 | intel_ddi_pre_enable                      |         67830775 |           835376\n      1 |      3679 | e1000e_reset                              |         66664445 |           147625\n     53 |      1851 | usb_control_msg                           |         66284776 |            40820\n     53 |      1854 | usb_start_wait_urb                        |         66272777 |            38835\n     38 |      1930 | drm_dp_i2c_do_msg                         |         65810781 |           206511\n  42534 |        82 | __task_pid_nr_ns                          |         65224567 |           175448\n      8 |      1929 | drm_dp_i2c_xfer                           |         63746788 |           201668\n      1 |      3681 | e1000_reset_hw_ich8lan                    |         62712125 |           119427\n     51 |       339 | acpi_ps_parse_aml                         |         60445802 |          7921658\n      1 |      3167 | i915_hpd_poll_init_work                   |         56777812 |           170866\n      1 |      3168 | drm_helper_hpd_irq_event                  |         56777478 |           170808\n      3 |      3169 | drm_helper_probe_detect_ctx               |         56777145 |           170726\n      2 |      1942 | iwl_run_init_mvm_ucode                    |         56027147 |            70531\n     74 |       236 | acpi_ns_evaluate                          |         55670815 |          3550574\n     73 |        50 | acpi_evaluate_object                      |         55557155 |          3444264\n      8 |      1836 | usb_resume_both                           |         55403483 |            19838\n      8 |      1835 | usb_resume                                |         55397150 |            19714\n      8 |      1834 | usb_dev_resume                            |         55375484 |            19520\n      7 |      1837 | generic_resume                            |         55328150 |            10526\n      2 |      1838 | hcd_bus_resume                            |         55138485 |             2692\n(140 rows)\n</code></pre> <p>While this analysis is crude, we can still pick out some interesting items.</p> <p>Important subsystem and device driver functions are usually prefixed by their identifier, so we can readily see the longest to suspend are tpm and e1000 while the longest to resume are e1000 and scsi devices.</p> <p>The presence of __mutex_lock_slowpath indicates contended mutexes, which is not ideal.</p> <p>The presence of delay or sleep functions msleep, usleep_range, __const_udelay indicates polling, which is not ideal.</p> <p>The 209977 calls to sched_clock_cpu seems excessive, but is probably caused by perf.</p> <p>Finally, we can stop PostgreSQL since we are not using it anymore.</p> <pre><code>$ sudo systemctl stop postgresql\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-detecting-system-management-mode-smm","title":"Example: Detecting System Management Mode (SMM)","text":"<p>Intel PT is automatically disabled by hardware when entering System Management Mode (SMM), so it is possible to use Intel PT to detect whether SMM might have run.  Control-flow packet generation is also disabled in secure enclaves.</p> <p>If those do not occur, and there is no trace data loss, then system wide tracing will show only one \"trace start\" and one \"trace end\" for each CPU.  Additional \"trace start\" or \"trace end\" branches would need another explanation i.e. SMM, secure enclave or trace data loss.</p> <p>To record system wide with 64M buffers for 3 seconds, we can use <code>perf record</code> with options:</p> <ul> <li><code>-m,64M</code> to set the trace buffer size to 64 MiB.  This is needed to avoid trace data loss.  Note the comma is needed.  Also be careful setting large buffer sizes.  With per-cpu tracing (the default), one buffer per CPU will be allocated.  In our case we have 8 CPUs so that means 512 MiB.  However when tracing with per-task contexts, there will be one buffer per task, which might be far more than anticipated.</li> <li><code>-a</code> to trace system wide i.e. all tasks, all CPUs</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt//</code> to get Intel PT</li> <li><code>sleep 3</code> is the workload.  The tracing will stop when the workload finishes, so this is simply a way of tracing for about 3 seconds.</li> </ul> <pre><code>$ sudo perf record -m,64M -a -e intel_pt// -- sleep 3\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 4.524 MB perf.data ]\n</code></pre> <p>To show \"trace start\" and \"trace end\", use <code>perf script</code> with options:</p> <ul> <li><code>--itrace=qbe</code> to show quicker (less detailed) decoding (q), branches (b) and errors (e)</li> <li><code>-F+flags</code> to show branch flags such as <code>tr strt</code> and <code>tr end</code></li> <li><code>--ns</code> to show the timestamp to nanoseconds instead of the default microseconds</li> </ul> <p>Note the itrace 'q' option is new from v5.9.  Use <code>perf version</code> to check the version.</p> <pre><code>$ sudo perf script --itrace=qbe -F+flags --ns | grep 'tr strt\\|tr end'\n            perf  7212 [000] 14733.245070483:          1   branches:   tr strt                             0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu) =&gt; ffffffff81016aa8 pt_config_start+0x68 ([kernel.kallsyms])\n            perf  7212 [001] 14733.245128490:          1   branches:   tr strt                             0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu) =&gt; ffffffff81016aa8 pt_config_start+0x68 ([kernel.kallsyms])\n            perf  7212 [002] 14733.245182361:          1   branches:   tr strt                             0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu) =&gt; ffffffff81016aa8 pt_config_start+0x68 ([kernel.kallsyms])\n            perf  7212 [003] 14733.245237624:          1   branches:   tr strt                             0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu) =&gt; ffffffff81016aa8 pt_config_start+0x68 ([kernel.kallsyms])\n            perf  7212 [004] 14733.245292674:          1   branches:   tr strt                             0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu) =&gt; ffffffff81016aa8 pt_config_start+0x68 ([kernel.kallsyms])\n            perf  7212 [005] 14733.245351116:          1   branches:   tr strt                             0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu) =&gt; ffffffff81016aa8 pt_config_start+0x68 ([kernel.kallsyms])\n            perf  7212 [006] 14733.245404620:          1   branches:   tr strt                             0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu) =&gt; ffffffff81016aa8 pt_config_start+0x68 ([kernel.kallsyms])\n            perf  7212 [007] 14733.245458096:          1   branches:   tr strt                             0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu) =&gt; ffffffff81016aa8 pt_config_start+0x68 ([kernel.kallsyms])\n            perf  7212 [000] 14736.246883705:          1   branches:   tr end               ffffffff81016eb6 pt_config_stop+0x66 ([kernel.kallsyms]) =&gt;                0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu)\n            perf  7212 [001] 14736.246987037:          1   branches:   tr end               ffffffff81016eb6 pt_config_stop+0x66 ([kernel.kallsyms]) =&gt;                0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu)\n            perf  7212 [002] 14736.247082703:          1   branches:   tr end               ffffffff81016eb6 pt_config_stop+0x66 ([kernel.kallsyms]) =&gt;                0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu)\n            perf  7212 [003] 14736.247180369:          1   branches:   tr end               ffffffff81016eb6 pt_config_stop+0x66 ([kernel.kallsyms]) =&gt;                0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu)\n            perf  7212 [004] 14736.247277368:          1   branches:   tr end               ffffffff81016eb6 pt_config_stop+0x66 ([kernel.kallsyms]) =&gt;                0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu)\n            perf  7212 [005] 14736.247370701:          1   branches:   tr end               ffffffff81016eb6 pt_config_stop+0x66 ([kernel.kallsyms]) =&gt;                0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu)\n            perf  7212 [006] 14736.247465034:          1   branches:   tr end               ffffffff81016eb6 pt_config_stop+0x66 ([kernel.kallsyms]) =&gt;                0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu)\n            perf  7212 [007] 14736.247558700:          1   branches:   tr end               ffffffff81016eb6 pt_config_stop+0x66 ([kernel.kallsyms]) =&gt;                0 __per_cpu_start+0x0 ([kernel.kallsyms].data..percpu)\n</code></pre> <p>In this case there were no unexplained <code>tr strt</code> or <code>tr end</code>.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-rdtsc-vs-intel-pt","title":"Example: rdtsc vs Intel PT","text":"<p>The rdtsc instruction has long been used to time functions.  Consider:</p> <ul> <li> <p>(How to Benchmark Code Execution Times on Intel \u00aeIA-32 and IA-64 Instruction Set Architectures)(print/ia-32-ia-64-benchmark-code-execution-paper.pdf)</p> </li> <li> <p>RDTSC the only way to benchmark. https://medium.com/geekculture/rdtsc-the-only-way-to-benchmark-fc84562ef734</p> </li> </ul> <p>But how does it compare to Intel PT.  In particular, Intel PT in cycle-accurate mode and configured to use an address filter to trace a single function.</p> <p>Let's create a test program with a trivial function f() to trace.  Here is the program (named rdtsc-vs-intel-pt.c):</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nstatic inline uint64_t rdtsc(void)\n{\n        unsigned int low, high;\n\n        asm volatile(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n\n        return low | ((uint64_t)high) &lt;&lt; 32;\n}\n\nstatic inline uint64_t rdtsc_before(void)\n{\n        unsigned int low, high;\n\n        asm volatile(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n    asm volatile(\"lfence\");\n\n        return low | ((uint64_t)high) &lt;&lt; 32;\n}\n\nstatic inline uint64_t rdtsc_after(void)\n{\n        unsigned int low, high;\n\n    asm volatile(\"lfence\");\n        asm volatile(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n\n        return low | ((uint64_t)high) &lt;&lt; 32;\n}\n\nstatic inline uint64_t rdtscp(void)\n{\n        unsigned int low, high, p;\n\n        asm volatile(\"rdtscp\" : \"=a\" (low), \"=d\" (high), \"=c\"(p));\n\n        return low | ((uint64_t)high) &lt;&lt; 32;\n}\n\nstatic inline uint64_t rdtscp_before(void)\n{\n        unsigned int low, high, p;\n\n        asm volatile(\"rdtscp\" : \"=a\" (low), \"=d\" (high), \"=c\"(p));\n    asm volatile(\"lfence\");\n\n        return low | ((uint64_t)high) &lt;&lt; 32;\n}\n\nstatic void prt(const char *msg, unsigned long long val)\n{\n    printf(\"%60s: %llu TSC ticks\\n\", msg, val);\n}\n\nvolatile int x = 0;\n\nstatic void __attribute__((noinline)) f(void)\n{\n    x = x * x + x + 1;\n}\n\nint main(int argc, char *argv[])\n{\n    unsigned long long tsc1, tsc2;\n\n    if (argc &gt; 1) {\n        int secs = atoi(argv[1]);\n\n        if (secs)\n            sleep(secs);\n    }\n\n    f();\n\n    f();\n\n    tsc1 = rdtsc();\n    f();\n    tsc2 = rdtsc();\n    prt(\"rdtsc with no ordering, measured f() time\", tsc2 - tsc1);\n\n    tsc1 = rdtscp();\n    f();\n    tsc2 = rdtscp();\n    prt(\"rdtscp with no ordering before, measured f() time\", tsc2 - tsc1);\n\n    tsc1 = rdtscp_before();\n    f();\n    tsc2 = rdtscp();\n    prt(\"rdtscp with ordering, measured f() time\", tsc2 - tsc1);\n\n    tsc1 = rdtsc_before();\n    f();\n    tsc2 = rdtsc_after();\n    prt(\"rdtsc with ordering, measured f() time\", tsc2 - tsc1);\n\n    return 0;\n}\n</code></pre> <p>There are some important points to note.</p> <p>First, the compiler must not inline the function f(), so <code>__attribute__((noinline))</code> is employed.</p> <p>Secondly, rdtsc is not a serializing instruction.  Here is what the Intel SDM has to say about it:</p> <pre><code>The RDTSC instruction is not a serializing instruction. It does not necessarily wait until all previous instructions\nhave been executed before reading the counter. Similarly, subsequent instructions may begin execution before the\nread operation is performed. The following items may guide software seeking to order executions of RDTSC:\n* If software requires RDTSC to be executed only after all previous instructions have executed and all previous\nloads are globally visible, 1 it can execute LFENCE immediately before RDTSC.\n* If software requires RDTSC to be executed only after all previous instructions have executed and all previous\nloads and stores are globally visible, it can execute the sequence MFENCE;LFENCE immediately before RDTSC.\n* If software requires RDTSC to be executed prior to execution of any subsequent instruction (including any\nmemory accesses), it can execute the sequence LFENCE immediately after RDTSC.\n</code></pre> <p>So to serialize rdtsc, the program defines functions rdtsc_before() and rdtsc_after().</p> <p>Thirdly, the newer alternative instruction rdtscp can be used.  However it is not entirely serialized either.  Here is what the Intel SDM has to say about it:</p> <pre><code>The RDTSCP instruction is not a serializing instruction, but it does wait until all previous instructions have executed\nand all previous loads are globally visible.1 But it does not wait for previous stores to be globally visible, and\nsubsequent instructions may begin execution before the read operation is performed. The following items may guide\nsoftware seeking to order executions of RDTSCP:\n* If software requires RDTSCP to be executed only after all previous stores are globally visible, it can execute\nMFENCE immediately before RDTSCP.\n* If software requires RDTSCP to be executed prior to execution of any subsequent instruction (including any\nmemory accesses), it can execute LFENCE immediately after RDTSCP.\n</code></pre> <p>So to serialize rdtscp, the program defines function <code>rdtscp_before()</code>.</p> <p>Finally, the program can take an extra parameter that causes sleep for that number of seconds.  This parameters will come in useful later.</p> <p>Before continuing, we need to consider, if rdtsc and rdtscp need some extra serialization, what about Intel PT.  Here is what the Intel SDM has to say about it:</p> <pre><code>Intel PT can be run in a cycle-accurate mode which enables CYC packets (see Section 32.4.2.14) that provide low-\nlevel information in the processor core clock domain. This cycle counter data in CYC packets can be used to\ncompute IPC (Instructions Per Cycle), or to track wall-clock time on a fine-grain level.\n</code></pre> <pre><code>Cycle-accurate mode adheres to the following protocol:\n* All packets that precede a CYC packet represent instructions or events that took place before the CYC time.\n* All packets that follow a CYC packet represent instructions or events that took place at the same time as, or\nafter, the CYC time.\n* The CYC-eligible packet that immediately follows a CYC packet represents an instruction or event that took\nplace at the same time as the CYC time.\n</code></pre> <p>To compile the test program:</p> <pre><code>$ gcc -Wall -Wextra -O3 -o rdtsc-vs-intel-pt rdtsc-vs-intel-pt.c\n</code></pre> <p>And run it:</p> <pre><code>$ ./rdtsc-vs-intel-pt \n                   rdtsc with no ordering, measured f() time: 95 TSC ticks\n           rdtscp with no ordering before, measured f() time: 288 TSC ticks\n                     rdtscp with ordering, measured f() time: 176 TSC ticks\n                      rdtsc with ordering, measured f() time: 177 TSC ticks\n</code></pre> <p>And trace it with Intel PT:</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt/cyc/u</code> to get Intel PT with cycle-accurate mode, user space only.</li> <li><code>--filter 'filter f @ ./rdtsc-vs-intel-pt'</code> specifies an address filter to trace only f()</li> <li><code>./rdtsc-vs-intel-pt</code> is the workload.</li> </ul> <pre><code>$ perf record -e intel_pt/cyc/u --filter 'filter f @ ./rdtsc-vs-intel-pt' ./rdtsc-vs-intel-pt\n                   rdtsc with no ordering, measured f() time: 26 TSC ticks\n           rdtscp with no ordering before, measured f() time: 73 TSC ticks\n                     rdtscp with ordering, measured f() time: 47 TSC ticks\n                      rdtsc with ordering, measured f() time: 47 TSC ticks\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.015 MB ]\n</code></pre> <pre><code>$ perf script --itrace=bep --ns -F+ipc,-period,-dso,-comm,+flags,+addr,-pid,-tid\n[000] 12434.509024343:            psb:                          psb offs: 0                                     0                0 [unknown]\n[000] 12434.509024343:            cbr:                          cbr: 42 freq: 4219 MHz (156%)                   0                0 [unknown]\n[000] 12434.509252555:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f45b77032f0 f+0x0\n[000] 12434.509252568:    branches:uH:   tr end  return             7f45b770330f f+0x1f =&gt;     7f45b77030b3 main+0x13    IPC: 0.12 (7/54) \n[000] 12434.509252568:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f45b77032f0 f+0x0\n[000] 12434.509252570:    branches:uH:   tr end  return             7f45b770330f f+0x1f =&gt;     7f45b77030b8 main+0x18    IPC: 0.87 (7/8) \n[000] 12434.509252571:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f45b77032f0 f+0x0\n[000] 12434.509252572:    branches:uH:   tr end  return             7f45b770330f f+0x1f =&gt;     7f45b77030c8 main+0x28    IPC: 1.75 (7/4) \n[000] 12434.509306045:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f45b77032f0 f+0x0\n[000] 12434.509306065:    branches:uH:   tr end  return             7f45b770330f f+0x1f =&gt;     7f45b7703104 main+0x64    IPC: 0.08 (7/81) \n[000] 12434.509307757:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f45b77032f0 f+0x0\n[000] 12434.509307763:    branches:uH:   tr end  return             7f45b770330f f+0x1f =&gt;     7f45b7703144 main+0xa4    IPC: 0.28 (7/25) \n[000] 12434.509308965:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f45b77032f0 f+0x0\n[000] 12434.509308970:    branches:uH:   tr end  return             7f45b770330f f+0x1f =&gt;     7f45b7703183 main+0xe3    IPC: 0.31 (7/22) \n</code></pre> <p>The trace shows the CPU, timestamp in nanoseconds, and event information: \"psb\" is the Intel PT synchronization event. \"cbr\" (core-to-bus ratio) shows the CPU frequency. The \"branches\" events show the 6 invocations of f() as:</p> <ul> <li>entry to f() \"0 [unknown] =&gt;     7f45b77032f0 f+0x0\" (Note the offset is 0 i.e. the start of f())</li> <li>return from f() \"7f45b770330f f+0x1f =&gt;     7f45b77030b3 main+0x13\"</li> </ul> <p>Branches are annotated with IPC (instructions-per-cpu-cycle) information.  The number of instructions is always 7.  The number of CPU cycles varies. Note that the frequency of CPU cycles changes whereas the TSC frequency (2712 MHz in this case) is constant.</p> <p>But the times are much smaller when traced with Intel PT, so what happened.  Let's add a 1 second sleep by passing 1 as the first parameter:</p> <pre><code>$ perf record -e intel_pt/cyc/u --filter 'filter f @ ./rdtsc-vs-intel-pt' ./rdtsc-vs-intel-pt 1\n                   rdtsc with no ordering, measured f() time: 359 TSC ticks\n           rdtscp with no ordering before, measured f() time: 234 TSC ticks\n                     rdtscp with ordering, measured f() time: 184 TSC ticks\n                      rdtsc with ordering, measured f() time: 193 TSC ticks\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.123 MB perf.data ]\n$ perf script --itrace=bep --ns -F+ipc,-period,-dso,-comm,+flags,+addr,-pid,-tid\n[005] 12915.734605958:            psb:                          psb offs: 0                                     0                0 [unknown]\n[005] 12915.734605958:            cbr:                          cbr: 42 freq: 4219 MHz (156%)                   0                0 [unknown]\n[005] 12916.735108407:            cbr:                          cbr: 12 freq: 1205 MHz ( 44%)                   0                0 [unknown]\n[005] 12916.735120793:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f67047c42f0 f+0x0\n[005] 12916.735120937:    branches:uH:   tr end  return             7f67047c430f f+0x1f =&gt;     7f67047c40b3 main+0x13    IPC: 0.04 (7/173) \n[005] 12916.735120938:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f67047c42f0 f+0x0\n[005] 12916.735120946:    branches:uH:   tr end  return             7f67047c430f f+0x1f =&gt;     7f67047c40b8 main+0x18    IPC: 0.70 (7/10) \n[005] 12916.735120952:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f67047c42f0 f+0x0\n[005] 12916.735120955:    branches:uH:   tr end  return             7f67047c430f f+0x1f =&gt;     7f67047c40c8 main+0x28    IPC: 1.75 (7/4) \n[005] 12916.735338404:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f67047c42f0 f+0x0\n[005] 12916.735338465:    branches:uH:   tr end  return             7f67047c430f f+0x1f =&gt;     7f67047c4104 main+0x64    IPC: 0.09 (7/73) \n[005] 12916.735344207:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f67047c42f0 f+0x0\n[005] 12916.735344233:    branches:uH:   tr end  return             7f67047c430f f+0x1f =&gt;     7f67047c4144 main+0xa4    IPC: 0.22 (7/31) \n[005] 12916.735348485:    branches:uH:   tr strt                               0 [unknown] =&gt;     7f67047c42f0 f+0x0\n[005] 12916.735348511:    branches:uH:   tr end  return             7f67047c430f f+0x1f =&gt;     7f67047c4183 main+0xe3    IPC: 0.22 (7/31) \n</code></pre> <p>Now we can see what happened.  The activity of 'perf' resulted in the CPU frequency increasing to 4219 MHz.  When the program went to sleep, the frequency dropped to 1205 MHz and the TSC timings went back up.</p> <p>This shows a powerful feature of Intel PT.  Intel PT can show what the CPU frequency actually is.</p> <p>Let's get that output again, but with only what is interesting and using \"--deltatime\" to get the change in time:</p> <pre><code>$ perf script --itrace=bep --ns -F+ipc,-period,-dso,-comm,-pid,-tid,-cpu,-ip,-event --deltatime | grep IPC\n    0.000000144:         IPC: 0.04 (7/173) \n    0.000000008:         IPC: 0.70 (7/10) \n    0.000000003:         IPC: 1.75 (7/4) \n    0.000000061:         IPC: 0.09 (7/73) \n    0.000000026:         IPC: 0.22 (7/31) \n    0.000000026:         IPC: 0.22 (7/31) \n</code></pre> <p>The last 4 correspond to the 4 TSC values, so we have:</p> <pre><code>     ns                                 TSC ticks / ns\n    144         IPC: 0.04 (7/173) \n      8         IPC: 0.70 (7/10) \n      3         IPC: 1.75 (7/4)         359 / 132   rdtsc with no ordering\n     61         IPC: 0.09 (7/73)        234 /  86   rdtscp with no ordering before\n     26         IPC: 0.22 (7/31)        184 /  68   rdtscp with ordering\n     26         IPC: 0.22 (7/31)        193 /  71   rdtsc with ordering\n</code></pre> <p>\"rdtsc with no ordering\" at 132ns does not match Intel PT result of 3ns at all.  \"rdtscp with ordering\" and \"rdtsc with ordering\" seem about the same.</p> <p>However the presence of TSC overhead is clearly visible.  Perhaps around 50ns in this case.  That isn't bad, but Intel PT seems the winner in this case.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-using-ptwrite-to-measure-the-time-of-an-individual-instruction","title":"Example: Using PTWRITE to measure the time of an individual instruction","text":"<p>In \"Example: rdtsc vs Intel PT\" above, it was seen how Intel PT can be used to measure the time of a function.</p> <p>In general it is not possible to measure the time of an individual instruction with Intel PT, but with some changes to the program code and using the PTWRITE instruction, it can be done.</p> <p>Some Atom and Hybrid CPUs support PTWRITE.  To check:</p> <pre><code># cat /sys/bus/event_source/devices/intel_pt/caps/ptwrite\n1\n</code></pre> <p>1 means PTWRITE is supported, 0 (or no file at all) means not supported.</p> <p>The reason for using PTWRITE is that it produces a CYC-eligible Intel PT packet which means we know the cycle count at that point.  Sandwich an instruction between 2 PTWRITE instructions and we can see how long that instruction took.</p> <p>Let's measure the time of xsave and xrestore instructions in the Linux kernel.</p> <p>First patch the kernel to insert PTWRITE instruction's in the right places. For this, the instruction used is \"ptwrite (%rsp)\" because it will always work and we don't care what the PTWRITE payload value is.</p> <p>Here is the patch diff:</p> <pre><code>diff --git a/arch/x86/kernel/fpu/xstate.h b/arch/x86/kernel/fpu/xstate.h\nindex d22ace092ca2..87b192548621 100644\n--- a/arch/x86/kernel/fpu/xstate.h\n+++ b/arch/x86/kernel/fpu/xstate.h\n@@ -83,14 +83,19 @@ static inline u64 xfeatures_mask_independent(void)\n #define XRSTOR     \".byte \" REX_PREFIX \"0x0f,0xae,0x2f\"\n #define XRSTORS        \".byte \" REX_PREFIX \"0x0f,0xc7,0x1f\"\n\n+/* ptwrite (%rsp) */\n+#define PTWRITE        \" .byte 0xf3, 0x48, 0x0f, 0xae, 0x24, 0x24\\n\"\n+\n /*\n  * After this @err contains 0 on success or the trap number when the\n  * operation raises an exception.\n  */\n #define XSTATE_OP(op, st, lmask, hmask, err)               \\\n-   asm volatile(\"1:\" op \"\\n\\t\"                 \\\n+   asm volatile(PTWRITE                        \\\n+            \"1:\" op \"\\n\\t\"                 \\\n             \"xor %[err], %[err]\\n\"             \\\n             \"2:\\n\\t\"                       \\\n+            PTWRITE                        \\\n             _ASM_EXTABLE_TYPE(1b, 2b, EX_TYPE_FAULT_MCE_SAFE)  \\\n             : [err] \"=a\" (err)                 \\\n             : \"D\" (st), \"m\" (*st), \"a\" (lmask), \"d\" (hmask)    \\\n@@ -111,12 +116,14 @@ static inline u64 xfeatures_mask_independent(void)\n  * address of the instruction where we might get an exception at.\n  */\n #define XSTATE_XSAVE(st, lmask, hmask, err)                \\\n-   asm volatile(ALTERNATIVE_2(XSAVE,               \\\n+   asm volatile(PTWRITE                        \\\n+            ALTERNATIVE_2(XSAVE,               \\\n                   XSAVEOPT, X86_FEATURE_XSAVEOPT,  \\\n                   XSAVES,   X86_FEATURE_XSAVES)    \\\n             \"\\n\"                       \\\n             \"xor %[err], %[err]\\n\"             \\\n             \"3:\\n\"                     \\\n+            PTWRITE                        \\\n             _ASM_EXTABLE_TYPE_REG(661b, 3b, EX_TYPE_EFAULT_REG, %[err]) \\\n             : [err] \"=r\" (err)                 \\\n             : \"D\" (st), \"m\" (*st), \"a\" (lmask), \"d\" (hmask)    \\\n@@ -127,10 +134,12 @@ static inline u64 xfeatures_mask_independent(void)\n  * XSAVE area format.\n  */\n #define XSTATE_XRESTORE(st, lmask, hmask)              \\\n-   asm volatile(ALTERNATIVE(XRSTOR,                \\\n+   asm volatile(PTWRITE                        \\\n+            ALTERNATIVE(XRSTOR,                \\\n                 XRSTORS, X86_FEATURE_XSAVES)       \\\n             \"\\n\"                       \\\n             \"3:\\n\"                     \\\n+            PTWRITE                        \\\n             _ASM_EXTABLE_TYPE(661b, 3b, EX_TYPE_FPU_RESTORE)   \\\n             :                          \\\n             : \"D\" (st), \"m\" (*st), \"a\" (lmask), \"d\" (hmask)    \\\n</code></pre> <p>After building and installing the new kernel, we can run a trace:</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-a</code> to trace system wide i.e. all tasks, all CPUs</li> <li><code>--kcore</code> to copy kernel object code from the /proc/kcore image (helps avoid decoding errors due to kernel self-modifying code)</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt/cyc,ptw,fup_on_ptw/k</code> to get Intel PT with cycle-accurate mode, PTWRITE+FUP, kernel space only.</li> <li><code>sh -c 'for i in</code>seq 1 10<code>;do sleep 0.01;done'</code> is the workload.</li> </ul> <pre><code># perf record -a --kcore -e intel_pt/cyc,ptw,fup_on_ptw/k -- sh -c 'for i in `seq 1 10`;do sleep 0.01;done'\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 2.599 MB perf.data ]\n</code></pre> <p>And see the results.</p> <p>Let's see xsaves on CPU 5:</p> <p>We can use <code>perf script</code> with options:</p> <ul> <li><code>--deltatime</code> to show time differences</li> <li><code>--insn-trace</code> to show all instructions</li> <li><code>--xed</code> to disassemble instructions using XED</li> <li><code>-C 5</code> to decode only CPU 5</li> </ul> <p>This shows times varying from 23ns to 163ns</p> <pre><code># perf script --deltatime --insn-trace --xed -C 5 | grep -A 2 xsave\n     migration/5    36 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n     migration/5    36 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n     migration/5    36 [005]     0.000000023:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000031:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000033:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000048:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000121:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000154:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000122:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000148:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000122:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000160:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n--\n         swapper     0 [005]     0.000000000:  ffffffffafea8f04 save_fpregs_to_fpstate+0x44 ([kernel.kallsyms])                 xsaves64 (%rdi)\n         swapper     0 [005]     0.000000000:  ffffffffafea8f08 save_fpregs_to_fpstate+0x48 ([kernel.kallsyms])                 xor %edi, %edi\n         swapper     0 [005]     0.000000163:  ffffffffafea8f0a save_fpregs_to_fpstate+0x4a ([kernel.kallsyms])                 ptwriteq  (%rsp)\n</code></pre> <p>Similarly, let's see xrestores on CPU 5:</p> <p>This shows times varying from 32ns to 855ns</p> <pre><code># perf script --deltatime --insn-trace --xed -C 5 | grep -A 1 xrst\n              sh  1167 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n              sh  1167 [005]     0.000000117:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n           sleep  1167 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n           sleep  1167 [005]     0.000000032:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n              sh  1169 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n              sh  1169 [005]     0.000000095:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n           sleep  1169 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n           sleep  1169 [005]     0.000000047:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n              sh  1170 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n              sh  1170 [005]     0.000000344:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n           sleep  1170 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n           sleep  1170 [005]     0.000000135:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n              sh  1174 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n              sh  1174 [005]     0.000000317:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n           sleep  1174 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n           sleep  1174 [005]     0.000000134:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n              sh  1176 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n              sh  1176 [005]     0.000000855:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n           sleep  1176 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n           sleep  1176 [005]     0.000000536:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n--\n            perf  1164 [005]     0.000000000:  ffffffffafea9072 restore_fpregs_from_fpstate+0x52 ([kernel.kallsyms])            xrstors64 (%rdi)\n            perf  1164 [005]     0.000000198:  ffffffffafea9076 restore_fpregs_from_fpstate+0x56 ([kernel.kallsyms])            ptwriteq  (%rsp)\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-tracing-__schedule","title":"Example: Tracing <code>__schedule()</code>","text":"<p>We want to observe some task switches, so in this example, a kernel compile is started in the background to act as a workload:</p> <pre><code>$ cd ~/git/linux\n$ make -j9 &gt;/dev/null &amp;\n[1] 77175\n</code></pre> <p>This example includes kernel tracing, which requires administrator privileges.</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-Se</code> snapshot mode with a snapshot at the end. This is a way to control the amount of data collected.  The root user default buffer size is 4MiB so with a single snapshot at the end, and 8 CPUs, data is limited to about 32MiB.</li> <li><code>-a</code> to trace system wide i.e. all tasks, all CPUs</li> <li><code>--kcore</code> to copy kernel object code from the /proc/kcore image (helps avoid decoding errors due to kernel self-modifying code)</li> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt/cyc,noretcomp,mtc_period=9/k</code> to get Intel PT with cycle-accurate mode. We add <code>noretcomp</code> to get a Intel PT TIP packet from RET instructions, which has the side-effect of also getting a CYC timing packet, and consequently enables calculating a timestamp at that point.  The <code>mtc_period</code> is set as high as possible because MTC packets are collected continuously which bloats the trace.</li> <li><code>--filter 'filter __schedule'</code> specifies an address filter to trace only __schedule()</li> <li><code>--no-switch-events</code> switch events will divide up __schedule(), so disable them</li> <li><code>--</code> is a separator, indicating that the rest of the options belong to the workload</li> <li><code>sleep 3</code> is the workload.  The tracing will stop when the workload finishes, so this is simply a way of tracing for about 3 seconds.</li> </ul> <pre><code>$ sudo ~/bin/perf record -Se -a --kcore -e intel_pt/cyc,noretcomp,mtc_period=9/k --filter 'filter __schedule' --no-switch-events -- sleep 3\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 34.200 MB perf.data ]\n</code></pre> <p>Don't need the workload anymore so kill it:</p> <pre><code>$ kill %1\n[1]+  Terminated              make -j9 &gt; /dev/null\n</code></pre> <p>Get extra packages for <code>export-to-sqlite.py</code> script:</p> <pre><code>sudo apt-get install sqlite3 python3-pyside2.qtsql libqt5sql5-psql\n</code></pre> <p>Refer to the script [http://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/perf/scripts/python/export-to-sqlite.py export-to-sqlite.py] for more information.</p> <p>Export to SQLite3 database:</p> <pre><code>$ perf script --itrace=be -s export-to-sqlite.py pt.db branches calls\n2022-09-30 16:34:08.522415 Creating database ...\n2022-09-30 16:34:08.526911 Writing records...\nWarning:\n2 instruction trace errors\n2022-09-30 16:34:11.191507 Adding indexes\n2022-09-30 16:34:11.215882 Dropping unused tables\n2022-09-30 16:34:11.230945 Done\n</code></pre> <p>Have a look at the errors.</p> <pre><code>$ perf script --itrace=e\nWarning:\n2 instruction trace errors\n instruction trace error type 1 time 31840.557348019 cpu 4 pid 83275 tid 83275 ip 0xffffffffb43a6c0e code 7: Overflow packet\n instruction trace error type 1 time 31840.557316000 cpu 0 pid 83275 tid 83275 ip 0xffffffffb43a6c0e code 7: Overflow packet\n</code></pre> <p>Overflows are not unexpected, and there are only 2, so they can be ignored in this case.</p> <p>Start the viewer to look at a call graph:</p> <pre><code>$ python3 ~/libexec/perf-core/scripts/python/exported-sql-viewer.py pt.db\n</code></pre> <p>The call graph looks like this:</p> <pre><code>Call Path                            Object     Count   Time (ns)   Time (%)\n\u25bc perf\n  \u25bc 83275:83275\n    \u25bc __schedule                     [kernel]    7013    47684493      100.0\n      \u25b6 rcu_note_context_switch     [kernel]    4773       29498        0.1\n      \u25b6 raw_spin_rq_lock_nested     [kernel]    4773       62676        0.1\n      \u25b6 update_rq_clock             [kernel]    4773       83770        0.2\n      \u25b6 pick_next_task              [kernel]    4773     2129516        4.5\n      \u25b6 psi_task_switch             [kernel]    4719     2336791        4.9\n      \u25b6 prepare_task_switch         [kernel]    4719      288511        0.6\n      \u25b6 enter_lazy_tlb              [kernel]    1117       15066        0.0\n      \u25b6 __switch_to_asm             [kernel]    4719    38735454       81.2\n      \u25b6 finish_task_switch.isra.0   [kernel]    4164     1214343        2.5\n      \u25b6 dequeue_task                [kernel]    2854     1183437        2.5\n      \u25b6 switch_mm_irqs_off          [kernel]    3602      529887        1.1\n      \u25b6 raw_spin_rq_unlock          [kernel]      54         515        0.0\n      \u25b6 asm_sysvec_reschedule_ipi   [kernel]       7        2250        0.0\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-how-to-create-an-application-that-can-trace-itself","title":"Example: How to create an application that can trace itself","text":"<p>An application may be able to detect unexpected conditions that warrent making a trace.  Here is an example of a program that does that:</p> <pre><code>$ cat self-trace-example.c\n#define _GNU_SOURCE\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stddef.h&gt;\n\nstatic char perf_temp_dir[] = \"/tmp/perf-control-XXXXXX\";\nstatic char *perf_control_name;\nstatic char *perf_ack_name;\nstatic char *perf_pid_name;\nstatic int perf_control = -1;\nstatic int perf_ack = -1;\nstatic int perf_pid;\n\nstatic int control_perf(const char *cmd)\n{\n        ssize_t ret;\n        ssize_t sz = strlen(cmd);\n        char buf[16];\n\n        printf(\"sending cmd '%s'\\n\", cmd);\n        ret = write(perf_control, cmd, sz);\n        if (ret != sz)\n                return -1;\n        buf[0] = 0;\n        ret = read(perf_ack, buf, sizeof(buf));\n        if (ret &lt; 0)\n                return ret;\n        if (ret &lt; 4 || strncmp(\"ack\\n\", buf, 4))\n                return -1;\n        printf(\"Ack'ed\\n\");\n        return 0;\n}\n\nstatic int mk_perf_fifo(char *dir_name, char *name, char **fifo_name, int *fd)\n{\n        if (asprintf(fifo_name, \"%s/%s\", dir_name, name) &lt; 0)\n                return -1;\n        mkfifo(*fifo_name, 0600);\n        *fd = open(*fifo_name, O_RDWR);\n        return *fd &lt; 0 ? *fd : 0;\n}\n\nstatic int init_perf(void)\n{\n        char *dir_name;\n        int err;\n\n        dir_name = mkdtemp(perf_temp_dir);\n        if (!dir_name)\n                return -1;\n        if (asprintf(&amp;perf_pid_name, \"%s/perf_pid\", dir_name) &lt; 0)\n                return -1;\n        err = mk_perf_fifo(dir_name, \"perf.control\", &amp;perf_control_name, &amp;perf_control);\n        if (err &lt; 0)\n                return err;\n        return mk_perf_fifo(dir_name, \"perf.ack\", &amp;perf_ack_name, &amp;perf_ack);\n}\n\nstatic int read_perf_pid(void)\n{\n        FILE *f = fopen(perf_pid_name, \"r\");\n\n        return (f &amp;&amp; fscanf(f, \"%d\", &amp;perf_pid) == 1) ? 0 : -1;\n}\n\nstatic void waitfor_perf_pid(void)\n{\n        char buf[256];\n\n        snprintf(buf, sizeof(buf), \"/proc/%d\", perf_pid);\n        while (!access(buf, F_OK))\n                usleep(1000);\n}\n\nstatic int start_perf(void)\n{\n        static bool initialized;\n        char *cmd;\n        int err;\n\n        if (!initialized) {\n                err = init_perf();\n                if (err)\n                        return err;\n                initialized = true;\n        }\n        err = asprintf(&amp;cmd, \"perf record --control fifo:%s,%s -S -e intel_pt//u -p %d &amp; echo $! &gt; %s\", perf_control_name, perf_ack_name, getpid(), perf_pid_name);\n        if (err &lt; 0)\n                return err;\n        printf(\"cmd is '%s'\\n\", cmd);\n        err = system(cmd);\n        free(cmd);\n        if (err)\n                return err;\n        err = control_perf(\"ping\");\n        if (err)\n                return err;\n        return read_perf_pid();\n}\n\n/* noinline so it shows in a call trace */\nstatic __attribute__((noinline)) int perf_snapshot(void)\n{\n        return control_perf(\"snapshot\");\n}\n\nvolatile int dummy_var;\n\n/* noinline so it shows in a call trace */\nstatic __attribute__((noinline)) void work(void)\n{\n        dummy_var += 1; /* Stop work() being optimized away */\n}\n\nint main()\n{\n        int err;\n\n        err = start_perf();\n        if (err)\n                goto out;\n        work();\n        work();\n        work();\n        err = perf_snapshot();\n        if (err)\n                goto out;\n        err = control_perf(\"stop\");\n        if (err)\n                goto out;\n        waitfor_perf_pid();\nout:\n        printf(\"Done, error %d\\n\", err);\n        return 0;\n}\n$ gcc -Wall -Wextra -g -O3 -o self-trace-example self-trace-example.c\n$ ./self-trace-example \ncmd is 'perf record --control fifo:/tmp/perf-control-FgaFCP/perf.control,/tmp/perf-control-FgaFCP/perf.ack -S -e intel_pt//u -p 13341 &amp; echo $! &gt; /tmp/perf-control-FgaFCP/perf_pid'\nsending cmd 'ping'\nAck'ed\nsending cmd 'snapshot'\nAck'ed\nsending cmd 'stop'\nAck'ed\n[ perf record: Woken up 3 times to write data ]\n[ perf record: Captured and wrote 0.015 MB perf.data ]\nDone, error 0\n$ perf script --call-trace\n self-trace-exam 13341 [005] 17238.631440463:  psb offs: 0                      \n self-trace-exam 13341 [005] 17238.631440463:  cbr: 41 freq: 4105 MHz (146%)    \n self-trace-exam 13341 [005] 17238.631448567: (/home/ahunter/git/self-trace-example/self-trace-e )              5617e25ba190            \n self-trace-exam 13341 [005] 17238.631448983: (/home/ahunter/git/self-trace-example/self-trace-e )              5617e25ba1b0            \n self-trace-exam 13341 [005] 17238.631448983: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  7fbbdde28490        \n self-trace-exam 13341 [005] 17238.631449817: (/usr/lib/x86_64-linux-gnu/libc.so.6               )              __strncmp_sse2          \n self-trace-exam 13341 [005] 17238.631449817: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      7fbbdde283e0    \n self-trace-exam 13341 [005] 17238.631450233: (/usr/lib/x86_64-linux-gnu/libc.so.6               )              __memcmpeq_sse2         \n self-trace-exam 13341 [005] 17238.631450442: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __memchr_sse2       \n self-trace-exam 13341 [005] 17238.631450442: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __strcmp_sse2_unaligned                         \n self-trace-exam 13341 [005] 17238.631450442: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                          rcmd_af                                     \n self-trace-exam 13341 [005] 17238.631450442: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                                                      \n self-trace-exam 13341 [005] 17238.631455233: (/home/ahunter/git/self-trace-example/self-trace-e )              5617e25ba280                                            \n self-trace-exam 13341 [005] 17238.631455442: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  7fbbdde28380                                        \n self-trace-exam 13341 [005] 17238.631455858: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  ____wcstold_l_internal                              \n self-trace-exam 13341 [005] 17238.631456275: (/usr/lib/x86_64-linux-gnu/libc.so.6               )              __GI___strcasecmp_l_sse2                                \n self-trace-exam 13341 [005] 17238.631456275: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __GI___strcasecmp_l_sse2                            \n self-trace-exam 13341 [005] 17238.631456275: (/usr/lib/x86_64-linux-gnu/libc.so.6               )              __strncmp_sse2                                          \n self-trace-exam 13341 [005] 17238.631456275: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __memcmp_sse2                                       \n self-trace-exam 13341 [005] 17238.631456275: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __GI___strncasecmp_l_sse2                       \n self-trace-exam 13341 [005] 17238.631456275: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __GI___strncasecmp_l_sse2                       \n self-trace-exam 13341 [005] 17238.631456275: (/usr/lib/x86_64-linux-gnu/libc.so.6               )              __strncmp_sse2                                          \n self-trace-exam 13341 [005] 17238.631456275: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __strncmp_sse2                                      \n self-trace-exam 13341 [005] 17238.631456275: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      rcmd_af                                         \n self-trace-exam 13341 [005] 17238.631456483: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                                                      \n self-trace-exam 13341 [005] 17238.631462317: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __memcmp_sse2                                   \n self-trace-exam 13341 [005] 17238.631462525: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __wcsxfrm_l                                         \n self-trace-exam 13341 [005] 17238.631462525: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                          7fbbdde28600                                \n self-trace-exam 13341 [005] 17238.631462525: (/home/ahunter/git/self-trace-example/self-trace-e )              5617e25ba1a0                                            \n self-trace-exam 13341 [005] 17238.631462733: (/usr/lib/x86_64-linux-gnu/libc.so.6               )              _IO_file_seekoff@@GLIBC_2.2.5                           \n self-trace-exam 13341 [005] 17238.631462942: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __GI___strncasecmp_l_sse2                           \n self-trace-exam 13341 [005] 17238.631463150: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __GI___strcasecmp_l_sse2                            \n self-trace-exam 13341 [005] 17238.631463150: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __memchr_sse2                                   \n self-trace-exam 13341 [005] 17238.631463150: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                          __GI___strcasecmp_l_sse2                    \n self-trace-exam 13341 [005] 17238.631463150: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                              __malloc_usable_size                    \n self-trace-exam 13341 [005] 17238.631463150: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                  __strcmp_sse2_unaligned             \n self-trace-exam 13341 [005] 17238.631463150: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                                                      \n self-trace-exam 13341 [005] 17238.631464400: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                      7fbbdde28380                    \n self-trace-exam 13341 [005] 17238.631464400: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                      ____wcstold_l_internal          \n self-trace-exam 13341 [005] 17238.631464608: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                      ____wcstold_l_internal          \n self-trace-exam 13341 [005] 17238.631466900: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                  __GI___strcasecmp_l_sse2            \n self-trace-exam 13341 [005] 17238.631466900: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                          __memcmpeq_sse2                             \n self-trace-exam 13341 [005] 17238.631466900: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                          __strncmp_sse2                              \n self-trace-exam 13341 [005] 17238.631467108: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                                                      \n self-trace-exam 13341 [005] 17238.631469400: (/usr/lib/x86_64-linux-gnu/libc.so.6               )              _IO_file_xsgetn_mmap                                    \n self-trace-exam 13341 [005] 17238.631471692: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __GI___strcasecmp_l_sse2                            \n self-trace-exam 13341 [005] 17238.631471900: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __GI___strcasecmp_l_sse2                            \n self-trace-exam 13341 [005] 17238.631471900: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __vfwscanf_internal                                 \n self-trace-exam 13341 [005] 17238.631472108: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __GI___strncasecmp_l_sse2                           \n self-trace-exam 13341 [005] 17238.631472317: (/home/ahunter/git/self-trace-example/self-trace-e )          work                        \n self-trace-exam 13341 [005] 17238.631472317: (/home/ahunter/git/self-trace-example/self-trace-e )          work                        \n self-trace-exam 13341 [005] 17238.631472317: (/home/ahunter/git/self-trace-example/self-trace-e )          work                        \n self-trace-exam 13341 [005] 17238.631472317: (/home/ahunter/git/self-trace-example/self-trace-e )          perf_snapshot               \n self-trace-exam 13341 [005] 17238.631472317: (/home/ahunter/git/self-trace-example/self-trace-e )                  5617e25ba1e0        \n self-trace-exam 13341 [005] 17238.631472317: (/home/ahunter/git/self-trace-example/self-trace-e )                  5617e25ba250        \n self-trace-exam 13341 [005] 17238.631472317: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                  __GI___pthread_tpp_change_priority                  \n self-trace-exam 13341 [005] 17238.631472525: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                          7fbbdde284d0                                \n self-trace-exam 13341 [005] 17238.631472525: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __GI___strncasecmp_l_sse2                       \n self-trace-exam 13341 [005] 17238.631472733: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __strncmp_sse2                                  \n self-trace-exam 13341 [005] 17238.631472733: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                              7fbbdde283e0                            \n self-trace-exam 13341 [005] 17238.631472733: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                          7fbbdde28490                                \n self-trace-exam 13341 [005] 17238.631472733: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __strncmp_sse2                                  \n self-trace-exam 13341 [005] 17238.631472733: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                              7fbbdde283e0                            \n self-trace-exam 13341 [005] 17238.631472733: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                          7fbbdde284d0                                \n self-trace-exam 13341 [005] 17238.631472733: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __strncmp_sse2                                  \n self-trace-exam 13341 [005] 17238.631472942: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                              7fbbdde283e0                            \n self-trace-exam 13341 [005] 17238.631472942: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                          __memrchr_sse2                              \n self-trace-exam 13341 [005] 17238.631472942: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                              __strcmp_sse2_unaligned                 \n self-trace-exam 13341 [005] 17238.631472942: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                  rcmd_af                             \n self-trace-exam 13341 [005] 17238.631472942: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                                                      \n self-trace-exam 13341 [005] 17238.631473567: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                      __GI___strncasecmp_l_sse2                       \n self-trace-exam 13341 [005] 17238.631473567: (/home/ahunter/git/self-trace-example/self-trace-e )                  5617e25ba1c0                                        \n self-trace-exam 13341 [005] 17238.631473775: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                                                      \n self-trace-exam 13341 [005] 17238.631475442: (/home/ahunter/git/self-trace-example/self-trace-e )                  5617e25ba210                                        \n self-trace-exam 13341 [005] 17238.631475442: (/usr/lib/x86_64-linux-gnu/libc.so.6               )                                                                      \n$ \n</code></pre> <p>Points to note:</p> <ul> <li>The program is fairly crude and is primarily an example of how to control perf using FIFOs.</li> <li>Snapshot mode (option -S) is used.  To also make a snapshot if the application terminates, the option -Se can be used instead.  Also the Intel PT snapshot size in bytes can be specified e.g. -Se100000</li> <li>Default buffer sizes are used, but that can be changed with the -m option.</li> <li>The program makes a single snapshot then stops perf and waits for it to finish.  The program could instead have made more snapshots and could stop and start a new perf process any time to enable the perf output file to be collected for later analysis or deleted.</li> <li>perf output file name is not specified and so will use (and overwrite) \"perf.data\".</li> <li>Intel PT config terms like mtc_period, psb_period, cyc, cyc_threshold, and noretcomp can affect the Intel PT overhead.</li> </ul>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-how-to-read-perf-clock","title":"Example: How to read perf clock","text":"<p>perf tools can use different clock IDs but Intel PT only supports the default perf clock.  While regular clocks can be read using POSIX clock_gettime() API, perf clock can be calculated from TSC, however the conversion parameters need to be read from a perf event.  This is a little awkward, but does offer the advantage of being a bit faster because it does not have to call into the kernel to get the clock value.  Here is an example:</p> <pre><code>$ cat perf-clock.c\n#include &lt;linux/perf_event.h&gt;\n#include &lt;sys/syscall.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;errno.h&gt;\n\n#define rmb() asm volatile(\"lfence\" ::: \"memory\")\n\nstruct perf_tsc_conversion {\n        __u16 time_shift;\n        __u32 time_mult;\n        __u64 time_zero;\n};\n\nstatic struct perf_tsc_conversion perf_tsc_conversion;\n\nstatic int perf_read_tsc_conversion(const struct perf_event_mmap_page *pc,\n                                    struct perf_tsc_conversion *tc)\n{\n        int cap_user_time_zero;\n        __u32 seq;\n        int i = 0;\n\n        while (1) {\n                seq = pc-&gt;lock;\n                rmb();\n                tc-&gt;time_mult = pc-&gt;time_mult;\n                tc-&gt;time_shift = pc-&gt;time_shift;\n                tc-&gt;time_zero = pc-&gt;time_zero;\n                cap_user_time_zero = pc-&gt;cap_user_time_zero;\n                rmb();\n                if (pc-&gt;lock == seq &amp;&amp; !(seq &amp; 1))\n                        break;\n                if (++i &gt; 10000) {\n                        errno = EINVAL;\n                        return -1;\n                }\n        }\n\n        if (!cap_user_time_zero) {\n                errno = EOPNOTSUPP;\n                return -1;\n        }\n\n        return 0;\n}\n\nstatic int perf_clock_init(void)\n{\n        struct perf_event_attr attr = {\n                .type   = PERF_TYPE_SOFTWARE,\n                .size = sizeof(attr),\n                .config = PERF_COUNT_SW_DUMMY,\n                .disabled = 1,\n                .exclude_kernel = 1,\n                .exclude_hv = 1,\n        };\n        long page_size = sysconf(_SC_PAGE_SIZE);\n        struct perf_event_mmap_page *pc;\n        size_t len;\n        int ret;\n        int fd;\n\n        if (page_size &lt; 0)\n                return -1;\n        fd = syscall(__NR_perf_event_open, &amp;attr, 0, 0, -1, 0);\n        if (fd &lt; 0)\n                return -1;\n        len = page_size * 2;\n        pc = mmap(NULL, len, PROT_READ, MAP_SHARED, fd, 0);\n        close(fd);\n        if (pc == MAP_FAILED)\n                return -1;\n        ret = perf_read_tsc_conversion(pc, &amp;perf_tsc_conversion);\n        munmap(pc, len);\n\n        return ret;\n}\n\nstatic __u64 rdtsc_ordered(void)\n{\n        unsigned int low, high;\n\n        asm volatile(\"rdtscp\" : \"=a\" (low), \"=d\" (high));\n        asm volatile(\"lfence\");\n        return low | ((__u64)high) &lt;&lt; 32;\n}\n\nstatic __u64 tsc_to_perf_time(__u64 cyc, const struct perf_tsc_conversion *tc)\n{\n        __u64 quot, rem;\n\n        quot = cyc &gt;&gt; tc-&gt;time_shift;\n        rem  = cyc &amp; (((__u64)1 &lt;&lt; tc-&gt;time_shift) - 1);\n        return tc-&gt;time_zero + quot * tc-&gt;time_mult +\n               ((rem * tc-&gt;time_mult) &gt;&gt; tc-&gt;time_shift);\n}\n\n__u64 perf_clock(void)\n{\n        return tsc_to_perf_time(rdtsc_ordered(), &amp;perf_tsc_conversion);\n}\n\n#define CNT 4\n\nint main()\n{\n        unsigned long long t[CNT];\n        int i;\n\n        if (perf_clock_init()) {\n                fprintf(stderr, \"Failed!\\n\");\n                return 1;\n        }\n        for (i = 0; i &lt; CNT; i++)\n                t[i] = perf_clock();\n        for (i = 0; i &lt; CNT; i++)\n                printf(\"%llu\\n\", t[i]);\n        return 0;\n}\n$ gcc -Wall -Wextra -o perf-clock perf-clock.c \n$ ./perf-clock \n2411326242381\n2411326242491\n2411326242570\n2411326242648\n$ \n</code></pre> <p>Points to note:</p> <ul> <li>For systems that support Intel PT, the conversion parameters should not change while the system is running.  Notable exceptions are Hibernation (because it actually involves a reboot), and inside a Virtual Machine (because TSC might be virtualized).</li> </ul>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-tracing-kernel-raw-spin-locks","title":"Example: Tracing kernel raw spin locks","text":"<p>In a v6.2 kernel, the raw spin lock functions are conveniently together:</p> <pre><code>$ sudo cat /proc/kallsyms | sort | grep -C30 ' _raw_spin_lock' \nffffffffacd2e940 t native_safe_halt\nffffffffacd2e960 t __pfx_native_halt\nffffffffacd2e970 t native_halt\nffffffffacd2e990 t __pfx_cpu_idle_poll.isra.0\nffffffffacd2e9a0 t cpu_idle_poll.isra.0\nffffffffacd2eaa0 T __pfx_default_idle_call\nffffffffacd2eab0 T default_idle_call\nffffffffacd2ebb0 t __pfx_intel_idle_s2idle\nffffffffacd2ebc0 t intel_idle_s2idle\nffffffffacd2ec40 t __pfx_intel_idle_xstate\nffffffffacd2ec50 t intel_idle_xstate\nffffffffacd2eca0 t __pfx_intel_idle_irq\nffffffffacd2ecb0 t intel_idle_irq\nffffffffacd2ed10 t __pfx_intel_idle\nffffffffacd2ed20 t intel_idle\nffffffffacd2ed70 t __pfx_intel_idle_ibrs\nffffffffacd2ed80 t intel_idle_ibrs\nffffffffacd2ee40 t __pfx_acpi_idle_do_entry\nffffffffacd2ee50 t acpi_idle_do_entry\nffffffffacd2eeb0 t __pfx_acpi_idle_enter_bm\nffffffffacd2eec0 t acpi_idle_enter_bm\nffffffffacd2f0c0 t __pfx_acpi_idle_enter\nffffffffacd2f0d0 t acpi_idle_enter\nffffffffacd2f240 t __pfx_acpi_idle_enter_s2idle\nffffffffacd2f250 t acpi_idle_enter_s2idle\nffffffffacd2f330 t __pfx_poll_idle\nffffffffacd2f340 t poll_idle\nffffffffacd2f3fa T __cpuidle_text_end\nffffffffacd2f400 T __lock_text_start\nffffffffacd2f400 T __pfx__raw_spin_lock_irqsave\nffffffffacd2f410 T _raw_spin_lock_irqsave\nffffffffacd2f470 T __pfx__raw_spin_trylock\nffffffffacd2f480 T _raw_spin_trylock\nffffffffacd2f4e0 T __pfx__raw_spin_unlock_irqrestore\nffffffffacd2f4f0 T _raw_spin_unlock_irqrestore\nffffffffacd2f540 T __pfx__raw_read_trylock\nffffffffacd2f550 T _raw_read_trylock\nffffffffacd2f5c0 T __pfx__raw_write_trylock\nffffffffacd2f5d0 T _raw_write_trylock\nffffffffacd2f630 T __pfx__raw_read_unlock\nffffffffacd2f640 T _raw_read_unlock\nffffffffacd2f680 T __pfx__raw_write_unlock\nffffffffacd2f690 T _raw_write_unlock\nffffffffacd2f6c0 T __pfx__raw_read_unlock_irq\nffffffffacd2f6d0 T _raw_read_unlock_irq\nffffffffacd2f710 T __pfx__raw_write_unlock_irq\nffffffffacd2f720 T _raw_write_unlock_irq\nffffffffacd2f760 T __pfx__raw_read_unlock_irqrestore\nffffffffacd2f770 T _raw_read_unlock_irqrestore\nffffffffacd2f7c0 T __pfx__raw_write_unlock_irqrestore\nffffffffacd2f7d0 T _raw_write_unlock_irqrestore\nffffffffacd2f810 T __pfx__raw_read_unlock_bh\nffffffffacd2f820 T _raw_read_unlock_bh\nffffffffacd2f840 T __pfx__raw_write_unlock_bh\nffffffffacd2f850 T _raw_write_unlock_bh\nffffffffacd2f870 T __pfx__raw_read_lock_irqsave\nffffffffacd2f880 T _raw_read_lock_irqsave\nffffffffacd2f8e0 T __pfx__raw_write_lock_irqsave\nffffffffacd2f8f0 T _raw_write_lock_irqsave\nffffffffacd2f950 T __pfx__raw_spin_trylock_bh\nffffffffacd2f960 T _raw_spin_trylock_bh\nffffffffacd2f9b0 T __pfx__raw_write_lock\nffffffffacd2f9c0 T _raw_write_lock\nffffffffacd2fa00 T __pfx__raw_read_lock\nffffffffacd2fa10 T _raw_read_lock\nffffffffacd2fa50 T __pfx__raw_read_lock_bh\nffffffffacd2fa60 T _raw_read_lock_bh\nffffffffacd2faa0 T __pfx__raw_write_lock_bh\nffffffffacd2fab0 T _raw_write_lock_bh\nffffffffacd2faf0 T __pfx__raw_write_lock_nested\nffffffffacd2fb00 T _raw_write_lock_nested\nffffffffacd2fb40 T __pfx__raw_read_lock_irq\nffffffffacd2fb50 T _raw_read_lock_irq\nffffffffacd2fb90 T __pfx__raw_write_lock_irq\nffffffffacd2fba0 T _raw_write_lock_irq\nffffffffacd2fbe0 T __pfx__raw_spin_lock\nffffffffacd2fbf0 T _raw_spin_lock\nffffffffacd2fc30 T __pfx__raw_spin_lock_bh\nffffffffacd2fc40 T _raw_spin_lock_bh\nffffffffacd2fc80 T __pfx__raw_spin_lock_irq\nffffffffacd2fc90 T _raw_spin_lock_irq\nffffffffacd2fce0 T __pfx__raw_spin_unlock_bh\nffffffffacd2fcf0 T _raw_spin_unlock_bh\nffffffffacd2fd10 T __pfx__raw_spin_unlock\nffffffffacd2fd20 T _raw_spin_unlock\nffffffffacd2fd60 T __pfx__raw_spin_unlock_irq\nffffffffacd2fd70 T _raw_spin_unlock_irq\nffffffffacd2fdb0 T __pfx___raw_callee_save___pv_queued_spin_unlock_slowpath\nffffffffacd2fdc0 T __raw_callee_save___pv_queued_spin_unlock_slowpath\nffffffffacd2fdf0 T __pfx___raw_callee_save___pv_queued_spin_unlock\nffffffffacd2fe00 T __raw_callee_save___pv_queued_spin_unlock\nffffffffacd2fe1a t .slowpath\nffffffffacd2fe30 T __pfx_native_queued_spin_lock_slowpath\nffffffffacd2fe40 T native_queued_spin_lock_slowpath\nffffffffacd30160 T __pfx___pv_queued_spin_lock_slowpath\nffffffffacd30170 T __pv_queued_spin_lock_slowpath\nffffffffacd30530 T __pfx___pv_queued_spin_unlock_slowpath\nffffffffacd30540 T __pv_queued_spin_unlock_slowpath\nffffffffacd306c0 T __pfx_queued_read_lock_slowpath\nffffffffacd306d0 T queued_read_lock_slowpath\nffffffffacd30800 T __pfx_queued_write_lock_slowpath\nffffffffacd30810 T queued_write_lock_slowpath\nffffffffacd30942 T __lock_text_end\nffffffffacd30950 T __kprobes_text_end\nffffffffacd30950 T __kprobes_text_start\nffffffffacd30950 T __pfx___do_softirq\nffffffffacd30950 T __softirqentry_text_start\nffffffffacd30960 T __do_softirq\nffffffffacd30ccd T __indirect_thunk_start\nffffffffacd30ccd T __softirqentry_text_end\nffffffffacd30ce0 T __x86_indirect_thunk_array\n</code></pre> <p>So an address filter can be used from <code>__lock_text_start</code> to <code>__lock_text_end</code>.</p> <p>For this example, fio will be used as a workload, with a runtime of just 1 second:</p> <pre><code>$ cat fio-rand-read.fio \n[global]\nname=fio-rand-read\nfilename=fio-read\nallow_file_create=0\nrw=randread\nbs=4K\ndirect=1\nnumjobs=8\ntime_based=1\nruntime=1\ngroup_reporting=1\n\n[file1]\nsize=1G\nioengine=libaio\niodepth=128\n</code></pre> <p>To reduce overflows, the mtc_period is increased to maximum (9 in this case), and to get accurate timing, cycle accurate mode is used.</p> <p>The NMI handler (asm_exc_nmi in this case) is also traced to see if there are NMIs during the spin locking.</p> <p>And the lock contention trace points are added to show up lock contention.</p> <pre><code>$ sudo perf record --kcore -a  -e intel_pt/cyc,mtc_period=9/k --filter 'filter __lock_text_start / __lock_text_end , filter asm_exc_nmi' -e lock:*  -- fio ./fio-rand-read.fio \nfile1: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=libaio, iodepth=128\n...\nfio-3.28\nStarting 4 processes\nJobs: 4 (f=4)\nfile1: (groupid=0, jobs=4): err= 0: pid=9051: Sun Apr  2 13:29:59 2023\n  read: IOPS=92.7k, BW=362MiB/s (380MB/s)(365MiB/1007msec)\n    slat (nsec): min=945, max=183448, avg=1376.99, stdev=1321.13\n    clat (usec): min=734, max=13668, avg=5512.61, stdev=891.87\n     lat (usec): min=739, max=13670, avg=5514.05, stdev=891.74\n    clat percentiles (usec):\n     |  1.00th=[ 2868],  5.00th=[ 4293], 10.00th=[ 4621], 20.00th=[ 4883],\n     | 30.00th=[ 5145], 40.00th=[ 5276], 50.00th=[ 5473], 60.00th=[ 5669],\n     | 70.00th=[ 5866], 80.00th=[ 6128], 90.00th=[ 6521], 95.00th=[ 6915],\n     | 99.00th=[ 7767], 99.50th=[ 8356], 99.90th=[11076], 99.95th=[11731],\n     | 99.99th=[12649]\n   bw (  KiB/s): min=370784, max=372152, per=100.00%, avg=371468.00, stdev=233.09, samples=8\n   iops        : min=92696, max=93038, avg=92867.00, stdev=58.27, samples=8\n  lat (usec)   : 750=0.01%, 1000=0.02%\n  lat (msec)   : 2=0.31%, 4=2.55%, 10=96.93%, 20=0.19%\n  cpu          : usr=1.99%, sys=6.98%, ctx=84145, majf=0, minf=564\n  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=0.1%, &gt;=64=99.7%\n     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%\n     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.1%\n     issued rwts: total=93375,0,0,0 short=0,0,0,0 dropped=0,0,0,0\n     latency   : target=0, window=0, percentile=100.00%, depth=128\n\nRun status group 0 (all jobs):\n   READ: bw=362MiB/s (380MB/s), 362MiB/s-362MiB/s (380MB/s-380MB/s), io=365MiB (382MB), run=1007-1007msec\n\nDisk stats (read/write):\n  nvme0n1: ios=83164/0, merge=0/0, ticks=456685/0, in_queue=456685, util=89.88%\n[ perf record: Woken up 147 times to write data ]\n[ perf record: Captured and wrote 109.608 MB perf.data ]\n</code></pre> <p>In this case 109 MB of data is manageable to process.</p> <p>Check the errors:</p> <pre><code>$ sudo perf script --itrace=e | grep error\n instruction trace error type 1 time 17126.002595342 cpu 0 pid 0 tid 0 ip 0xffffffffabdb5ac5 code 7: Overflow packet\n instruction trace error type 1 time 17126.203301006 cpu 7 pid 0 tid 0 ip 0xffffffffabdb5944 code 7: Overflow packet\n instruction trace error type 1 time 17126.240656254 cpu 4 pid 0 tid 0 ip 0xffffffffabdb5944 code 7: Overflow packet\n instruction trace error type 1 time 17126.394446279 cpu 5 pid 0 tid 0 ip 0xffffffffabdb5944 code 7: Overflow packet\n instruction trace error type 1 time 17126.424700733 cpu 5 pid 0 tid 0 ip 0xffffffffabdb5944 code 7: Overflow packet\n instruction trace error type 1 time 17126.615614220 cpu 7 pid 82 tid 82 ip 0xffffffffacc7597e code 7: Overflow packet\n instruction trace error type 1 time 17126.788347553 cpu 5 pid 1115 tid 1320 ip 0xffffffffc062f8c2 code 7: Overflow packet\n instruction trace error type 1 time 17126.863253778 cpu 0 pid 0 tid 0 ip 0xffffffffabdb5944 code 7: Overflow packet\n instruction trace error type 1 time 17126.906410486 cpu 2 pid 0 tid 0 ip 0xffffffffabdb5944 code 7: Overflow packet\n instruction trace error type 1 time 17127.091705727 cpu 2 pid 0 tid 0 ip 0xffffffffabdb5944 code 7: Overflow packet\nWarning:\n10 instruction trace errors\n$\n</code></pre> <p>All the errors are overflows.  The overflows represent small losses of trace data, so we are not seeing a perfect picture, however overflows clear fast (e.g. 10us) so it is not too bad.</p> <p>Because spin lock functions run to completion on the same CPU, a relatively simple script can be used to analyze the times:</p> <pre><code>from perf_trace_context import perf_set_itrace_options\n\nglb_last = {}\nglb_data = []\nglb_count = 0\n\ndef get_optional(perf_dict, field, dflt):\n    if field in perf_dict:\n        return perf_dict[field]\n    return dflt\n\ndef process_event(param_dict):\n    name = param_dict[\"ev_name\"]\n    if name[0:8] != \"branches\":\n        return\n    sample      = param_dict[\"sample\"]\n    flags       = get_optional(sample, \"flags\", \"\")\n    addr_symbol = get_optional(sample, \"addr_symbol\", \"[unknown]\")\n    addr_symoff = get_optional(sample, \"addr_symoff\", \"[unknown]\")\n    symbol      = get_optional(param_dict, \"symbol\", \"[unknown]\")\n    ts          = sample[\"time\"]\n    cpu         = sample[\"cpu\"]\n    if \"B\" in flags and addr_symoff == 0:\n        # Address filter beginning trace, so record call information\n        glb_last[cpu] = (ts, addr_symbol)\n    elif \"E\" in flags and \"r\" in flags and cpu in glb_last:\n        call_ts, call_sym = glb_last[cpu]\n        if call_sym == symbol:\n            # Address filter ending trace, so record return information\n            glb_data.append((cpu, call_ts, ts, symbol, addr_symbol, addr_symoff))\n            del glb_last[cpu]\n    global glb_count\n    glb_count += 1\n    if glb_count % 100000 == 0:\n        print(\"\\rProcessed\", glb_count, end = \"\")\n\ndef trace_begin():\n    perf_set_itrace_options(perf_script_context, \"be\")\n\ndef timestamp(x):\n    s = str(x)\n    r = s[-9:]\n    l = s[:len(s) - len(r)]\n    if len(l):\n        return l + \".\" + (\"000000000\" + r)[-9:]\n    return \"0.\" + (\"000000000\" + r)[-9:]\n\ndef trace_end():\n    print(\"\\rProcessed\", glb_count)\n    print(\"Aggregating...\")\n    syms = {}\n    least = 0\n    topn = []\n    N = 10\n    # Aggregate by symbol\n    for cpu, call_ts, ret_ts, symbol, from_sym, from_symoff in glb_data:\n        if symbol not in syms:\n            syms[symbol] = (0, 0, 0, -1)\n        tot, cnt, max, min = syms[symbol]\n        dur = ret_ts - call_ts\n        tot += dur\n        cnt += 1\n        if dur &gt; max:\n            max = dur\n        if min == -1 or dur &lt; min:\n            min = dur\n        syms[symbol] = (tot, cnt, max, min)\n        if dur &gt; least:\n            topn.append((dur, cpu, call_ts, ret_ts, symbol, from_sym, from_symoff))\n            topn = sorted(topn, key=lambda x: x[0])\n            n = len(topn)\n            if n &gt; N:\n                del topn[0]\n            least = topn[0][0]\n    print(\"\\nFunction duration:\")\n    print(\"Symbol                                        Count     Avg (ns)   Max (ns)   Min (ns)\")\n    for x in sorted(syms.keys()):\n        tot, cnt, max, min = syms[x]\n        print(\"%-40s %10u %12.1f %10u %10u\" % (x, cnt, tot / cnt, max, min))\n    print(\"\\nTop\", N, \":\")\n    print(\"Symbol                                Duration (ns)  CPU            Start              End  Returns to\")\n    topn.reverse()\n    for d in topn:\n        dur, cpu, call_ts, ret_ts, symbol, from_sym, from_symoff = d\n        call_ts = str(call_ts)\n        call_ts = call_ts\n        print(\"%-40s %10u %4u %16s %16s  %s+%#x\" % (symbol, dur, cpu, timestamp(call_ts), timestamp(ret_ts), from_sym, from_symoff))\n\ndef auxtrace_error(typ, code, cpu, pid, tid, ip, ts, msg, cpumode, *x):\n    if cpu in glb_last:\n        del glb_last[cpu]\n</code></pre> <p>The results are:</p> <pre><code>$ time sudo perf script fn-durations.py \nProcessedWarning:0\n10 instruction trace errors\nProcessed 15804761\nAggregating...\n\nFunction duration:\nSymbol                                        Count     Avg (ns)   Max (ns)   Min (ns)\n_raw_read_lock                               242755         23.2      14119          8\n_raw_read_lock_bh                                60         35.5        140          8\n_raw_read_lock_irqsave                          122         45.5        338          7\n_raw_read_unlock                             242778          8.2       2050          5\n_raw_read_unlock_irqrestore                     122         10.5        113          5\n_raw_spin_lock                               767672         11.8      19064          4\n_raw_spin_lock_bh                                62         19.6        135          9\n_raw_spin_lock_irq                            36660         15.7       2467          5\n_raw_spin_lock_irqsave                       808035         15.5      93655          6\n_raw_spin_trylock                             32357         11.2       1371          5\n_raw_spin_unlock                             799630          3.9       1946          1\n_raw_spin_unlock_irq                          31435          5.8        506          2\n_raw_spin_unlock_irqrestore                  813481          4.6       3790          1\n_raw_write_lock                               26842         11.8        266          7\n_raw_write_lock_bh                               34         15.2         42          6\n_raw_write_lock_irq                             175         26.7        354          9\n_raw_write_unlock                             26841          3.3        289          1\n_raw_write_unlock_irq                           177          6.7        194          2\n\nTop 10 :\nSymbol                                Duration (ns)  CPU            Start              End  Returns to\n_raw_spin_lock_irqsave                        93655    5  17127.007313673  17127.007407328  fwtable_write32+0x63\n_raw_spin_lock                                19064    2  17126.745592947  17126.745612011  tick_do_update_jiffies64+0x25\n_raw_spin_lock                                14544    1  17127.151604551  17127.151619095  __queue_work+0x18c\n_raw_spin_lock                                14363    1  17127.087603311  17127.087617674  handle_irq_event+0x51\n_raw_spin_lock                                14123    5  17127.084610854  17127.084624977  raw_spin_rq_lock_nested+0x23\n_raw_read_lock                                14119    2  17127.085605857  17127.085619976  ext4_es_lookup_extent+0x55\n_raw_spin_lock_irqsave                        13484    1  17127.073606372  17127.073619856  hrtimer_next_event_without+0x43\n_raw_spin_lock                                11660    4  17126.615990730  17126.616002390  handle_edge_irq+0x1f\n_raw_spin_lock_irqsave                        11256    0  17126.014614808  17126.014626064  hrtimer_get_next_event+0x3e\n_raw_spin_lock                                 9598    1  17126.617729578  17126.617739176  handle_edge_irq+0x1f\n\nreal    1m50.786s\nuser    0m0.005s\nsys     0m0.012s\n</code></pre> <p>Note the processing of 109 MB took nearly 2 minutes.</p> <p>The average lock times are very low, and consequently not very interesting.</p> <p>To look at the worst case:</p> <pre><code>$ sudo perf script --itrace=crpe -F+flags,-dso,+addr,-comm,-tid,-period --ns  --time 17127.007313673,17127.007407328 -C 5\n[005] 17127.007313673:                         cbr:                          cbr: 41 freq: 4105 MHz (146%)    ffffffffacd2f410                0 [unknown]\n[005] 17127.007313673:                  branches:k:   tr strt                               0 [unknown] =&gt; ffffffffacd2f410 _raw_spin_lock_irqsave+0x0\n[005] 17127.007313675:                  branches:k:   tr end  call           ffffffffacd2f433 _raw_spin_lock_irqsave+0x23 =&gt; ffffffffabd168b0 preempt_count_add+0x0\n[005] 17127.007313677:                  branches:k:   tr strt                               0 [unknown] =&gt; ffffffffacd2f438 _raw_spin_lock_irqsave+0x28\n[005] 17127.007313709:                  branches:k:   call                   ffffffffacd2f455 _raw_spin_lock_irqsave+0x45 =&gt; ffffffffacd2fe40 native_queued_spin_lock_slowpath+0x0\n[005] 17127.007407328:                  branches:k:   return                 ffffffffacd2fed1 native_queued_spin_lock_slowpath+0x91 =&gt; ffffffffacd2f45a _raw_spin_lock_irqsave+0x4a\n[005] 17127.007407328:                  branches:k:   tr end  return         ffffffffacd2f461 _raw_spin_lock_irqsave+0x51 =&gt; ffffffffc07ed873 fwtable_write32+0x63\n</code></pre> <p>The call to native_queued_spin_lock_slowpath() indicates a contended spin lock.  Interestingly, the lock contention tracepoint is missing in the case.  A review of the source code of queued_spin_lock_slowpath() shows why: the tracepoints are only triggered in the \"queue:\" path.  Checking the address shows it spinning instead here when the \"queue:\" path has not been taken:</p> <pre><code>    /*\n     * We're pending, wait for the owner to go away.\n     *\n     * 0,1,1 -&gt; 0,1,0\n     *\n     * this wait loop must be a load-acquire such that we match the\n     * store-release that clears the locked bit and create lock\n     * sequentiality; this is because not all\n     * clear_pending_set_locked() implementations imply full\n     * barriers.\n     */\n    if (val &amp; _Q_LOCKED_MASK)\n        atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_MASK));\n</code></pre> <p>A look at the next worst case shows it was interrupted by an NMI:</p> <pre><code>$ sudo perf script --itrace=crpe -F+flags,-dso,+addr,-comm,-tid,-period --ns  --time 17126.745592947,17126.745612011 -C 2\n[002] 17126.745592947:                         cbr:                          cbr:  4 freq:  400 MHz ( 14%)    ffffffffacd2fbf0                0 [unknown]\n[002] 17126.745592947:                  branches:k:   tr strt                               0 [unknown] =&gt; ffffffffacd2fbf0 _raw_spin_lock+0x0\n[002] 17126.745592952:                  branches:k:   tr end  call           ffffffffacd2fc02 _raw_spin_lock+0x12 =&gt; ffffffffabd168b0 preempt_count_add+0x0\n[002] 17126.745592957:                  branches:k:   tr strt                               0 [unknown] =&gt; ffffffffacd2fc07 _raw_spin_lock+0x17\n[002] 17126.745594638:                         psb:                          psb offs: 0x800190                              0 ffffffffacd2fc12 _raw_spin_lock+0x22\n[002] 17126.745596360:                  branches:k:   hw int                 ffffffffacd2fc12 _raw_spin_lock+0x22 =&gt; fffffffface01cd0 asm_exc_nmi+0x0\n[002] 17126.745596430:                  branches:k:   tr end  jcc            fffffffface01df4 first_nmi+0x0 =&gt; fffffffface01df4 first_nmi+0x0\n[002] 17126.745611938:                  branches:k:   tr strt                               0 [unknown] =&gt; ffffffffacd2fc12 _raw_spin_lock+0x22\n[002] 17126.745612011:                  branches:k:   tr end\n</code></pre> <p>A look at the next worst case shows it was undergoing a change in CPU frequency from 400 MHz to 1301 MHz:</p> <pre><code>$ sudo perf script --itrace=crpe -F+flags,-dso,+addr,-comm,-tid,-period --ns  --time 17127.151604551,17127.151619095 -C 1\n[001] 17127.151604551:                         cbr:                          cbr:  4 freq:  400 MHz ( 14%)    ffffffffacd2fbf0                0 [unknown]\n[001] 17127.151604551:                  branches:k:   tr strt                               0 [unknown] =&gt; ffffffffacd2fbf0 _raw_spin_lock+0x0\n[001] 17127.151604581:                  branches:k:   tr end  call           ffffffffacd2fc02 _raw_spin_lock+0x12 =&gt; ffffffffabd168b0 preempt_count_add+0x0\n[001] 17127.151604618:                  branches:k:   tr strt                               0 [unknown] =&gt; ffffffffacd2fc07 _raw_spin_lock+0x17\n[001] 17127.151612757:                         cbr:   call                   cbr: 13 freq: 1301 MHz ( 46%)                   0 ffffffffacd2fc07 _raw_spin_lock+0x17\n[001] 17127.151619095:                  branches:k:   tr end  return         ffffffffacd2fc15 _raw_spin_lock+0x25 =&gt; ffffffffabcf900c __queue_work+0x18c\n</code></pre> <p>A look at the next worst case shows it really did take that long:</p> <pre><code>$ sudo perf script --itrace=bpe -F+flags,-dso,+addr,-comm,-tid,-period --ns  --time 17127.087603311,17127.087617674\n[001] 17127.087603311:                         cbr:                          cbr: 41 freq: 4105 MHz (146%)    ffffffffacd2fbf0                0 [unknown]\n[001] 17127.087603311:                  branches:k:   tr strt                               0 [unknown] =&gt; ffffffffacd2fbf0 _raw_spin_lock+0x0\n[001] 17127.087603312:                  branches:k:   tr end  call           ffffffffacd2fc02 _raw_spin_lock+0x12 =&gt; ffffffffabd168b0 preempt_count_add+0x0\n[001] 17127.087603447:                  branches:k:   tr strt                               0 [unknown] =&gt; ffffffffacd2fc07 _raw_spin_lock+0x17\n[001] 17127.087617674:                  branches:k:   tr end  return         ffffffffacd2fc15 _raw_spin_lock+0x25 =&gt; ffffffffabd72381 handle_irq_event+0x51\n</code></pre> <p>Looking at the instructions, presumably it was the atomic operation \"lock cmpxchgl  %edx, (%rbx)\" that took unusually long:</p> <pre><code>$ sudo perf script --itrace=i0nse  -F-dso,+addr,-comm,-tid,-period,+insn --xed --ns  --time 17127.087603311,17127.087617674  \n[001] 17127.087603311:              instructions:k:                0 ffffffffacd2fbf0 _raw_spin_lock+0x0                nop %edi, %edx\n[001] 17127.087603311:              instructions:k:                0 ffffffffacd2fbf4 _raw_spin_lock+0x4                nopl  %eax, (%rax,%rax,1)\n[001] 17127.087603311:              instructions:k:                0 ffffffffacd2fbf9 _raw_spin_lock+0x9                pushq  %rbx\n[001] 17127.087603311:              instructions:k:                0 ffffffffacd2fbfa _raw_spin_lock+0xa                mov %rdi, %rbx\n[001] 17127.087603311:              instructions:k:                0 ffffffffacd2fbfd _raw_spin_lock+0xd                mov $0x1, %edi\n[001] 17127.087603312:              instructions:k: ffffffffabd168b0 ffffffffacd2fc02 _raw_spin_lock+0x12               callq  0xffffffffaacfd55e\n[001] 17127.087603447:              instructions:k:                0 ffffffffacd2fc07 _raw_spin_lock+0x17               xor %eax, %eax\n[001] 17127.087603447:              instructions:k:                0 ffffffffacd2fc09 _raw_spin_lock+0x19               mov $0x1, %edx\n[001] 17127.087603447:              instructions:k:                0 ffffffffacd2fc0e _raw_spin_lock+0x1e               lock cmpxchgl  %edx, (%rbx)\n[001] 17127.087617673:              instructions:k:                0 ffffffffacd2fc12 _raw_spin_lock+0x22               jnz 0xffffffffacd2fc1a\n[001] 17127.087617673:              instructions:k:                0 ffffffffacd2fc14 _raw_spin_lock+0x24               popq  %rbx\n[001] 17127.087617674:              instructions:k: ffffffffabd72381 ffffffffacd2fc15 _raw_spin_lock+0x25               retq  \n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-how-to-run-perf-on-a-different-cpu-to-the-workload","title":"Example: How to run perf on a different CPU to the workload","text":"<p>The taskset utility can be used to run perf on a different CPU to the workload.  For example, in a 8 CPU system, to run perf on CPU 0 and the workload on CPUs 1 to 7:</p> <pre><code>$ taskset --cpu 0 perf record -e intel_pt//u -- taskset --cpu 1-7 uname\nLinux\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.049 MB perf.data ]\n</code></pre> <p>Here it can be seen perf is restricted to CPU 0 but uname is running on CPU 2:</p> <pre><code>$ perf script --itrace=bieqq\n       perf-exec 11353 [000] 26597.875924:          1 instructions:  ffffffffabca5248 native_write_msr+0x8 ([kernel.kallsyms])\n         taskset 11353 [000] 26597.876033:          1 instructions:  ffffffffac302b6d ima_file_mmap+0x2d ([kernel.kallsyms])\n         taskset 11353 [000] 26597.876130:          1 instructions:  fffffffface01264 asm_exc_page_fault+0x4 ([kernel.kallsyms])\n         taskset 11353 [000] 26597.876201:          1 instructions:      7f3f4be379cc _nl_intern_locale_data+0xdc (/usr/lib/x86_64-linux-gnu/libc.so.6)\n         taskset 11353 [002] 26597.876280:          1 instructions:  ffffffffabca5248 native_write_msr+0x8 ([kernel.kallsyms])\n         taskset 11353 [002] 26597.876386:          1 instructions:  ffffffffabd92645 __rcu_read_unlock+0x25 ([kernel.kallsyms])\n         taskset 11353 [002] 26597.876460:          1 instructions:  ffffffffabf2a9ba folio_mark_accessed+0x2a ([kernel.kallsyms])\n           uname 11353 [002] 26597.876547:          1 instructions:      7f8dcb95f66f __GI___tunables_init+0x10f (/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2)\n           uname 11353 [002] 26597.876663:          1 instructions:      7f8dcb9594e8 _dl_relocate_object+0x788 (/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2)\n           uname 11353 [002] 26597.876752:          1 instructions:  ffffffffabf196d1 filemap_map_pages+0x651 ([kernel.kallsyms])\n           uname 11353 [002] 26597.876817:          1 instructions:  ffffffffabf2a9ba folio_mark_accessed+0x2a ([kernel.kallsyms])\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#example-intel-pt-event-trace","title":"Example: Intel PT Event Trace","text":"<p>Some processors like Alder Lake-N support Intel PT Event Trace.  Whether it is supported can be determined by the event_trace capability:</p> <pre><code>$ cat /sys/bus/event_source/devices/intel_pt/caps/event_trace \n1\n</code></pre> <p>\"1\" means it is supported.  \"0\" means it is not supported.  If the file is missing, then the kernel does not have support.</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-pt-event-trace-asynchronous-events","title":"Intel PT Event Trace : Asynchronous Events","text":"<p>Intel PT Event Trace records asynchronous events like interrupts, exceptions, faults, and NMI.  Branch tracing can be done at the same time but is not necessary.</p> <p>We can use <code>perf record</code> with options:</p> <ul> <li><code>-e</code> to select which events, i.e. the following:</li> <li><code>intel_pt/event,branch=0/u</code> to get Intel PT Event Trace and disable branch tracing, user space only.</li> <li><code>uname</code> is the workload.</li> </ul> <pre><code>$ perf record -e intel_pt/event,branch=0/u uname\nLinux\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.031 MB perf.data ]\n</code></pre> <p>To list the events, use <code>perf script</code> with options:</p> <ul> <li><code>--itrace=eI</code> to show errors (e) and events (I)</li> <li><code>--ns</code> to show the timestamp to nanoseconds instead of the default microseconds The output shows INTR for interrupts, exceptions, faults, and NMI.  In this case the PFA (Page Fault Linear Address) indicates that they are page faults.  IRET indicates a return to user space.</li> </ul> <pre><code>$ perf script --itrace=Ie --ns | head -10\n           uname   253 [007]  1719.062059042:                       evt:  cfe: IRET IP: 0 vector: 0                        0 [unknown] ([unknown])\n           uname   253 [007]  1719.062059042:                     iflag:  IFLAG: 0-&gt;1 non branch                7f7371368059 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   253 [007]  1719.062060708:                       evt:  cfe: INTR IP: 1 vector: 14 PFA: 0x7f7371368059     7f7371368059 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   253 [007]  1719.062065292:                       evt:  cfe: IRET IP: 0 vector: 0             7f7371368059 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   253 [007]  1719.062068000:                       evt:  cfe: INTR IP: 1 vector: 14 PFA: 0x7f7371366004     7f737136bbdb [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   253 [007]  1719.062070083:                       evt:  cfe: IRET IP: 0 vector: 0             7f737136bbdb [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   253 [007]  1719.062071333:                       evt:  cfe: INTR IP: 1 vector: 14 PFA: 0x7f737136dff8     7f737136bc42 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   253 [007]  1719.062073417:                       evt:  cfe: IRET IP: 0 vector: 0             7f737136bc42 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   253 [007]  1719.062078417:                       evt:  cfe: INTR IP: 1 vector: 14 PFA: 0x7f737136de88     7f737136bcd3 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   253 [007]  1719.062084250:                       evt:  cfe: IRET IP: 0 vector: 0             7f737136bcd3 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n</code></pre> <p>The timestamps are accurate only to the MTC period.  By default, mtc_period is 3 which means 8 (2^3) times the period of ART (Always Running Timer).  We can get the information needed to determine the ART frequency as follows:</p> <pre><code>$ cat /sys/bus/event_source/devices/intel_pt/tsc_art_ratio \n84:2\n$ dmesg | grep TSC\n[    0.000000] tsc: Detected 1612.800 MHz TSC\n[    0.018522] TSC deadline timer available\n</code></pre> <p>ART frequency is 1612.800 MHz / 42.  MTC period is 8 / ART frequency, which is 208 ns.  So, in this case, the timestamps are accurate to +/-208 ns. It is important to note that this cannot be improved by using Cycle-Accurate Mode alone.  That is because the CFE and EVT packets are not CYC-eligible.  To get more accurate timestamps, we need to do a branch trace also, but we do not need TNT packets to get timestamps on asynchronous or indirect branches, so the <code>perf record</code> command becomes:</p> <pre><code>$ perf record -e intel_pt/event,cyc,notnt/u uname\nLinux\n[ perf record: Woken up 2 times to write data ]\n[ perf record: Captured and wrote 0.036 MB perf.data ]\n</code></pre> <p>Now the corresponding branches can be displayed also, with more accurate timestamps.</p> <pre><code>$ perf script --itrace=eIb --ns | head -11\n           uname   274 [003]  4513.329990775:                        evt:  cfe: IRET IP: 0 vector: 0                        0 [unknown] ([unknown])\n           uname   274 [003]  4513.329990794:                      iflag:  IFLAG: 0-&gt;1 via branch                           0 [unknown] ([unknown])\n           uname   274 [003]  4513.329990794:          1                branches:uH:                 0 [unknown] ([unknown]) =&gt;     7fdd2d39b059 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   274 [003]  4513.329991489:                        evt:  cfe: INTR IP: 1 vector: 14 PFA: 0x7fdd2d39b059     7fdd2d39b059 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   274 [003]  4513.329991489:          1                branches:uH:      7fdd2d39b059 [unknown] (/lib/ld64-uClibc-1.0.39.so) =&gt;                0 [unknown] ([unknown])\n           uname   274 [003]  4513.329993275:                        evt:  cfe: IRET IP: 0 vector: 0             7fdd2d39b059 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   274 [003]  4513.329993391:          1                branches:uH:                 0 [unknown] ([unknown]) =&gt;     7fdd2d39b059 [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   274 [003]  4513.329994447:                        evt:  cfe: INTR IP: 1 vector: 14 PFA: 0x7ffe3db37de0     7fdd2d39eb6b [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   274 [003]  4513.329994447:          1                branches:uH:      7fdd2d39eb6b [unknown] (/lib/ld64-uClibc-1.0.39.so) =&gt;                0 [unknown] ([unknown])\n           uname   274 [003]  4513.329995775:                        evt:  cfe: IRET IP: 0 vector: 0             7fdd2d39eb6b [unknown] (/lib/ld64-uClibc-1.0.39.so)\n           uname   274 [003]  4513.329995950:          1                branches:uH:                 0 [unknown] ([unknown]) =&gt;     7fdd2d39eb6b [unknown] (/lib/ld64-uClibc-1.0.39.so)\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#tracing-jit-compiled-code-like-javatm-with-openjdk","title":"Tracing JIT-compiled code like Java\u2122 with OpenJDK","text":"<p>Intel PT decoding needs to walk the object code to reconstruct control flow from trace packets, so how does this work if the code is created at runtime by a JIT compiler.</p> <p>The answer is that some JIT compilers like OpenJDK Java provide an interface to record the JIT-compiled code.  For Java it is called Java\u2122 Virtual Machine Tool Interface (JVM TI).  <code>perf</code> provides library libperf-jvmti.so to make use of the interface.  To make it work:</p> <ul> <li>java option <code>-agentpath</code> is used to tell java to use libperf-jvmti.so which produces a jitdump file</li> <li><code>perf inject</code> must be used to inject information from the jitdump file into the output perf.data file</li> </ul> <p>Below is a small example using HelloWorldApp from The Java\u2122 Tutorials.  Note that the recorded perf.data file is called java.perf.data and the injected perf.data file is called java.perf.data.jitted.</p> <pre><code>$ cat HelloWorldApp.java\n/**\n * The HelloWorldApp class implements an application that\n * simply prints \"Hello World!\" to standard output.\n */\nclass HelloWorldApp {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\"); // Display the string.\n    }\n}\n$ javac HelloWorldApp.java\n$ perf record -m,16M -e intel_pt//u -o java.perf.data java -agentpath:$HOME/lib64/libperf-jvmti.so HelloWorldApp\njava: jvmti: jitdump in /home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jit-162584.dump\nHello World!\n[ perf record: Woken up 3 times to write data ]\n[ perf record: Captured and wrote 15.469 MB java.perf.data ]\n$ perf inject -i java.perf.data --jit -o java.perf.data.jitted\n$ perf script --itrace=qqi -i java.perf.data.jitted | grep jitted | head\n            java  162586 [006] 779113.252541:          1 instructions:uH:      7f7bc860008b flush_icache_stub+0xb (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-1.so)\n            java  162586 [006] 779113.257527:          1 instructions:uH:      7f7bc8614007 Interpreter+0xb487 (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-29.so)\n            java  162586 [006] 779113.259374:          1 instructions:uH:      7f7bc8611617 Interpreter+0x8a97 (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-29.so)\n            java  162586 [006] 779113.259391:          1 instructions:uH:      7f7bc8618c3d Interpreter+0x100bd (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-29.so)\n            java  162586 [006] 779113.259411:          1 instructions:uH:      7f7bc86146a7 Interpreter+0xbb27 (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-29.so)\n            java  162586 [006] 779113.259426:          1 instructions:uH:      7f7bc861a823 Interpreter+0x11ca3 (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-29.so)\n            java  162586 [006] 779113.259444:          1 instructions:uH:      7f7bc8618b3f Interpreter+0xffbf (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-29.so)\n            java  162586 [006] 779113.259458:          1 instructions:uH:      7f7bc8621514 Interpreter+0x18994 (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-29.so)\n            java  162586 [006] 779113.259473:          1 instructions:uH:      7f7bc860f684 Interpreter+0x6b04 (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-29.so)\n            java  162586 [006] 779113.259489:          1 instructions:uH:      7f7bc861e401 Interpreter+0x15881 (/home/ahunter/.debug/jit/java-jit-20230920.XXVLk6o0/jitted-162584-29.so)\n$ \n</code></pre> <p>Note that OpenJDK does not provide all JIT-compiled code via JVMTI so there are still decode errors:</p> <pre><code>$ perf script --itrace=e -i java.perf.data.jitted | head\n instruction trace error type 1 time 779113.256448669 cpu 6 pid 162584 tid 162586 ip 0x7f7bc8657180 code 5: Failed to get instruction\n instruction trace error type 1 time 779113.256449353 cpu 6 pid 162584 tid 162586 ip 0x7f7be7902b8c code 6: Trace doesn't match instruction\n instruction trace error type 1 time 779113.256562002 cpu 6 pid 162584 tid 162586 ip 0x7f7bc8657180 code 5: Failed to get instruction\n instruction trace error type 1 time 779113.256567103 cpu 6 pid 162584 tid 162586 ip 0x7f7bc860fa2e code 6: Trace doesn't match instruction\n instruction trace error type 1 time 779113.256567276 cpu 6 pid 162584 tid 162586 ip 0x7f7be75739df code 6: Trace doesn't match instruction\n instruction trace error type 1 time 779113.256567282 cpu 6 pid 162584 tid 162586 ip 0x7f7be7e3797e code 6: Trace doesn't match instruction\n instruction trace error type 1 time 779113.256567458 cpu 6 pid 162584 tid 162586 ip 0x7f7be787eeb8 code 6: Trace doesn't match instruction\n instruction trace error type 1 time 779113.256590771 cpu 6 pid 162584 tid 162586 ip 0x7f7bc8657180 code 5: Failed to get instruction\n instruction trace error type 1 time 779113.256666104 cpu 6 pid 162584 tid 162586 ip 0x7f7bc8657180 code 5: Failed to get instruction\n instruction trace error type 1 time 779113.256666673 cpu 6 pid 162584 tid 162586 ip 0x7f7be7b8159b code 6: Trace doesn't match instruction\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#using-perf-dlfilter-interface-to-disassemble-executed-instructions","title":"Using perf dlfilter interface to disassemble executed instructions","text":"<p>perf provides an API to link a user-provided library for filtering or processing of data.  Such a library is refered to as a dlfilter. Refer to the perf dlfilter man page for details. The advantage of using a dlfilter is that it can be much faster than processing with the perf Python API.</p> <p>Below is a perf dlfilter program to disassemble Intel PT traces.  It could be modified to filter based on particular kinds of instructions, but at the moment just prints a disassembly.  The Intel X86 Encoder Decoder (XED) is used.  Refer to Example: Tracing your own code : Hello World for how to install XED.</p> <pre><code>// SPDX-License-Identifier: GPL-2.0\n/*\n * perf dlfilter to disassemble Intel PT trace\n */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;string.h&gt;\n\n#include &lt;perf/perf_dlfilter.h&gt;\n\n#include &lt;xed/xed-interface.h&gt;\n\n#define MAX_CPU 4096\n\nstatic __u64 last_branch_addr[MAX_CPU];\n\n#define BUFSZ 65536\n\nstatic __u8 ibuf[BUFSZ];\n\n#define BRANCHES_EVENT \"branches\"\n\nstatic const char *branches = BRANCHES_EVENT;\nstatic const size_t branches_len = (sizeof(BRANCHES_EVENT) - 1);\n\nstruct perf_dlfilter_fns perf_dlfilter_fns;\n\nint start(void **data, void *ctx)\n{\n    xed_tables_init();\n    return 0;\n}\n\nstatic void print_instruction(xed_decoded_inst_t *inst, __u64 from_addr)\n{\n    char obuf[256];\n\n    if (!xed_format_context(XED_SYNTAX_ATT, inst, obuf, sizeof(obuf), from_addr, NULL, NULL)) {\n        printf(\"xed_format_context failed\\n\");\n        return;\n    }\n\n    printf(\"%16llx  %s\\n\", from_addr, obuf);\n}\n\nstatic void disassemble_buffer(__u64 from_addr, __u64 to_addr, bool is_64_bit, bool inclusive, __u8 *buf, __s32 len)\n{\n    xed_error_enum_t xed_ret;\n    xed_decoded_inst_t inst;\n    __u8 *p = buf;\n\n    xed_decoded_inst_zero(&amp;inst);\n\n    if (is_64_bit)\n        xed_decoded_inst_set_mode(&amp;inst, XED_MACHINE_MODE_LONG_64, XED_ADDRESS_WIDTH_64b);\n    else\n        xed_decoded_inst_set_mode(&amp;inst, XED_MACHINE_MODE_LEGACY_32, XED_ADDRESS_WIDTH_32b);\n\n    /* Bump up 'to_addr' to make the loop include that instruction also */\n    if (inclusive)\n        to_addr += 1;\n\n    while (len &gt; 0 &amp;&amp; from_addr &lt; to_addr) {\n        xed_uint_t ilen;\n\n        xed_decoded_inst_zero_keep_mode(&amp;inst);\n\n        xed_ret = xed_decode(&amp;inst, p, len);\n        if (xed_ret != XED_ERROR_NONE) {\n            printf(\"xed_decode failed, error %d\\n\", xed_ret);\n            return;\n        }\n\n        print_instruction(&amp;inst, from_addr);\n\n        ilen = xed_decoded_inst_get_length(&amp;inst);\n\n        p += ilen;\n        len -= ilen;\n        from_addr += ilen;\n    }\n}\n\nstatic void disassemble_range(void *ctx, __u64 from_addr, __u64 to_addr, bool is_64_bit, bool inclusive, __u8 *buf, size_t buf_len)\n{\n    __u64 sz;\n    __u64 read_sz;\n    __s32 nr_bytes;\n\n    sz = to_addr - from_addr;\n    if (sz == 0 &amp;&amp; !inclusive)\n        return;\n\n    /* 'inclusive' means also read last instruction */\n    read_sz = inclusive ? sz + XED_MAX_INSTRUCTION_BYTES : sz;\n\n    if (read_sz &gt; buf_len) {\n        printf(\"Cannot disassemble from %llx to %llx, buffer too small\\n\", from_addr, to_addr);\n        return;\n    }\n\n    /* Read object code, return numbers of bytes read */\n    nr_bytes = perf_dlfilter_fns.object_code(ctx, from_addr, ibuf, read_sz);\n    if (nr_bytes &lt; sz) {\n        printf(\"Failed to read object code\\n\");\n        return;\n    }\n\n    disassemble_buffer(from_addr, to_addr, is_64_bit, inclusive, buf, nr_bytes);\n}\n\nint filter_event_early(void *data, const struct perf_dlfilter_sample *sample, void *ctx)\n{\n    const struct perf_dlfilter_al *al;\n    __u64 from_addr, to_addr;\n    bool async;\n\n    /* Only process per-cpu branch events */\n    if (strncmp(sample-&gt;event, branches, branches_len) ||\n        sample-&gt;cpu &lt; 0 ||\n        !sample-&gt;addr_correlates_sym)\n        return 0;\n\n    from_addr = last_branch_addr[sample-&gt;cpu];\n    to_addr = sample-&gt;ip;\n\n    if (!from_addr || !to_addr)\n        goto out;\n\n    if (to_addr &lt; from_addr) {\n        printf(\"Cannot disassemble from %llx to %llx\\n\", from_addr, to_addr);\n        goto out;\n    }\n\n    al = perf_dlfilter_fns.resolve_ip(ctx);\n    if (!al) {\n        printf(\"Cannot resolve address %llx\\n\", sample-&gt;ip);\n        goto out;\n    }\n\n    /* Asynchronous means the instruction at the branch address was not executed */\n    async = sample-&gt;flags &amp; PERF_DLFILTER_FLAG_ASYNC;\n\n    disassemble_range(ctx, from_addr, to_addr, al-&gt;is_64_bit, !async, ibuf, sizeof(ibuf));\n\nout:\n    if (sample-&gt;flags &amp; PERF_DLFILTER_FLAG_TRACE_END)\n        last_branch_addr[sample-&gt;cpu] = 0;\n    else\n        last_branch_addr[sample-&gt;cpu] = sample-&gt;addr;\n\n    return 0;\n}\n\nconst char *filter_description(const char **long_description)\n{\n    static char *long_desc = \"Requires an Intel PT branch trace (not config term branch=0).  \"\n        \"Per-thread recording is not supported.  Example: \"\n        \"perf record -e intel_pt//u uname ; \"\n        \"perf script --itrace=be --dlfilter dlfilter-x86-disasm.so --ns -F-period,-event,+addr,+flags\";\n\n    *long_description = long_desc;\n    return \"Disassemble Intel PT trace\";\n}\n</code></pre> <p>To compile the dlfilter:</p> <pre><code>$ gcc -c -o dlfilter-x86-disasm.o -I ~/include -fpic dlfilter-x86-disasm.c\n$ gcc -shared -o dlfilter-x86-disasm.so dlfilter-x86-disasm.o -lxed\n</code></pre> <p>To record a simple trace and disassemble:</p> <pre><code>$ perf record -e intel_pt//u uname\nLinux\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.044 MB perf.data ]\n$ perf script --itrace=be --dlfilter dlfilter-x86-disasm.so --ns -F-period,-event,+addr,+flags | head\n           uname    7834 [000] 15899.089119450:   tr strt                               0 [unknown] ([unknown]) =&gt;     7fb0daf7b2f0 _start+0x0 (/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2)\n           uname    7834 [000] 15899.089119659:   tr end  async              7fb0daf7b2f0 _start+0x0 (/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2) =&gt;                0 [unknown] ([unknown])\n           uname    7834 [000] 15899.089122367:   tr strt                               0 [unknown] ([unknown]) =&gt;     7fb0daf7b2f0 _start+0x0 (/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2)\n    7fb0daf7b2f0  mov %rsp, %rdi\n    7fb0daf7b2f3  callq  0x7fb0daf7c090\n           uname    7834 [000] 15899.089122367:   call                       7fb0daf7b2f3 _start+0x3 (/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2) =&gt;     7fb0daf7c090 _dl_start+0x0 (/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2)\n    7fb0daf7c090  nop %edi, %edx\n    7fb0daf7c094  pushq  %rbp\n    7fb0daf7c095  mov %rsp, %rbp\n    7fb0daf7c098  pushq  %r15\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#tracing-intel-user-interrupts-with-intel-processor-trace-intel-pt","title":"Tracing Intel User Interrupts with Intel Processor Trace (Intel PT)","text":"<p>RFC patches to add Linux kernel support for Intel User Interrupts were submitted in 2021 LWN Article, discussion, but have not progressed since.</p> <p>So this example uses a custom kernel based on the provided uintr-linux-kernel git repository branch uintr-next commit 9bbbb4b7fb89.</p> <p>Importantly, User Interrupt support must be enabled in kernel config i.e. CONFIG_X86_USER_INTERRUPTS=y</p> <p>Once installed, check the kernel version is what is expected e.g.</p> <pre><code>$ uname -a\nLinux spr2 6.0.0-00019-g9bbbb4b7fb89 #2 SMP PREEMPT_DYNAMIC Tue Jan 16 18:38:27 EET 2024 x86_64 GNU/Linux\n</code></pre> <p>And check for the User Interrupts feature:</p> <pre><code>$ cat /proc/cpuinfo | head -30 | grep -c uintr\n1\n</code></pre> <p>The developer provided benchmark programs uintr-ipc-bench.  In this example, branch master commit 6696170577b9. Build and run instructions in README.md</p> <p>Benchamark program build/source/uintrfd/uintrfd-uni will be used.  It repeatedly sends a user interrupt (senduipi) to another thread which will invoke a registered handler function ui_handler().  The time taken from sending to receiving is measured:</p> <pre><code>$ cat source/uintrfd/uintrfd-uni.c\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;x86gprintrin.h&gt;\n\n#define __USE_GNU\n#include &lt;pthread.h&gt;\n#include &lt;sched.h&gt;\n\n#include \"common/common.h\"\n\n#ifndef __NR_uintr_register_handler\n#define __NR_uintr_register_handler 471\n#define __NR_uintr_unregister_handler   472\n#define __NR_uintr_create_fd        473\n#define __NR_uintr_register_sender  474\n#define __NR_uintr_unregister_sender    475\n#define __NR_uintr_wait         476\n#endif\n\n#define uintr_register_handler(handler, flags)  syscall(__NR_uintr_register_handler, handler, flags)\n#define uintr_unregister_handler(flags)     syscall(__NR_uintr_unregister_handler, flags)\n#define uintr_create_fd(vector, flags)      syscall(__NR_uintr_create_fd, vector, flags)\n#define uintr_register_sender(fd, flags)    syscall(__NR_uintr_register_sender, fd, flags)\n#define uintr_unregister_sender(ipi_idx, flags) syscall(__NR_uintr_unregister_sender, ipi_idx, flags)\n#define uintr_wait(flags)           syscall(__NR_uintr_wait, flags)\n\nvolatile unsigned long uintr_received;\nvolatile unsigned int uintr_count = 0;\nint descriptor;\n\nstruct Benchmarks bench;\n\nvoid __attribute__ ((interrupt))\n     __attribute__((target(\"general-regs-only\", \"inline-all-stringops\")))\n     ui_handler(struct __uintr_frame *ui_frame,\n        unsigned long long vector) {\n\n    benchmark(&amp;bench);\n    uintr_count++;\n    uintr_received = 1;\n}\n\nvoid __attribute__ ((noinline)) senduipi(int uipi_index)\n{\n    _senduipi(uipi_index);\n}\n\nvoid *client_communicate(void *arg) {\n\n    struct Arguments* args = (struct Arguments*)arg;\n    int loop;\n\n    int uipi_index = uintr_register_sender(descriptor, 0);\n    if (uipi_index &lt; 0)\n        throw(\"Sender register error\\n\");\n\n    for (loop = args-&gt;count; loop &gt; 0; --loop) {\n\n        uintr_received = 0;\n        bench.single_start = now();\n\n        // Send User IPI\n        senduipi(uipi_index);\n\n        while (!uintr_received){\n            // Keep spinning until this user interrupt is received.\n        }\n    }\n\n    return NULL;\n}\n\nvoid server_communicate(int descriptor, struct Arguments* args) {\n\n    while (uintr_count &lt; args-&gt;count) {\n        //Keep spinning until all user interrupts are delivered.\n    }\n\n    // The message size is always one (it's just a signal)\n    args-&gt;size = 1;\n    evaluate(&amp;bench, args);\n}\n\nvoid communicate(int descriptor, struct Arguments* args) {\n\n    pthread_t pt;\n\n    setup_benchmarks(&amp;bench);\n\n    // Create another thread\n    if (pthread_create(&amp;pt, NULL, &amp;client_communicate, args)) {\n        throw(\"Error creating sender thread\");\n    }\n\n    server_communicate(descriptor, args);\n\n    close(descriptor);\n}\n\nint main(int argc, char* argv[]) {\n\n    struct Arguments args;\n\n    if (uintr_register_handler(ui_handler, 0))\n        throw(\"Interrupt handler register error\\n\");\n\n    // Create a new uintrfd object and get the corresponding\n    // file descriptor.\n    descriptor = uintr_create_fd(0, 0);\n    if (descriptor &lt; 0)\n        throw(\"Interrupt vector allocation error\\n\");\n\n    // Enable interrupts\n    _stui();\n\n    parse_arguments(&amp;args, argc, argv);\n\n    communicate(descriptor, &amp;args);\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>The benchmark is using timespec_get() which is not ideal for comparing time measurements because it uses CLOCK_REALTIME which is not monotonic.</p> <ul> <li>For comparing times on different machines, CLOCK_MONOTONIC can be used.</li> <li>For comparing times on the same machine, CLOCK_MONTONIC or CLOCK_MONTONIC_RAW can be used.</li> <li>For comparing with Intel PT, CLOCK_MONTONIC_RAW will be a close match to perf time, so that is used here.</li> </ul> <p>Also to get precise timing, Intel PT address filtering can be used, but in that case senduipi needs to be a separate, non-inline function.</p> <p>Here are the changes:</p> <pre><code>$ git diff\ndiff --git a/source/common/benchmarks.c b/source/common/benchmarks.c\nindex 6c3fe92..6619cd9 100644\n--- a/source/common/benchmarks.c\n+++ b/source/common/benchmarks.c\n@@ -13,7 +13,7 @@ bench_t now() {\n    return ((double)clock()) / CLOCKS_PER_SEC * 1e9;\n #else\n    struct timespec ts;\n-   timespec_get(&amp;ts, TIME_UTC);\n+   clock_gettime(CLOCK_MONOTONIC_RAW, &amp;ts);\n\n    return ts.tv_sec * 1e9 + ts.tv_nsec;\n\ndiff --git a/source/uintrfd/uintrfd-uni.c b/source/uintrfd/uintrfd-uni.c\nindex cb62dbb..c26f9d2 100644\n--- a/source/uintrfd/uintrfd-uni.c\n+++ b/source/uintrfd/uintrfd-uni.c\n@@ -42,6 +42,11 @@ void __attribute__ ((interrupt))\n    uintr_received = 1;\n }\n\n+void __attribute__ ((noinline)) senduipi(int uipi_index)\n+{\n+   _senduipi(uipi_index);\n+}\n+\n void *client_communicate(void *arg) {\n\n    struct Arguments* args = (struct Arguments*)arg;\n@@ -57,7 +62,7 @@ void *client_communicate(void *arg) {\n        bench.single_start = now();\n\n        // Send User IPI\n-       _senduipi(uipi_index);\n+       senduipi(uipi_index);\n\n        while (!uintr_received){\n            // Keep spinning until this user interrupt is received.\n</code></pre> <p>Run the benchmark program, tracing with Intel PT and cycle-accurate mode, using address filters for the sending function <code>senduipi()</code> and receiving <code>function ui_handler()</code>:</p> <pre><code>$ perf record -e intel_pt/cyc/u --filter 'filter senduipi #1 @ build/source/uintrfd/uintrfd-uni , filter ui_handler #1 @ build/source/uintrfd/uintrfd-uni' -- build/source/uintrfd/uintrfd-uni\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.131 MB uintr-tfr2/perf.data ]\n\n============ RESULTS ================\nMessage size:       1\nMessage count:      1000\nTotal duration:     2.416   ms\nAverage duration:   1.348   us\nMinimum duration:   1.280   us\nMaximum duration:   7.608   us\nStandard deviation: 0.235   us\nMessage rate:       413926  msg/s\n=====================================\n</code></pre> <p>A python script is needed to compute statistics from the Intel PT trace:</p> <pre><code>$ cat uintr-uni-stats.py\n\nimport statistics\nimport numpy\n\ndef trace_begin():\n    print(\"uintr-uni statistics\")\n    print(\"====================\")\n\ndef get_optional(perf_dict, field, dflt):\n    if field in perf_dict:\n        return perf_dict[field]\n    return dflt\n\nglb_start = 0\nglb_data = []\n\ndef process_event(param_dict):\n    name        = param_dict[\"ev_name\"]\n    if not name.startswith(\"branches\"):\n        return\n    sample      = param_dict[\"sample\"]\n    pid         = sample[\"pid\"]\n    tid         = sample[\"tid\"]\n    cpu         = sample[\"cpu\"]\n    ts          = sample[\"time\"]\n    addr_symbol = get_optional(sample, \"addr_symbol\", \"[unknown]\")\n    addr_symoff = get_optional(sample, \"addr_symoff\", \"[unknown]\")\n    symbol      = get_optional(param_dict, \"symbol\", \"[unknown]\")\n    symoff      = get_optional(param_dict, \"symoff\", 1)\n    global glb_start\n    global glb_data\n    if addr_symbol == \"senduipi\" and addr_symoff == 0:\n        if glb_start:\n            print(cpu, pid, tid, ts, name, symbol, symoff, addr_symbol, addr_symoff, \"START AFTER START\")\n        glb_start = ts\n    elif addr_symbol == \"ui_handler\" and addr_symoff == 0:\n        if glb_start:\n            latency = (ts - glb_start) / 1000\n            glb_data.append(latency)\n            glb_start = 0\n        else:\n            print(cpu, pid, tid, ts, name, symbol, symoff, addr_symbol, addr_symoff, \"END NO START\")\n\ndef trace_end():\n    print()\n    print(\"Count:              %u\" % len(glb_data))\n    print(\"Average:            %.3f\" % statistics.mean(glb_data))\n    print(\"Minimum:            %.3f\" % min(glb_data))\n    print(\"Maximum:            %.3f\" % max(glb_data))\n    print(\"Standard deviation: %.3f\" % statistics.stdev(glb_data))\n    h = numpy.histogram(glb_data, bins=10)\n    print(\"\\nHistogram:\")\n    print(\"  Range          Count\")\n    for i in range(10):\n        print(\"  %.3f - %.3f  %u\" % (h[1][i], h[1][i+1], h[0][i]))\n</code></pre> <p>First check for errors:</p> <pre><code>$ perf script --itrace=e\n$\n</code></pre> <p>No errors, so run the script:</p> <pre><code>$ perf script --itrace=bep -s uintr-uni-stats.py\nuintr-uni statistics\n====================\n\nCount:              1000\nAverage:            1.259\nMinimum:            1.201\nMaximum:            7.484\nStandard deviation: 0.216\n\nHistogram:\n  Range          Count\n  1.201 - 1.829  998\n  1.829 - 2.458  1\n  2.458 - 3.086  0\n  3.086 - 3.714  0\n  3.714 - 4.342  0\n  4.342 - 4.971  0\n  4.971 - 5.599  0\n  5.599 - 6.227  0\n  6.227 - 6.856  0\n  6.856 - 7.484  1\n</code></pre> <p>The Intel PT results are slighly lower than the benchmark program produced itself, because they do not included the overhead of getting the time (via clock_gettime).</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#appendix-intel-pt-capabilities-on-different-processors","title":"Appendix: Intel PT capabilities on different processors","text":"<p>Generally, processors with the same CPU core microarchitecture can be expected to have the same Intel PT capabilities.  The Linux Intel PT driver provides capability flags in sysfs, refer Intel PT man page .  Below are some examples:</p>"},{"location":"perf-tools-support-for-intel-processor-trace/#9th-gen-core-skylake","title":"9th Gen Core (Skylake)","text":"<pre><code>$ grep -H . /sys/bus/event_source/devices/intel_pt/caps/*\n/sys/bus/event_source/devices/intel_pt/caps/cr3_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds:3fff\n/sys/bus/event_source/devices/intel_pt/caps/ip_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/max_subleaf:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc_periods:249\n/sys/bus/event_source/devices/intel_pt/caps/num_address_ranges:2\n/sys/bus/event_source/devices/intel_pt/caps/output_subsys:0\n/sys/bus/event_source/devices/intel_pt/caps/payloads_lip:0\n/sys/bus/event_source/devices/intel_pt/caps/power_event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/psb_cyc:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_periods:3f\n/sys/bus/event_source/devices/intel_pt/caps/ptwrite:0\n/sys/bus/event_source/devices/intel_pt/caps/single_range_output:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_multiple_entries:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_output:1\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-atom-apollo-lake","title":"Intel Atom (Apollo Lake)","text":"<pre><code># grep -H . /sys/bus/event_source/devices/intel_pt/caps/*\n/sys/bus/event_source/devices/intel_pt/caps/cr3_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds:ffff\n/sys/bus/event_source/devices/intel_pt/caps/event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/ip_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/max_subleaf:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc_periods:249\n/sys/bus/event_source/devices/intel_pt/caps/num_address_ranges:2\n/sys/bus/event_source/devices/intel_pt/caps/output_subsys:0\n/sys/bus/event_source/devices/intel_pt/caps/payloads_lip:1\n/sys/bus/event_source/devices/intel_pt/caps/power_event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/psb_cyc:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_periods:3f\n/sys/bus/event_source/devices/intel_pt/caps/ptwrite:0\n/sys/bus/event_source/devices/intel_pt/caps/single_range_output:1\n/sys/bus/event_source/devices/intel_pt/caps/tnt_disable:0\n/sys/bus/event_source/devices/intel_pt/caps/topa_multiple_entries:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_output:1\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-atom-gemini-lake","title":"Intel Atom (Gemini Lake)","text":"<pre><code># grep -H . /sys/bus/event_source/devices/intel_pt/caps/*\n/sys/bus/event_source/devices/intel_pt/caps/cr3_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds:ffff\n/sys/bus/event_source/devices/intel_pt/caps/event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/ip_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/max_subleaf:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc_periods:249\n/sys/bus/event_source/devices/intel_pt/caps/num_address_ranges:2\n/sys/bus/event_source/devices/intel_pt/caps/output_subsys:0\n/sys/bus/event_source/devices/intel_pt/caps/payloads_lip:1\n/sys/bus/event_source/devices/intel_pt/caps/power_event_trace:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_cyc:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_periods:3f\n/sys/bus/event_source/devices/intel_pt/caps/ptwrite:1\n/sys/bus/event_source/devices/intel_pt/caps/single_range_output:1\n/sys/bus/event_source/devices/intel_pt/caps/tnt_disable:0\n/sys/bus/event_source/devices/intel_pt/caps/topa_multiple_entries:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_output:1\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#10th-gen-core-ice-lake","title":"10th Gen Core (Ice Lake)","text":"<pre><code># grep -H . /sys/bus/event_source/devices/intel_pt/caps/*\n/sys/bus/event_source/devices/intel_pt/caps/cr3_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds:1fff\n/sys/bus/event_source/devices/intel_pt/caps/event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/ip_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/max_subleaf:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc_periods:249\n/sys/bus/event_source/devices/intel_pt/caps/num_address_ranges:2\n/sys/bus/event_source/devices/intel_pt/caps/output_subsys:0\n/sys/bus/event_source/devices/intel_pt/caps/payloads_lip:0\n/sys/bus/event_source/devices/intel_pt/caps/power_event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/psb_cyc:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_periods:3f\n/sys/bus/event_source/devices/intel_pt/caps/ptwrite:0\n/sys/bus/event_source/devices/intel_pt/caps/single_range_output:1\n/sys/bus/event_source/devices/intel_pt/caps/tnt_disable:0\n/sys/bus/event_source/devices/intel_pt/caps/topa_multiple_entries:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_output:1\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#11th-gen-core-tiger-lake","title":"11th Gen Core (Tiger Lake)","text":"<pre><code>$ grep -H . /sys/bus/event_source/devices/intel_pt/caps/*\n/sys/bus/event_source/devices/intel_pt/caps/cr3_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds:1fff\n/sys/bus/event_source/devices/intel_pt/caps/ip_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/max_subleaf:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc_periods:249\n/sys/bus/event_source/devices/intel_pt/caps/num_address_ranges:2\n/sys/bus/event_source/devices/intel_pt/caps/output_subsys:0\n/sys/bus/event_source/devices/intel_pt/caps/payloads_lip:0\n/sys/bus/event_source/devices/intel_pt/caps/power_event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/psb_cyc:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_periods:3f\n/sys/bus/event_source/devices/intel_pt/caps/ptwrite:0\n/sys/bus/event_source/devices/intel_pt/caps/single_range_output:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_multiple_entries:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_output:1\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#intel-atom-jasper-lake","title":"Intel Atom (Jasper Lake)","text":"<pre><code># grep -H . /sys/bus/event_source/devices/intel_pt/caps/*\n/sys/bus/event_source/devices/intel_pt/caps/cr3_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds:ffff\n/sys/bus/event_source/devices/intel_pt/caps/event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/ip_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/max_subleaf:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc_periods:249\n/sys/bus/event_source/devices/intel_pt/caps/num_address_ranges:2\n/sys/bus/event_source/devices/intel_pt/caps/output_subsys:0\n/sys/bus/event_source/devices/intel_pt/caps/payloads_lip:1\n/sys/bus/event_source/devices/intel_pt/caps/power_event_trace:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_cyc:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_periods:3f\n/sys/bus/event_source/devices/intel_pt/caps/ptwrite:1\n/sys/bus/event_source/devices/intel_pt/caps/single_range_output:1\n/sys/bus/event_source/devices/intel_pt/caps/tnt_disable:0\n/sys/bus/event_source/devices/intel_pt/caps/topa_multiple_entries:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_output:1\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#12th-gen-core-alder-lake","title":"12th Gen Core (Alder Lake)","text":"<pre><code># grep -H . /sys/bus/event_source/devices/intel_pt/caps/*\n/sys/bus/event_source/devices/intel_pt/caps/cr3_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds:3f\n/sys/bus/event_source/devices/intel_pt/caps/event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/ip_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/max_subleaf:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc_periods:249\n/sys/bus/event_source/devices/intel_pt/caps/num_address_ranges:2\n/sys/bus/event_source/devices/intel_pt/caps/output_subsys:0\n/sys/bus/event_source/devices/intel_pt/caps/payloads_lip:0\n/sys/bus/event_source/devices/intel_pt/caps/power_event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/psb_cyc:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_periods:3f\n/sys/bus/event_source/devices/intel_pt/caps/ptwrite:1\n/sys/bus/event_source/devices/intel_pt/caps/single_range_output:1\n/sys/bus/event_source/devices/intel_pt/caps/tnt_disable:0\n/sys/bus/event_source/devices/intel_pt/caps/topa_multiple_entries:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_output:1\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#n-series-alder-lake-n","title":"N-Series (Alder Lake-N)","text":"<p>Alder Lake-N has only E-Cores and more Intel PT features like Event Trace and TNT Disable.</p> <pre><code># grep -H . /sys/bus/event_source/devices/intel_pt/caps/*\n/sys/bus/event_source/devices/intel_pt/caps/cr3_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds:ffff\n/sys/bus/event_source/devices/intel_pt/caps/event_trace:1\n/sys/bus/event_source/devices/intel_pt/caps/ip_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/max_subleaf:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc_periods:249\n/sys/bus/event_source/devices/intel_pt/caps/num_address_ranges:2\n/sys/bus/event_source/devices/intel_pt/caps/output_subsys:0\n/sys/bus/event_source/devices/intel_pt/caps/payloads_lip:1\n/sys/bus/event_source/devices/intel_pt/caps/power_event_trace:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_cyc:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_periods:3f\n/sys/bus/event_source/devices/intel_pt/caps/ptwrite:1\n/sys/bus/event_source/devices/intel_pt/caps/single_range_output:1\n/sys/bus/event_source/devices/intel_pt/caps/tnt_disable:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_multiple_entries:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_output:1\n</code></pre>"},{"location":"perf-tools-support-for-intel-processor-trace/#13th-gen-core-raptor-lake","title":"13th Gen Core (Raptor Lake)","text":"<pre><code># grep -H . /sys/bus/event_source/devices/intel_pt/caps/*\n/sys/bus/event_source/devices/intel_pt/caps/cr3_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/cycle_thresholds:3f\n/sys/bus/event_source/devices/intel_pt/caps/event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/ip_filtering:1\n/sys/bus/event_source/devices/intel_pt/caps/max_subleaf:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc:1\n/sys/bus/event_source/devices/intel_pt/caps/mtc_periods:249\n/sys/bus/event_source/devices/intel_pt/caps/num_address_ranges:2\n/sys/bus/event_source/devices/intel_pt/caps/output_subsys:0\n/sys/bus/event_source/devices/intel_pt/caps/payloads_lip:0\n/sys/bus/event_source/devices/intel_pt/caps/power_event_trace:0\n/sys/bus/event_source/devices/intel_pt/caps/psb_cyc:1\n/sys/bus/event_source/devices/intel_pt/caps/psb_periods:3f\n/sys/bus/event_source/devices/intel_pt/caps/ptwrite:1\n/sys/bus/event_source/devices/intel_pt/caps/single_range_output:1\n/sys/bus/event_source/devices/intel_pt/caps/tnt_disable:0\n/sys/bus/event_source/devices/intel_pt/caps/topa_multiple_entries:1\n/sys/bus/event_source/devices/intel_pt/caps/topa_output:1\n\n# echo -n \"Intel PT can be used in VMX operation (VMX_MISC MSR 0x485 bit 14) : \" ; rdmsr -p 0 -f 14:14 0x485\nIntel PT can be used in VMX operation (VMX_MISC MSR 0x485 bit 14) : 1\n\n# echo -n \"PEBS output to Intel PT Capability (PERF_CAPABILITIES MSR 0x345 bit 16) : \" ;  rdmsr -p 0 -f 16:16 0x345\nPEBS output to Intel PT Capability (PERF_CAPABILITIES MSR 0x345 bit-16) : 0\n</code></pre>"},{"location":"reference-count-checking/","title":"Reference Count Checking","text":"<p>Reference count checking is enabled when building the perf tool with leak or address sanitizer:</p> <pre><code>make -C tools/perf DEBUG=1 EXTRA_CFLAGS=\"-fsanitize=address\"\n</code></pre> <p>or explicitly like:</p> <pre><code>make -C tools/perf -DREFCNT_CHECKING=1\"\n</code></pre>"},{"location":"reference-count-checking/#how-it-works","title":"How it works","text":"<p>The way the reference count checker works is to take a struct like:</p> <pre><code>struct nsinfo {\n        pid_t                   pid;\n        pid_t                   tgid;\n        pid_t                   nstgid;\n        bool                    need_setns;\n        bool                    in_pidns;\n        char                    *mntns_path;\n        refcount_t              refcnt;\n};\n</code></pre> <p>and to convert it to two structs:</p> <pre><code>struct original_nsinfo {\n        pid_t                   pid;\n        pid_t                   tgid;\n        pid_t                   nstgid;\n        bool                    need_setns;\n        bool                    in_pidns;\n        char                    *mntns_path;\n        refcount_t              refcnt;\n};\n\nstruct nsinfo {\n        struct original_nsinfo *orig;\n};\n\n</code></pre> <p>To make the code more readable, this is done within a macro called <code>DECLARE_RC_STRUCT</code> and if <code>REFCNT_CHECKING</code> isn't enabled then the two struct version isn't used.</p> <p>Once we have two structs the reference count checking works by every time a <code>get</code> is done a malloc is done of the, in this case, <code>struct nsinfo</code> with the original pointer copied. Every time a <code>put</code> is done the pointer is cleared and the memory freed. To access the variables in the struct then the <code>orig</code> pointer must be used.</p> <p>What does this give us? Well if we do a <code>get</code> without a <code>put</code> then leak sanitizer will report the memory leak at the point the <code>get</code> was done. If we do a double <code>put</code> then there is a use after free, similarly for a use of a <code>put</code> struct's variable after it was <code>put</code>. Basically the intermediate pointer whose lifetime matches a get and put, gives us something approximating Resource Acquisition Is Initialization (RAII) in C. This is done without requiring additional tokens be passed or APIs change, but it does require changes around the reference counted struct and accessing its variables.</p> <p>Here is a real example from a failing test:</p> <pre><code>$ perf test 27 -vv\n 27: Share thread maps                                               :\n--- start ---\ntest child forked, pid 465481\n=================================================================\n==465481==ERROR: AddressSanitizer: heap-use-after-free on address 0x6020000050d0 at pc 0x5561bf855050 bp 0x7ffd2e049b50 sp 0x7ffd2e049b48\nREAD of size 8 at 0x6020000050d0 thread T0\n    #0 0x5561bf85504f in maps__refcnt tools/perf/util/maps.h:94\n    #1 0x5561bf855a08 in test__thread_maps_share tests/thread-maps-share.c:80\n    #2 0x5561bf80615f in run_test tests/builtin-test.c:238\n    #3 0x5561bf806404 in test_and_print tests/builtin-test.c:267\n    #4 0x5561bf807233 in __cmd_test tests/builtin-test.c:404\n    #5 0x5561bf808702 in cmd_test tests/builtin-test.c:561\n    #6 0x5561bf891a6f in run_builtin tools/perf/perf.c:323\n    #7 0x5561bf891fe0 in handle_internal_command tools/perf/perf.c:377\n    #8 0x5561bf8923a8 in run_argv tools/perf/perf.c:421\n    #9 0x5561bf892910 in main tools/perf/perf.c:537\n\n0x6020000050d0 is located 0 bytes inside of 8-byte region [0x6020000050d0,0x6020000050d8)\nfreed by thread T0 here:\n    #0 0x7fe6de4b76a8 in __interceptor_free libsanitizer/asan/asan_malloc_linux.cpp:52\n    #1 0x5561bf992736 in maps__put util/maps.c:196\n    #2 0x5561bf9b4d9e in thread__delete util/thread.c:92\n    #3 0x5561bf9b50ff in thread__put util/thread.c:151\n    #4 0x5561bf8559f9 in test__thread_maps_share tests/thread-maps-share.c:79\n    #5 0x5561bf80615f in run_test tests/builtin-test.c:238\n    #6 0x5561bf806404 in test_and_print tests/builtin-test.c:267\n    #7 0x5561bf807233 in __cmd_test tests/builtin-test.c:404\n    #8 0x5561bf808702 in cmd_test tests/builtin-test.c:561\n    #9 0x5561bf891a6f in run_builtin tools/perf/perf.c:323\n    #10 0x5561bf891fe0 in handle_internal_command tools/perf/perf.c:377\n    #11 0x5561bf8923a8 in run_argv tools/perf/perf.c:421\n    #12 0x5561bf892910 in main tools/perf/perf.c:537\n\npreviously allocated by thread T0 here:\n    #0 0x7fe6de4b89cf in __interceptor_malloc libsanitizer/asan/asan_malloc_linux.cpp:69\n    #1 0x5561bf9924c2 in maps__new util/maps.c:168\n    #2 0x5561bf9b4878 in thread__init_maps util/thread.c:27\n    #3 0x5561bf97ccdf in ____machine__findnew_thread util/machine.c:658\n    #4 0x5561bf97ce02 in __machine__findnew_thread util/machine.c:677\n    #5 0x5561bf97ce72 in machine__findnew_thread util/machine.c:687\n    #6 0x5561bf85518f in test__thread_maps_share tests/thread-maps-share.c:34\n    #7 0x5561bf80615f in run_test tests/builtin-test.c:238\n    #8 0x5561bf806404 in test_and_print tests/builtin-test.c:267\n    #9 0x5561bf807233 in __cmd_test tests/builtin-test.c:404\n    #10 0x5561bf808702 in cmd_test tests/builtin-test.c:561\n    #11 0x5561bf891a6f in run_builtin tools/perf/perf.c:323\n    #12 0x5561bf891fe0 in handle_internal_command tools/perf/perf.c:377\n    #13 0x5561bf8923a8 in run_argv tools/perf/perf.c:421\n    #14 0x5561bf892910 in main tools/perf/perf.c:537\n\nSUMMARY: AddressSanitizer: heap-use-after-free tools/perf/util/maps.h:94 in maps__refcnt\nShadow bytes around the buggy address:\n  0x0c047fff89c0: fa fa 00 00 fa fa 00 fa fa fa 00 00 fa fa 00 fa\n  0x0c047fff89d0: fa fa 00 fa fa fa 00 00 fa fa 00 02 fa fa 00 00\n  0x0c047fff89e0: fa fa 00 fa fa fa 00 06 fa fa 00 03 fa fa 00 02\n  0x0c047fff89f0: fa fa 00 05 fa fa 00 02 fa fa 00 fa fa fa 00 00\n  0x0c047fff8a00: fa fa 00 00 fa fa 00 00 fa fa 00 00 fa fa 00 fa\n=&gt;0x0c047fff8a10: fa fa 01 fa fa fa fd fa fa fa[fd]fa fa fa 03 fa\n  0x0c047fff8a20: fa fa 00 fa fa fa 03 fa fa fa 00 fa fa fa 03 fa\n  0x0c047fff8a30: fa fa 00 fa fa fa 03 fa fa fa 00 fa fa fa fd fd\n  0x0c047fff8a40: fa fa 03 fa fa fa 00 fa fa fa fd fd fa fa 00 fa\n  0x0c047fff8a50: fa fa 00 fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff8a60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n==465481==ABORTING\ntest child finished with 1\n---- end ----\nShare thread maps: FAILED!\n</code></pre> <p>So what we see in:</p> <pre><code>READ of size 8 at 0x6020000050d0 thread T0\n    #0 0x5561bf85504f in maps__refcnt tools/perf/util/maps.h:94\n    #1 0x5561bf855a08 in test__thread_maps_share tests/thread-maps-share.c:80\n</code></pre> <p>is that the test is using a struct after it was <code>put</code>, the use is in the header file accessor function but the test code thread-maps-share.c line 80 calls this. The put happening on the line before:</p> <pre><code>freed by thread T0 here:\n    #0 0x7fe6de4b76a8 in __interceptor_free libsanitizer/asan/asan_malloc_linux.cpp:52\n    #1 0x5561bf992736 in maps__put util/maps.c:196\n    #2 0x5561bf9b4d9e in thread__delete util/thread.c:92\n    #3 0x5561bf9b50ff in thread__put util/thread.c:151\n    #4 0x5561bf8559f9 in test__thread_maps_share tests/thread-maps-share.c:79\n\n</code></pre> <p>We can even see the location of the get:</p> <pre><code>previously allocated by thread T0 here:\n    #0 0x7fe6de4b89cf in __interceptor_malloc libsanitizer/asan/asan_malloc_linux.cpp:69\n    #1 0x5561bf9924c2 in maps__new util/maps.c:168\n    #2 0x5561bf9b4878 in thread__init_maps util/thread.c:27\n    #3 0x5561bf97ccdf in ____machine__findnew_thread util/machine.c:658\n    #4 0x5561bf97ce02 in __machine__findnew_thread util/machine.c:677\n    #5 0x5561bf97ce72 in machine__findnew_thread util/machine.c:687\n    #6 0x5561bf85518f in test__thread_maps_share tests/thread-maps-share.c:34\n</code></pre> <p>So we've diagnosed a use after <code>put</code>, we now just need to send a patch making sure that the <code>put</code> happens later than the use.</p>"},{"location":"todo/","title":"Todo","text":"<ul> <li> <p>Enable callchains for guests (used by perf kvm). At least doing this for the guest kernel should be very possible.</p> </li> <li> <p>The feature tests should be performed only when a file that needs those tests, or at least only when some .c or .h file will be rebuilt</p> <ul> <li>An initial step would be for 'make install-doc' not to run the feature tests, there it is not needed at all.</li> </ul> </li> <li> <p>Packages needed for the build should be checked before we start building object files, such as bison (bpetkov)</p> </li> <li> <p>Forward port the page fault tracepoints and use it in 'trace':</p> <ul> <li>This link need to be fixed! 32ba4abf60ae</li> </ul> </li> <li> <p>Use Kconfig to allow selecting features and build minimal version of perf, e.g. one with just 'record' for use in embedded platforms.</p> <ul> <li>David Ahern prototyped this, dig those patches and update them.</li> </ul> </li> <li> <p>Cherry pick the plugin support in libtraceevent.</p> </li> <li> <p>Add build id support in PERF_RECORD_MMAP, so that we can support long running sessions where update of components may take place.</p> </li> <li> <p>Allow automatic downloading of DSOs with richer symtabs and DWARF info from debuginfo servers such as darkserver (https://fedoraproject.org/wiki/Darkserver).</p> </li> <li> <p>Limit the size of the build id cache (~/.debug), in a way similar to how ccache manages its cache.</p> </li> <li> <p>Adopt Vince Weaver's suite of tests in 'perf test'</p> <ul> <li>Latest perf_event_tests suites on Github</li> </ul> </li> <li> <p>Add reference counters to the dso and thread structs, so that in tools like 'top' we can remove unused threads from the dead_threads list and also unload symbol tables not referenced by any maps.</p> </li> <li> <p>Accumulate callchain info in order to get cumulative period info like 'sysprof'.</p> </li> <li> <p><code>Add --sort addr</code></p> </li> <li> <p>Systemtap SDT suppport in 'perf probe'</p> </li> <li> <p>Move build-id trimming from perf-record to perf-archive:</p> <ul> <li>Just write the build-id for all DSOs, without trying to process all samples at perf-record time to find out which DSOs had samples and thus should be included in the perf.data build-id header</li> <li>At perf archive time, process all samples and trim the result, so that the tarball is smaller.</li> <li>Perhaps even an heuristic to figure out if the savings would be worth the trouble of processing all samples, i.e. look at the build-id table and do the math to figure out the sum of file sizes, if it is below some threshold, don't process the samples, just pack those files straight away, doing the sample processing only if it is more than that threshold.</li> </ul> </li> <li> <p>Resolve samples in callchains to DSOs and stash its build ids in the perf.data file header (acme)</p> </li> <li> <p>Implement --initial-delay, already available in 'perf stat', on 'perf trace'.</p> </li> <li> <p>Fix 'perf top --stdio -g' to limit the number of lines displayed, as it is not considering the callchains, perhaps we need to wire this up with the logic for '--max-stack', that is already available for 'perf top'. The problem is that it scrolls the screen, we can't see the top entries.</p> </li> <li> <p>What I want is that if I am on bar(), it annotates bar(), no samples just the call site (obtained from the callchain) dissassembly. This is useful because in many cases there maybe multiple call sites within a function and there maybe inlines in between. Hard to track down if you cannot figure out the surrounding addresses of the call site. (Request made by Stephane Eranian)</p> </li> <li> <p>Check for control+C, Q, when processing events in 'perf report', so that we can exit the tool when processing big files (acme)</p> </li> <li> <p>Adopt the kernel ERR_PTR() macro to avoid passing pointer addresses to return pointers from functions, instead use return pointer or return ERR_PTR(ENOENT), for instance, see include/linux/err.h in the kernel sources. (acme)</p> </li> <li> <p>Adopt the Hints warnings provided by 'perf trace' for permission checks in the other tools (acme)</p> </li> <li> <p>'perf top' should be, just like the other tools (trace, stat, record), able to start a workload to observe it. I.e. 'perf top -e probe_perf:map__get,probe_perf:map__put perf top' should work.</p> </li> <li> <p>When viewing multiple events (say, perf top -e cycles,instructions) in non-grouped mode (the default) list the events sorted by number of samples, nowadays I think it retains the evlist linked list order, i.e. how the user specified it in the command line. (From a conversation between acme and fbl)</p> </li> <li> <p>Don't stop the build tests when some devel package required for one of the tests is not present, just skip that test, warning the user about it. I.e. in 'make -C tools/perf build-test' (acme)</p> </li> <li> <p>Record which 'make build-test' tests fail the most, and then run it in order of previous failures. Recording it in each test machine helps running the tests that fails the most on specific build environment, i.e. some distro may fail more frequently some tests than others. Do this for 'perf test' as well. And make it a command line selectable behaviour, as sometimes we're not interested in those, just checking if something else that usually passes, stopped passing.</p> </li> <li> <p>Check if the objdump call in annotate worked or not, providing a popup window telling it didn't work, to test, just uninstall binutils or otherwise remove objdump from the path (acme)</p> </li> <li> <p>Introduce perf_evlist__strerror_create_maps() to provide more informative error messages for when a thread specified via -p in top/record doesn't exist, etc. (acme)</p> </li> <li> <p>Validade the CPU before passing to the kernel, i.e. 'perf top -C 10000' returns -EINVAL at sys_perf_event_open for something we could have validated beforehand (acme)</p> </li> <li> <p>Improve error message for 'perf record --call-graph dwarf' on an old kernel, say 3.9 on fedora 17, it should use perf_missing_features to notice that the perf_event_attr members needed for DWARF callchains are not present instead of plain telling that an invalid option was used (acme)</p> </li> <li> <p>Use '-e msr/smi/' in 'perf trace' if available, will be nice in a 'strace' like tool to show that in addition to syscalls, by default. (acme)</p> </li> <li> <p>Improve git pre-commit hook script to check for OPTION() with -- in its name, to fix bugs like ad16511b0e40 (\"perf mem: Add -U/-K (--all-user/--all-kernel) options\") (acme)</p> </li> <li> <p>Use __printf(a, b) to annotate applicable functions, see tools/include/compiler-gcc.h and source code in the kernel tree to see examples (acme).</p> </li> <li> <p>Accessing symtabs in containers from the host, watch Brendan's talk (link to the moment he describes it) to see the description of the problem and how to fix it (acme)</p> </li> <li> <p>perf probe tab completion, considering -x for a userspace binary or without it for kernel symbols, to allow this to work: <code>$ perf probe -x ~/bin/perf -L trace__</code> (acme)</p> </li> <li> <p>Use perf probe -x ~/bin/perf -F trace__* to get the possible functions for the tab completion (acme)</p> </li> </ul>"},{"location":"todo/#old-entries","title":"Old entries","text":"<ul> <li>Make the instruction augmentation in the annotate browser platform specific.<ul> <li>Right now they are x86 specific but are in the common code. DONE</li> </ul> </li> <li>Factorize the multidimensional sorting between perf report and annotate (will be used by perf trace)</li> <li>Implement a perf cmp (profile comparison between two perf.data) (DONE, its called 'perf diff')</li> <li>Implement a perf view (GUI) (Partially done, see 'perf report --gtk')</li> <li>Make pressing 'V' multiple times to go on cycling thru various verbosity levels in 'perf top', so that info that is present in 'perf top -v' can be obtained without having to restart the tool (acme). (This link need to be fixed! DONE)</li> <li>Use the highest precision level available by default, e.g.: cycles:pp (DONE)</li> <li>Enhance perf trace:<ul> <li>Handle the cpu field</li> <li>Handle the timestamp</li> <li>Use the in-perf ip -&gt; symbol resolving</li> <li>Use the in-perf pid -&gt; cmdline resolving</li> <li>Implement multidimensional sorting by field name</li> </ul> </li> </ul>"},{"location":"top-down-analysis/","title":"Top-down analysis with the perf tool","text":"<p>Note, the description here is for Linux 6.1. Earlier versions of the perf tool supported top-down analysis but due to naming inconsistencies in old versions, Linux 6.1 is focused upon on this page.</p>"},{"location":"top-down-analysis/#what-is-top-down-analysis","title":"What is top-down analysis?","text":"<p>Top-down analysis is an approach for identifying software performance bottlenecks. It is described in A Top-Down method for performance analysis and counters architecture but is often come across in Appendix B of Intel's Optimization Reference Manual in their software development manuals. The approach gathers a group of metrics and from these a problematic metric is identified. A group of metrics associated with the problematic metric are then measured drilling down to the metric/issue that identifies the performance problem.</p> <p>More recent Intel processors feature improvements for top-down analysis, the most recent being Timed Process Event Based Sampling (TPEBS). A description for using perf from Intel is given here.</p>"},{"location":"top-down-analysis/#starting-at-the-top","title":"Starting at the top","text":"<p>In this tutorial perf bench mem memcpy will be used for the <code>&lt;benchmark&gt;</code>. First of all gather the level 1 metrics:</p> <pre><code>  $ perf stat -M TopdownL1 &lt;benchmark&gt;\n</code></pre> <p>The output will be like:</p> <pre><code>  $ perf stat -M TopdownL1 perf bench mem memcpy\n\n  # Running 'mem/memcpy' benchmark:\n  # function 'default' (Default memcpy() provided by glibc)\n  # Copying 1MB bytes ...\n\n         5.677689 GB/sec\n  # function 'x86-64-unrolled' (unrolled memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         5.425347 GB/sec\n  # function 'x86-64-movsq' (movsq-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         6.141903 GB/sec\n  # function 'x86-64-movsb' (movsb-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         7.454676 GB/sec\n\n   Performance counter stats for 'perf bench mem memcpy':\n\n          72,813,380      TOPDOWN.SLOTS                    #     25.5 %  tma_retiring        \n                                                    #     44.3 %  tma_backend_bound   \n                                                    #     24.3 %  tma_frontend_bound  \n                                                    #      6.0 %  tma_bad_speculation \n          18,560,273      topdown-retiring                 #     25.5% Retiring              \n          17,703,645      topdown-fe-bound                 #     24.3% Frontend Bound        \n              43,171      INT_MISC.UOP_DROPPING                                              \n          31,980,778      topdown-be-bound                 #     43.9% Backend Bound         \n              55,052      cpu/INT_MISC.RECOVERY_CYCLES,cmask=1,edge/                                   \n           4,568,682      topdown-bad-spec                 #      6.3% Bad Speculation       \n\n         0.012820482 seconds time elapsed\n\n         0.004290000 seconds user\n         0.008581000 seconds sys\n</code></pre> <p>The TopdownL1 metrics may be computed by default if no metric is provided:</p> <pre><code>  $ perf stat perf bench mem memcpy\n  # Running 'mem/memcpy' benchmark:\n  # function 'default' (Default memcpy() provided by glibc)\n  # Copying 1MB bytes ...\n\n        16.837284 GB/sec\n  # function 'x86-64-unrolled' (unrolled memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n        16.551907 GB/sec\n  # function 'x86-64-movsq' (movsq-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n        19.148284 GB/sec\n\n   Performance counter stats for 'perf bench mem memcpy':\n\n               21.38 msec task-clock                       #    0.927 CPUs utilized             \n                   7      context-switches                 #  327.406 /sec                      \n                   0      cpu-migrations                   #    0.000 /sec                      \n               6,247      page-faults                      #  292.187 K/sec                     \n          94,684,914      cycles                           #    4.429 GHz                       \n         117,788,965      instructions                     #    1.24  insn per cycle            \n          25,949,650      branches                         #    1.214 G/sec                     \n             252,622      branch-misses                    #    0.97% of all branches           \n                          TopdownL1                 #     45.8 %  tma_backend_bound      \n                                                    #     11.2 %  tma_bad_speculation    \n                                                    #     18.2 %  tma_frontend_bound     \n                                                    #     24.8 %  tma_retiring           \n\n         0.023069998 seconds time elapsed\n\n         0.000000000 seconds user\n         0.023455000 seconds sys\n</code></pre> <p>On the right of the counter values are the metrics. For TopdownL1 there are the metrics tma_retiring, tma_backend_bound, tma_frontend_bound and tma_bad_speculation. For the benchmark tma_backend_bound is the largest. We can drill down into this metric by adding the suffix _group to the metric name:</p> <pre><code>  $ perf stat -M tma_backend_bound_group perf bench mem memcpy\n\n  # Running 'mem/memcpy' benchmark:\n  # function 'default' (Default memcpy() provided by glibc)\n  # Copying 1MB bytes ...\n\n         6.781684 GB/sec\n  # function 'x86-64-unrolled' (unrolled memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         5.033827 GB/sec\n  # function 'x86-64-movsq' (movsq-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         6.688784 GB/sec\n  # function 'x86-64-movsb' (movsb-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         6.829108 GB/sec\n\n   Performance counter stats for 'perf bench mem memcpy':\n\n          69,746,420      TOPDOWN.SLOTS                    #     24.9 %  tma_core_bound      \n                                                    #     17.5 %  tma_memory_bound    \n          18,599,045      topdown-retiring                 #     26.7% Retiring              \n           1,253,770      EXE_ACTIVITY.BOUND_ON_STORES                                       \n          17,504,983      topdown-fe-bound                 #     25.1% Frontend Bound        \n           1,769,443      EXE_ACTIVITY.1_PORTS_UTIL                                          \n          29,266,144      topdown-be-bound                 #     42.0% Backend Bound         \n              55,050      cpu/INT_MISC.RECOVERY_CYCLES,cmask=1,edge/                                   \n           2,934,845      CYCLE_ACTIVITY.STALLS_MEM_ANY                                      \n           6,667,954      CYCLE_ACTIVITY.STALLS_TOTAL                                        \n           1,775,168      EXE_ACTIVITY.2_PORTS_UTIL                                          \n           4,376,245      topdown-bad-spec                 #      6.3% Bad Speculation       \n\n         0.012655913 seconds time elapsed\n\n         0.008451000 seconds user\n         0.004225000 seconds sys\n</code></pre> <p>This time tma_core_bound is the largest TMA metric and so we drill down in to it:</p> <pre><code>  $ perf stat -M tma_core_bound_group perf bench mem memcpy\n  # Running 'mem/memcpy' benchmark:\n  # function 'default' (Default memcpy() provided by glibc)\n  # Copying 1MB bytes ...\n\n         6.510417 GB/sec\n  # function 'x86-64-unrolled' (unrolled memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         6.065606 GB/sec\n  # function 'x86-64-movsq' (movsq-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         7.512019 GB/sec\n  # function 'x86-64-movsb' (movsb-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         6.781684 GB/sec\n\n   Performance counter stats for 'perf bench mem memcpy':\n\n        70,285,910      TOPDOWN.SLOTS                    #     31.2 %  tma_ports_utilization\n        18,467,278      topdown-retiring                 #     26.3% Retiring              \n         2,165,618      cpu/EXE_ACTIVITY.3_PORTS_UTIL,umask=0x80/                                   \n        17,364,754      topdown-fe-bound                 #     24.7% Frontend Bound        \n         1,754,496      EXE_ACTIVITY.1_PORTS_UTIL                                          \n        30,043,781      topdown-be-bound                 #     42.7% Backend Bound         \n        14,057,182      CPU_CLK_UNHALTED.THREAD          #      0.1 %  tma_divider         \n         3,054,356      CYCLE_ACTIVITY.STALLS_MEM_ANY                                      \n         6,685,779      CYCLE_ACTIVITY.STALLS_TOTAL                                        \n         1,767,046      EXE_ACTIVITY.2_PORTS_UTIL                                          \n         4,410,096      topdown-bad-spec                 #      6.3% Bad Speculation       \n             9,354      ARITH.DIVIDER_ACTIVE                                               \n\n       0.011282941 seconds time elapsed\n\n       0.000000000 seconds user\n       0.011349000 seconds sys\n</code></pre> <p>And then tma_ports_utilization:</p> <pre><code>  $ perf stat -M tma_ports_utilization_group perf bench mem memcpy\n\n  # Running 'mem/memcpy' benchmark:\n  # function 'default' (Default memcpy() provided by glibc)\n  # Copying 1MB bytes ...\n\n         6.554111 GB/sec\n  # function 'x86-64-unrolled' (unrolled memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...  \n\n         5.710892 GB/sec\n  # function 'x86-64-movsq' (movsq-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         6.467301 GB/sec\n  # function 'x86-64-movsb' (movsb-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n         6.300403 GB/sec\n\n   Performance counter stats for 'perf bench mem memcpy':\n\n         1,812,959      RESOURCE_STALLS.SCOREBOARD       #     16.6 %  tma_ports_utilized_0  (34.73%)\n         1,991,726      cpu/EXE_ACTIVITY.3_PORTS_UTIL,umask=0x80/                                     (34.73%)\n        14,159,441      CPU_CLK_UNHALTED.THREAD                                              (34.73%)\n         6,689,757      CYCLE_ACTIVITY.STALLS_TOTAL                                          (34.73%)\n         3,838,402      CYCLE_ACTIVITY.STALLS_MEM_ANY                                        (34.73%)\n         3,282,823      UOPS_EXECUTED.CYCLES_GE_3        #     22.9 %  tma_ports_utilized_3m  (52.98%)\n        14,324,185      CPU_CLK_UNHALTED.THREAD                                              (52.98%)\n        14,599,955      CPU_CLK_UNHALTED.THREAD          #     12.5 %  tma_ports_utilized_2  (65.27%)\n         1,823,495      EXE_ACTIVITY.2_PORTS_UTIL                                            (65.27%)\n         1,819,926      EXE_ACTIVITY.1_PORTS_UTIL        #     12.5 %  tma_ports_utilized_1  (79.65%)\n        14,591,940      CPU_CLK_UNHALTED.THREAD                                              (79.65%)\n\n       0.012931961 seconds time elapsed\n\n       0.008647000 seconds user\n       0.004323000 seconds sys\n</code></pre> <p>For tma_ports_utilization_group we can see numbers like (34.73%) that indicate there were insufficient performance counters to gather the metric and the performance counters had to be multiplexed during the benchmark run. Multiplexing lowers accuracy and can be worked around by just measuring the metric on its own:</p> <pre><code>  $ perf stat -M tma_ports_utilized_0 perf bench mem memcpy\n  ...\n         2,268,815      RESOURCE_STALLS.SCOREBOARD       #     19.8 %  tma_ports_utilized_0\n</code></pre> <p>Finally we see tma_ports_utilized_3m as the largest metric. Looking at <code>perf list</code>, (sometimes <code>perf list -v</code>) we can see the metrics meaning:</p> <ul> <li> <p>tma_ports_utilized_3m</p> <p>This metric represents fraction of cycles CPU executed total of 3 or more uops per cycle on all execution ports (Logical Processor cycles since ICL, Physical Core cycles otherwise). Sample with: UOPS_EXECUTED.CYCLES_GE_3</p> </li> </ul> <p>The 'Sample with' event can be used with <code>perf record</code> to identify where in the benchmark the performance bottleneck is:</p> <pre><code>  $ perf record -e UOPS_EXECUTED.CYCLES_GE_3 perf bench mem memcpy; perf report\n\n  # Running 'mem/memcpy' benchmark:\n  # function 'default' (Default memcpy() provided by glibc)\n  # Copying 1MB bytes ...\n\n        23.251488 GB/sec\n  # function 'x86-64-unrolled' (unrolled memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n        23.251488 GB/sec\n  # function 'x86-64-movsq' (movsq-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n        28.722426 GB/sec\n  # function 'x86-64-movsb' (movsb-based memcpy() in arch/x86/lib/memcpy_64.S)\n  # Copying 1MB bytes ...\n\n        27.901786 GB/sec\n  [ perf record: Woken up 1 times to write data ]\n  [ perf record: Captured and wrote 0.034 MB perf.data (1 samples) ]\n\n  # To display the perf.data header info, please use --header/--header-only options.  \n  #\n  #\n  # Total Lost Samples: 0  \n  #\n  # Samples: 1  of event 'UOPS_EXECUTED.CYCLES_GE_3/period=1000000/'\n  # Event count (approx.): 2000003 \n  #\n  # Overhead  Command     Shared Object  Symbol         \n  # ........  ..........  .............  ...............  \n  #\n     100.00%  mem-memcpy  perf           [.] memcpy_orig\n</code></pre>"},{"location":"tutorial/","title":"Linux kernel profiling with <code>perf</code>","text":"<p>Linux kernel profiling with perf</p>"},{"location":"tutorial/#introduction","title":"Introduction","text":"<p>Perf is a profiler tool for Linux 2.6+ based systems that abstracts away CPU hardware differences in Linux performance measurements and presents a simple commandline interface. Perf is based on the <code>perf_events</code> interface exported by recent versions of the Linux kernel. This article demonstrates the <code>perf</code> tool through example runs. Output was obtained on a Ubuntu 11.04 system with kernel 2.6.38-8-generic results running on an HP 6710b with dual-core Intel Core2 T7100 CPU. For readability, some output is abbreviated using ellipsis (<code>[...]</code>).</p>"},{"location":"tutorial/#commands","title":"Commands","text":"<p>The perf tool offers a rich set of commands to collect and analyze performance and trace data. The command line usage is reminiscent of <code>git</code> in that there is a generic tool, <code>perf</code>, which implements a set of commands: <code>stat</code>, <code>record</code>, <code>report</code>, [...]</p> <p>The list of supported commands:</p> <pre><code>perf\n\n  usage: perf [--version] [--help] [OPTIONS] COMMAND [ARGS]\n\n The most commonly used perf commands are:\n   annotate        Read perf.data (created by perf record) and display annotated code\n   archive         Create archive with object files with build-ids found in perf.data file\n   bench           General framework for benchmark suites\n   buildid-cache   Manage build-id cache.\n   buildid-list    List the buildids in a perf.data file\n   c2c             Shared Data C2C/HITM Analyzer.\n   config          Get and set variables in a configuration file.\n   daemon          Run record sessions on background\n   data            Data file related processing\n   diff            Read perf.data files and display the differential profile\n   evlist          List the event names in a perf.data file\n   ftrace          simple wrapper for kernel's ftrace functionality\n   inject          Filter to augment the events stream with additional information\n   iostat          Show I/O performance metrics\n   kallsyms        Searches running kernel for symbols\n   kvm             Tool to trace/measure kvm guest os\n   list            List all symbolic event types\n   mem             Profile memory accesses\n   record          Run a command and record its profile into perf.data\n   report          Read perf.data (created by perf record) and display the profile\n   script          Read perf.data (created by perf record) and display trace output\n   stat            Run a command and gather performance counter statistics\n   test            Runs sanity tests.\n   top             System profiling tool.\n   version         display the version of perf binary\n   probe           Define new dynamic tracepoints\n\n See 'perf help COMMAND' for more information on a specific command.\n</code></pre> <p>Certain commands require special support in the kernel and may not be available. To obtain the list of options for each command, simply type the command name followed by <code>-h</code>:</p> <pre><code>perf stat -h\n\n usage: perf stat [&lt;options&gt;] [&lt;command&gt;]\n\n    -e, --event &lt;event&gt;   event selector. use 'perf list' to list available events\n    -i, --no-inherit      child tasks do not inherit counters\n    -p, --pid &lt;n&gt;         stat events on existing process id\n    -t, --tid &lt;n&gt;         stat events on existing thread id\n    -a, --all-cpus        system-wide collection from all CPUs\n    -c, --scale           scale/normalize counters\n    -v, --verbose         be more verbose (show counter open errors, etc)\n    -r, --repeat &lt;n&gt;      repeat command and print average + stddev (max: 100)\n    -n, --null            null run - dont start any counters\n    -B, --big-num         print large numbers with thousands' separators\n</code></pre>"},{"location":"tutorial/#events","title":"Events","text":"<p>The <code>perf</code> tool supports a list of measurable events.  The tool and underlying kernel interface can measure events coming from different sources. For instance, some event are pure kernel counters, in this case they are called software events. Examples include: context-switches, minor-faults.</p> <p>Another source of events is the processor itself and its Performance Monitoring Unit (PMU). It provides a list of events to measure micro-architectural events such as the number of cycles, instructions retired, L1 cache misses and so on. Those events are called PMU hardware events or hardware events for short. They vary with each processor type and model.</p> <p>The perf_events interface also provides a small set of common hardware events monikers. On each processor, those events get mapped onto an actual events provided by the CPU, if they exists, otherwise the event cannot be used. Somewhat confusingly, these are also called hardware events and hardware cache events.</p> <p>Finally, there are also tracepoint events which are implemented by the kernel <code>ftrace</code> infrastructure. Those are only available with the 2.6.3x and newer kernels.</p> <p>To obtain a list of supported events:</p> <pre><code>perf list\n\nList of pre-defined events (to be used in -e):\n\n cpu-cycles OR cycles                       [Hardware event]\n instructions                               [Hardware event]\n cache-references                           [Hardware event]\n cache-misses                               [Hardware event]\n branch-instructions OR branches            [Hardware event]\n branch-misses                              [Hardware event]\n bus-cycles                                 [Hardware event]\n ref-cycles                                 [Hardware event]\n\n cpu-clock                                  [Software event]\n task-clock                                 [Software event]\n page-faults OR faults                      [Software event]\n minor-faults                               [Software event]\n major-faults                               [Software event]\n context-switches OR cs                     [Software event]\n cpu-migrations OR migrations               [Software event]\n alignment-faults                           [Software event]\n emulation-faults                           [Software event]\n bpf-output                                 [Software event]\n cgroup-switches                            [Software event]\n dummy                                      [Software event]\n\n L1-dcache-loads                            [Hardware cache event]\n L1-dcache-load-misses                      [Hardware cache event]\n L1-dcache-stores                           [Hardware cache event]\n L1-dcache-store-misses                     [Hardware cache event]\n L1-dcache-prefetches                       [Hardware cache event]\n L1-dcache-prefetch-misses                  [Hardware cache event]\n L1-icache-loads                            [Hardware cache event]\n L1-icache-load-misses                      [Hardware cache event]\n L1-icache-prefetches                       [Hardware cache event]\n L1-icache-prefetch-misses                  [Hardware cache event]\n LLC-loads                                  [Hardware cache event]\n LLC-load-misses                            [Hardware cache event]\n LLC-stores                                 [Hardware cache event]\n LLC-store-misses                           [Hardware cache event]\n\n LLC-prefetch-misses                        [Hardware cache event]\n dTLB-loads                                 [Hardware cache event]\n dTLB-load-misses                           [Hardware cache event]\n dTLB-stores                                [Hardware cache event]\n dTLB-store-misses                          [Hardware cache event]\n dTLB-prefetches                            [Hardware cache event]\n dTLB-prefetch-misses                       [Hardware cache event]\n iTLB-loads                                 [Hardware cache event]\n iTLB-load-misses                           [Hardware cache event]\n branch-loads                               [Hardware cache event]\n branch-load-misses                         [Hardware cache event]\n\n rNNN (see 'perf list --help' on how to encode it) [Raw hardware event descriptor]\n\n mem:&lt;addr&gt;[:access]                        [Hardware breakpoint]\n\n kvmmmu:kvm_mmu_pagetable_walk              [Tracepoint event]\n\n [...]\n\n sched:sched_stat_runtime                   [Tracepoint event]\n sched:sched_pi_setprio                     [Tracepoint event]\n syscalls:sys_enter_socket                  [Tracepoint event]\n syscalls:sys_exit_socket                   [Tracepoint event]\n\n [...]\n\n</code></pre> <p>An event can have sub-events (or unit masks). On some processors and for some events, it may be possible to combine unit masks and measure when either sub-event occurs. Finally, an event can have modifiers, i.e., filters which alter when or how the event is counted.</p>"},{"location":"tutorial/#hardware-events","title":"Hardware events","text":"<p>PMU hardware events are CPU specific and documented by the CPU vendor. The <code>perf</code> tool, if linked against the <code>libpfm4</code> the library provides some short description of the events. For a listing of PMU hardware events for Intel and AMD processors, see</p> <ul> <li>Intel PMU event tables: Appendix A of manual</li> <li>AMD PMU event table: section 3.14 of manual</li> </ul>"},{"location":"tutorial/#counting-with-perf-stat","title":"Counting with <code>perf stat</code>","text":"<p>For any of the supported events, perf can keep a running count during process execution. In counting modes, the occurrences of events are simply aggregated and presented on standard output at the end of an application run. To generate these statistics, use the <code>stat</code> command of <code>perf</code>. For instance:</p> <pre><code>perf stat -B dd if=/dev/zero of=/dev/null count=1000000\n\n1000000+0 records in\n1000000+0 records out\n512000000 bytes (512 MB) copied, 0.956217 s, 535 MB/s\n\n Performance counter stats for 'dd if=/dev/zero of=/dev/null count=1000000':\n\n            5,099 cache-misses             #      0.005 M/sec (scaled from 66.58%)\n          235,384 cache-references         #      0.246 M/sec (scaled from 66.56%)\n        9,281,660 branch-misses            #      3.858 %     (scaled from 33.50%)\n      240,609,766 branches                 #    251.559 M/sec (scaled from 33.66%)\n    1,403,561,257 instructions             #      0.679 IPC   (scaled from 50.23%)\n    2,066,201,729 cycles                   #   2160.227 M/sec (scaled from 66.67%)\n              217 page-faults              #      0.000 M/sec\n                3 CPU-migrations           #      0.000 M/sec\n               83 context-switches         #      0.000 M/sec\n       956.474238 task-clock-msecs         #      0.999 CPUs\n\n       0.957617512  seconds time elapsed\n\n</code></pre> <p>With no events specified, <code>perf stat</code> collects the common events listed above. Some are software events, such as <code>context-switches</code>, others are generic hardware events such as <code>cycles</code>. After the hash sign, derived metrics may be presented, such as 'IPC' (instructions per cycle).</p>"},{"location":"tutorial/#options-controlling-event-selection","title":"Options controlling event selection","text":"<p>It is possible to measure one or more events per run of the <code>perf</code> tool. Events are designated using their symbolic names followed by optional unit masks and modifiers. Event names, unit masks, and modifiers are case insensitive.</p> <p>By default, events are measured at both user and kernel levels:</p> <pre><code>perf stat -e cycles dd if=/dev/zero of=/dev/null count=100000\n</code></pre> <p>To measure only at the user level, it is necessary to pass a modifier:</p> <pre><code>perf stat -e cycles:u dd if=/dev/zero of=/dev/null count=100000\n</code></pre> <p>To measure both user and kernel (explicitly):</p> <pre><code>perf stat -e cycles:uk dd if=/dev/zero of=/dev/null count=100000\n</code></pre>"},{"location":"tutorial/#modifiers","title":"Modifiers","text":"<p>Events can optionally have a modifier by appending a colon and one or more modifiers. Modifiers allow the user to restrict when events are counted.</p> <p>To measure a PMU event and pass modifiers:</p> <pre><code>perf stat -e instructions:u dd if=/dev/zero of=/dev/null count=100000\n</code></pre> <p>In this example, we are measuring the number of instructions at the user level. Note that for actual events, the modifiers depends on the underlying PMU model. All modifiers can be combined at will. Here is a simple table to summarize the most common modifiers for Intel and AMD x86 processors.</p> Modifiers Description Example u monitor at priv level 3, 2, 1 (user) event:u k monitor at priv level 0 (kernel) event:k h monitor hypervisor events on a virtualization environment event:h H monitor host machine on a virtualization environment event:H G monitor guest machine on a virtualization environment event:G <p>All modifiers above are considered as a boolean (flag).</p>"},{"location":"tutorial/#hardware-events_1","title":"Hardware events","text":"<p>To measure an actual PMU as provided by the HW vendor documentation, pass the hexadecimal parameter code:</p> <pre><code>perf stat -e r1a8 -a sleep 1\n\nPerformance counter stats for 'sleep 1':\n\n            210,140 raw 0x1a8\n       1.001213705  seconds time elapsed\n</code></pre>"},{"location":"tutorial/#multiple-events","title":"multiple events","text":"<p>To measure more than one event, simply provide a comma-separated list with no space:</p> <pre><code>perf stat -e cycles,instructions,cache-misses [...]\n</code></pre> <p>There is no theoretical limit in terms of the number of events that can be provided. If there are more events than there are actual hw counters, the kernel will automatically multiplex them. There is no limit of the number of software events. It is possible to simultaneously measure events coming from different sources.</p> <p>However, given that there is one file descriptor used per event and either per-thread (per-thread mode) or per-cpu (system-wide), it is possible to reach the maximum number of open file descriptor per process as imposed by the kernel. In that case, perf will report an error. See the troubleshooting section for help with this matter.</p>"},{"location":"tutorial/#multiplexing-and-scaling-events","title":"multiplexing and scaling events","text":"<p>If there are more events than counters, the kernel uses time multiplexing (switch frequency = <code>HZ</code>, generally 100 or 1000) to give each event a chance to access the monitoring hardware. Multiplexing only applies to PMU events. With multiplexing, an event is not measured all the time. At the end of the run, the tool scales the count based on total time enabled vs time running. The actual formula is:</p> <p><code>final_count =  raw_count * time_enabled/time_running</code></p> <p>This provides an estimate of what the count would have been, had the event been measured during the entire run. It is very important to understand this is an estimate not an actual count. Depending on the workload, there will be blind spots which can introduce errors during scaling.</p> <p>Events are currently managed in round-robin fashion. Therefore each event will eventually get a chance to run. If there are N counters, then up to the first N events on the round-robin list are programmed into the PMU. In certain situations it may be less than that because some events may not be measured together or they compete for the same counter. Furthermore, the perf_events interface allows multiple tools to measure the same thread or CPU at the same time. Each event is added to the same round-robin list. There is no guarantee that all events of a tool are stored sequentially in the list.</p> <p>To avoid scaling (in the presence of only one active perf_event user), one can try and reduce the number of events. The following table provides the number of counters for a few common processors:</p> Processor Generic counters Fixed counters AMD Zen 6 0 ARM Cortex 6 0 Intel Core 2 3 Intel Nehalem 4 3 Intel SandyBridge 4 3 Intel Haswell 4 3 Intel Skylake 4 3 Intel Sunny Cove 8 5 Intel Willow Cove 8 5 Intel Golden Cove 8 5 Intel Raptor Cove 8 5 Generic counters can measure any events. Fixed counters can only measure one event. Some counters may be reserved for special purposes, such as a watchdog timer. <p>The following examples show the effect of scaling:</p> <pre><code>perf stat -B -e cycles,cycles ./noploop 1\n\n Performance counter stats for './noploop 1':\n\n    2,812,305,464 cycles\n    2,812,304,340 cycles\n\n       1.302481065  seconds time elapsed\n\n</code></pre> <p>Here, there is no multiplexing and thus no scaling. Let's add one more event:</p> <pre><code>perf stat -B -e cycles,cycles,cycles ./noploop 1\n\n Performance counter stats for './noploop 1':\n\n    2,809,725,593 cycles                    (scaled from 74.98%)\n    2,810,797,044 cycles                    (scaled from 74.97%)\n    2,809,315,647 cycles                    (scaled from 75.09%)\n\n       1.295007067  seconds time elapsed\n\n</code></pre> <p>There was multiplexing and thus scaling. It can be interesting to try and pack events in a way that guarantees that event A and B are always measured together. Although the perf_events kernel interface provides support for event grouping, the current <code>perf</code> tool does not.</p>"},{"location":"tutorial/#repeated-measurement","title":"Repeated measurement","text":"<p>It is possible to use <code>perf stat</code> to run the same test workload multiple times and get for each count, the standard deviation from the mean.</p> <pre><code>perf stat -r 5 sleep 1\n\n Performance counter stats for 'sleep 1' (5 runs):\n\n    &lt;not counted&gt; cache-misses\n           20,676 cache-references         #     13.046 M/sec   ( +-   0.658% )\n            6,229 branch-misses            #      0.000 %       ( +-  40.825% )\n    &lt;not counted&gt; branches\n    &lt;not counted&gt; instructions\n    &lt;not counted&gt; cycles\n              144 page-faults              #      0.091 M/sec   ( +-   0.139% )\n                0 CPU-migrations           #      0.000 M/sec   ( +-    -nan% )\n                1 context-switches         #      0.001 M/sec   ( +-   0.000% )\n         1.584872 task-clock-msecs         #      0.002 CPUs    ( +-  12.480% )\n\n       1.002251432  seconds time elapsed   ( +-   0.025% )\n\n</code></pre> <p>Here, <code>sleep</code> is run 5 times and the mean count for each event, along with ratio of std-dev/mean is printed.</p>"},{"location":"tutorial/#options-controlling-environment-selection","title":"Options controlling environment selection","text":"<p>The <code>perf</code> tool can be used to count events on a per-thread, per-process, per-cpu or system-wide basis. In per-thread mode, the counter only monitors the execution of a designated thread. When the thread is scheduled out, monitoring stops. When a thread migrated from one processor to another, counters are saved on the current processor and are restored on the new one.</p> <p>The per-process mode is a variant of per-thread where all threads of the process are monitored. Counts and samples are aggregated at the process level. The perf_events interface allows for automatic inheritance on <code>fork()</code> and <code>pthread_create()</code>. By default, the perf tool activates inheritance.</p> <p>In per-cpu mode, all threads running on the designated processors are monitored. Counts and samples are thus aggregated per CPU. An event is only monitoring one CPU at a time. To monitor across multiple processors, it is necessary to create multiple events.  The perf tool can aggregate counts and samples across multiple processors. It can also monitor only a subset of the processors.</p>"},{"location":"tutorial/#counting-and-inheritance","title":"Counting and inheritance","text":"<p>By default, <code>perf stat</code> counts for all threads of the process and subsequent child processes and threads. This can be altered using the <code>-i</code> option. It is not possible to obtain a count breakdown per-thread or per-process.</p>"},{"location":"tutorial/#processor-wide-mode","title":"Processor-wide mode","text":"<p>By default, <code>perf stat</code> counts in per-thread mode. To count on a per-cpu basis pass the <code>-a</code> option. When it is specified by itself, all online processors are monitored and counts are aggregated. For instance:</p> <pre><code>perf stat -B -ecycles:u,instructions:u -a dd if=/dev/zero of=/dev/null count=2000000\n\n2000000+0 records in\n2000000+0 records out\n1024000000 bytes (1.0 GB) copied, 1.91559 s, 535 MB/s\n\n Performance counter stats for 'dd if=/dev/zero of=/dev/null count=2000000':\n\n    1,993,541,603 cycles\n      764,086,803 instructions             #      0.383 IPC\n\n       1.916930613  seconds time elapsed\n</code></pre> <p>This measurement collects events <code>cycles</code> and <code>instructions</code> across all CPUs. The duration of the measurement is determined by the execution of <code>dd</code>. In other words, this measurement captures execution of the <code>dd</code> process and anything else than runs at the user level on all CPUs.</p> <p>To time the duration of the measurement without actively consuming cycles, it is possible to  use the =/usr/bin/sleep= command:</p> <pre><code>perf stat -B -ecycles:u,instructions:u -a sleep 5\n\n Performance counter stats for 'sleep 5':\n\n      766,271,289 cycles\n      596,796,091 instructions             #      0.779 IPC\n\n       5.001191353  seconds time elapsed\n\n</code></pre> <p>It is possible to restrict monitoring to a subset of the CPUS using the <code>-C</code> option. A list of CPUs to monitor can be passed. For instance, to measure on CPU0, CPU2 and CPU3:</p> <pre><code>perf stat -B -e cycles:u,instructions:u -a -C 0,2-3 sleep 5\n</code></pre> <p>The demonstration machine has only two CPUs, but we can limit to CPU 1.</p> <pre><code>perf stat -B -e cycles:u,instructions:u -a -C 1 sleep 5\n\n Performance counter stats for 'sleep 5':\n\n      301,141,166 cycles\n      225,595,284 instructions             #      0.749 IPC\n\n       5.002125198  seconds time elapsed\n\n</code></pre> <p>Counts are aggregated across all the monitored CPUs. Notice how the number of counted cycles and instructions are both halved when measuring a single CPU.</p>"},{"location":"tutorial/#attaching-to-a-running-process","title":"Attaching to a running process","text":"<p>It is possible to use perf to attach to an already running thread or process. This requires the permission to attach along with the thread or process ID. To attach to a process, the <code>-p</code> option must be the process ID. To attach to the sshd service that is commonly running on many Linux machines, issue:</p> <pre><code>ps ax | fgrep sshd\n\n 2262 ?        Ss     0:00 /usr/sbin/sshd -D\n 2787 pts/0    S+     0:00 fgrep --color=auto sshd\n\nperf stat -e cycles -p 2262 sleep 2\n\n Performance counter stats for process id '2262':\n\n    &lt;not counted&gt; cycles\n\n       2.001263149  seconds time elapsed\n\n</code></pre> <p>What determines the duration of the measurement is the command to execute. Even though we are attaching to a process, we can still pass the name of a command. It is used to time the measurement. Without it, <code>perf</code> monitors until it is killed. Also note that when attaching to a process, all threads of the process are monitored. Furthermore, given that inheritance is on by default, child processes or threads will also be monitored. To turn this off, you must use the <code>-i</code> option. It is possible to attach a specific thread within a process. By thread, we mean kernel visible thread. In other words, a thread visible by the <code>ps</code> or <code>top</code> commands. To attach to a thread, the <code>-t</code> option must be used. We look at <code>rsyslogd</code>, because it always runs on Ubuntu 11.04, with multiple threads.</p> <pre><code>ps -L ax | fgrep rsyslogd | head -5\n\n 889   889 ?        Sl     0:00 rsyslogd -c4\n 889   932 ?        Sl     0:00 rsyslogd -c4\n 889   933 ?        Sl     0:00 rsyslogd -c4\n 2796  2796 pts/0    S+     0:00 fgrep --color=auto rsyslogd\n\nperf stat -e cycles -t 932 sleep 2\n\n Performance counter stats for thread id '932':\n\n    &lt;not counted&gt; cycles\n\n       2.001037289  seconds time elapsed\n\n</code></pre> <p>In this example, the thread 932 did not run during the 2s of the measurement. Otherwise, we would see a count value. Attaching to kernel threads is possible, though not really recommended. Given that kernel threads tend to be pinned to a specific CPU, it is best to use the cpu-wide mode.</p>"},{"location":"tutorial/#options-controlling-output","title":"Options controlling output","text":"<p><code>perf stat</code> can modify output to suit different needs.</p>"},{"location":"tutorial/#pretty-printing-large-numbers","title":"Pretty printing large numbers","text":"<p>For most people, it is hard to read large numbers. With <code>perf stat</code>, it is possible to print large numbers using the comma separator for thousands (US-style). For that the <code>-B</code> option and the correct locale for <code>LC_NUMERIC</code> must be set. As the above example showed, Ubuntu already sets the locale information correctly. An explicit call looks as follows:</p> <pre><code>LC_NUMERIC=en_US.UTF8 perf stat -B -e cycles:u,instructions:u dd if=/dev/zero of=/dev/null count=10000000\n\n100000+0 records in\n100000+0 records out\n51200000 bytes (51 MB) copied, 0.0971547 s, 527 MB/s\n\n Performance counter stats for 'dd if=/dev/zero of=/dev/null count=100000':\n\n       96,551,461 cycles\n       38,176,009 instructions             #      0.395 IPC\n\n       0.098556460  seconds time elapsed\n\n</code></pre>"},{"location":"tutorial/#machine-readable-output","title":"Machine readable output","text":"<p><code>perf stat</code> can also print counts in a format that can easily be imported into a spreadsheet or parsed by scripts. The <code>-x</code> option alters the format of the output and allows users to pass a field delimiter. This makes is easy to produce CSV-style output:</p> <pre><code>perf stat  -x, date\n\nThu May 26 21:11:07 EDT 2011\n884,cache-misses\n32559,cache-references\n&lt;not counted&gt;,branch-misses\n&lt;not counted&gt;,branches\n&lt;not counted&gt;,instructions\n&lt;not counted&gt;,cycles\n188,page-faults\n2,CPU-migrations\n0,context-switches\n2.350642,task-clock-msecs\n</code></pre> <p>Note that the <code>-x</code> option is not compatible with <code>-B</code>.</p>"},{"location":"tutorial/#sampling-with-perf-record","title":"Sampling with <code>perf record</code>","text":"<p>The <code>perf</code> tool can be used to collect profiles on per-thread, per-process and per-cpu basis.</p> <p>There are several commands associated with sampling: <code>record</code>, <code>report</code>, <code>annotate</code>. You must first collect the samples using <code>perf record</code>. This generates an output file called <code>perf.data</code>. That file can then be analyzed, possibly on another machine, using the <code>perf report</code> and <code>perf annotate</code> commands. The model is fairly similar to that of OProfile.</p>"},{"location":"tutorial/#event-based-sampling-overview","title":"Event-based sampling overview","text":"<p>Perf_events is based on event-based sampling. The period is expressed as the number of occurrences of an event, not the number of timer ticks. A sample is recorded when the sampling counter overflows, i.e., wraps from 2^64 back to 0. No PMU implements 64-bit hardware counters, but perf_events emulates such counters in software.</p> <p>The way perf_events emulates 64-bit counter is limited to expressing sampling periods using the number of bits in the actual hardware counters. If this is smaller than 64, the kernel silently truncates the period in this case. Therefore, it is best if the period is always smaller than 2^31 if running on 32-bit systems.</p> <p>On counter overflow, the kernel records information, i.e., a sample, about the execution of the program. What gets recorded depends on the type of measurement. This is all specified by the user and the tool. But the key information that is common in all samples is the instruction pointer, i.e. where was the program when it was interrupted.</p> <p>Interrupt-based sampling introduces skids on modern processors. That means that the instruction pointer stored in each sample designates the place where the program was interrupted to process the PMU interrupt, not the place where the counter actually overflows, i.e., where it was at the end of the sampling period. In some case, the distance between those two points may be several dozen instructions or more if there were taken branches. When the program cannot make forward progress, those two locations are indeed identical. For this reason, care must be taken when interpreting profiles.</p>"},{"location":"tutorial/#default-event-cycle-counting","title":"Default event: cycle counting","text":"<p>By default, <code>perf record</code> uses the <code>cycles</code> event as the sampling event. This is a generic hardware event that is mapped to a hardware-specific PMU event by the kernel. For Intel, it is mapped to <code>UNHALTED_CORE_CYCLES</code>. This event does not maintain a constant correlation to time in the presence of CPU frequency scaling. Intel provides another event, called <code>UNHALTED_REFERENCE_CYCLES</code> but this event is NOT currently available with perf_events.</p> <p>On AMD systems, the event is mapped to <code>CPU_CLK_UNHALTED</code> and this event is also subject to frequency scaling. On any Intel or AMD processor, the <code>cycle</code> event does not count when the processor is idle, i.e., when it calls <code>mwait()</code>.</p>"},{"location":"tutorial/#period-and-rate","title":"Period and rate","text":"<p>The perf_events interface allows two modes to express the sampling period:</p> <ul> <li>the number of occurrences of the event (period)</li> <li>the average rate of samples/sec\u00a0(frequency)</li> </ul> <p>The <code>perf</code> tool defaults to the average rate. It is set to 1000Hz, or 1000 samples/sec. That means that the kernel is dynamically adjusting the sampling period to achieve the target average rate. The adjustment in period is reported in the raw profile data. In contrast, with the other mode, the sampling period is set by the user and does not vary between samples. There is currently no support for sampling period randomization.</p>"},{"location":"tutorial/#collecting-samples","title":"Collecting samples","text":"<p>By default, <code>perf record</code> operates in per-thread mode, with inherit mode enabled. The simplest mode looks as follows, when executing a simple program that busy loops:</p> <pre><code>perf record ./noploop 1\n\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.002 MB perf.data (~89 samples) ]\n</code></pre> <p>The example above collects samples for event <code>cycles</code> at an average target rate of 1000Hz. The resulting samples are saved into the <code>perf.data</code> file. If the file already existed, you may be prompted to pass <code>-f</code> to overwrite it. To put the results in a specific file, use the <code>-o</code> option.</p> <p>WARNING: The number of reported samples is only an estimate. It does not reflect the actual number of samples collected. The estimate is based on the number of bytes written to the <code>perf.data</code> file and the minimal sample size. But the size of each sample depends on the type of measurement. Some samples are generated by the counters themselves but others are recorded to support symbol correlation during post-processing, e.g., <code>mmap()</code> information.</p> <p>To get an accurate number of samples for the <code>perf.data</code> file, it is possible to use the <code>perf report</code> command:</p> <pre><code>perf record ./noploop 1\n\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.058 MB perf.data (~2526 samples) ]\nperf report -D -i perf.data | fgrep RECORD_SAMPLE | wc -l\n\n1280\n\n</code></pre> <p>To specify a custom rate, it is necessary to use the <code>-F</code> option. For instance, to sample on event <code>instructions</code> only at the user level and  at an average rate of 250 samples/sec:</p> <pre><code>perf record -e instructions:u -F 250 ./noploop 4\n\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.049 MB perf.data (~2160 samples) ]\n\n</code></pre> <p>To specify a sampling period, instead, the <code>-c</code> option must be used. For instance, to collect a sample every 2000 occurrences of event <code>instructions</code>  only at the user level only:</p> <pre><code>perf record -e retired_instructions:u -c 2000 ./noploop 4\n\n[ perf record: Woken up 55 times to write data ]\n[ perf record: Captured and wrote 13.514 MB perf.data (~590431 samples) ]\n</code></pre>"},{"location":"tutorial/#processor-wide-mode_1","title":"Processor-wide mode","text":"<p>In per-cpu mode mode,  samples are collected for all threads executing on the monitored CPU. To switch <code>perf record</code> in per-cpu mode, the <code>-a</code> option must be used.  By default in this mode, ALL online CPUs are monitored. It is possible to restrict to the a subset of CPUs using the <code>-C</code> option, as explained with <code>perf stat</code> above.</p> <p>To sample on <code>cycles</code> at both user and kernel levels for 5s on all CPUS with an average target rate of 1000 samples/sec:</p> <pre><code>perf record -a -F 1000 sleep 5\n\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.523 MB perf.data (~22870 samples) ]\n</code></pre>"},{"location":"tutorial/#flame-graph","title":"Flame Graph","text":"<p>FlameGraphs are a popular way to visualize stack traces and break down execution time. The perf tool supports natively generating flame graphs using the <code>perf script report flamegraph</code> command.</p> <pre><code>perf record -a -g -F 99 sleep 60\nperf script report flamegraph\ngoogle-chrome flamegraph.html\n</code></pre> <p>By default this creates a <code>flamegraph.html</code> file and the <code>google-chrome</code> command will load the file into your web browser. The visualization uses d3 and the relevant d3 files may need to be installed or downloaded on demand. If downloading is necessary then a prompt will appear to ensure perf doesn't create unprompted network traffic. The prompt can be disabled with the <code>--allow-download</code> option.</p>"},{"location":"tutorial/#firefox-profiler","title":"Firefox Profiler","text":"<p>Firefox profiler is a powerful tool developed by Mozilla to analyze and optimize the performance of web applications and websites. It allows developers to gain deep insights into the behaviour of their code and identify performance bottlenecks, making it an invaluable asset for web development and debugging. Here is the matrix channel for Firefox profiler discussion, you can reach out in case any doubt or issue arise.  One of the key components of the Firefox Profiler is the Gecko format. It is a specialized data format used to store performance data collected during the profiling process. The Gecko format is particularly beneficial because it offers a comprehensive and structured representation of performance data, enabling developers to visualize and interpret complex metrics in a more manageable way. Here is the sample_gecko_output generated by the gecko script. The gecko script is available under scripts/python directory:</p> <pre><code>perf script report gecko -h\nusage: perf script gecko [&lt;options&gt;] [&lt;command&gt;]\n[--user-colour]         Color for user category\n[--kernel-colour]       Color for kernel category\n[--save-only]           Save the output to a file\n\nCommands:\n\nperf script gecko -a sleep 60\n\nor \n\nperf record -a -g -F 99 sleep 60\nperf script report gecko \n\nNOTE: If you want to use command line args for gecko script then you need to use it as \"perf script report gecko [&lt;options&gt;]\"\n</code></pre> <p>If you're seeking to visualize the behaviour for a particular process, you have a couple of options:</p> <pre><code>perf record -p &lt;pid&gt;\nperf script report gecko\n\nor \n\n1. Run perf report\n2. Identify and select the specific process you're interested in.\n3. Opt to run a script for either the chosen process or all processes.\n</code></pre>"},{"location":"tutorial/#sample-analysis-with-perf-report","title":"Sample analysis with <code>perf report</code>","text":"<p>Samples collected by <code>perf record</code> are saved into a binary file called, by default, <code>perf.data</code>. The <code>perf report</code> command reads this file and generates a concise execution profile. By default, samples are sorted by functions with the most samples first. It is possible to customize the sorting order and therefore to view the data differently.</p> <pre><code>perf report\n\n# Events: 1K cycles\n#\n# Overhead          Command                   Shared Object  Symbol\n# ........  ...............  ..............................  .....................................\n#\n    28.15%      firefox-bin  libxul.so                       [.] 0xd10b45\n     4.45%          swapper  [kernel.kallsyms]               [k] mwait_idle_with_hints\n     4.26%          swapper  [kernel.kallsyms]               [k] read_hpet\n     2.13%      firefox-bin  firefox-bin                     [.] 0x1e3d\n     1.40%  unity-panel-ser  libglib-2.0.so.0.2800.6         [.] 0x886f1\n     [...]\n</code></pre> <p>The column 'Overhead' indicates the percentage of the overall samples collected in the corresponding function. The second column reports the process from which the samples were collected. In per-thread/per-process mode, this is always the name of the monitored command. But in cpu-wide mode, the command can vary. The third column shows the name of the ELF image where the samples came from.  If a program is dynamically linked, then this may show the name of a shared library. When the samples come from the kernel, then the pseudo ELF image name <code>[kernel.kallsyms]</code> is used. The fourth column indicates the privilege level at which the sample was taken, i.e. when the program was running when it was interrupted:</p> <ul> <li>[.] : user level</li> <li>[k]: kernel level</li> <li>[g]: guest kernel level (virtualization)</li> <li>[u]: guest os user space</li> <li></li> </ul> <p>The final column shows the symbol name.</p> <p>There are many different ways samples can be presented, i.e., sorted. To sort by shared objects, i.e., dsos:</p> <pre><code>perf report --sort=dso\n\n# Events: 1K cycles\n#\n# Overhead                   Shared Object\n# ........  ..............................\n#\n    38.08%  [kernel.kallsyms]\n    28.23%  libxul.so\n     3.97%  libglib-2.0.so.0.2800.6\n     3.72%  libc-2.13.so\n     3.46%  libpthread-2.13.so\n     2.13%  firefox-bin\n     1.51%  libdrm_intel.so.1.0.0\n     1.38%  dbus-daemon\n     1.36%  [drm]\n     [...]\n</code></pre>"},{"location":"tutorial/#options-controlling-output_1","title":"Options controlling output","text":"<p>To make the output easier to parse, it is possible to change the column separator to a single character:</p> <pre><code>perf report -t\n</code></pre>"},{"location":"tutorial/#options-controlling-kernel-reporting","title":"Options controlling kernel reporting","text":"<p>The <code>perf</code> tool does not know how to extract symbols form compressed kernel images (vmlinuz). Therefore, users must pass the path of the uncompressed kernel using the <code>-k</code> option:</p> <pre><code>perf report -k /tmp/vmlinux\n</code></pre> <p>Of course, this works only if the kernel is compiled to with debug symbols.</p>"},{"location":"tutorial/#processor-wide-mode_2","title":"Processor-wide mode","text":"<p>In per-cpu mode, samples are recorded from all threads running on the monitored CPUs. As as result, samples from many different processes may be collected. For instance, if we monitor across all CPUs for 5s:</p> <pre><code>perf record -a sleep 5\nperf report\n\n# Events: 354  cycles\n#\n# Overhead          Command               Shared Object  Symbol\n# ........  ...............  ..........................  ......................................\n#\n    13.20%          swapper  [kernel.kallsyms]           [k] read_hpet\n     7.53%          swapper  [kernel.kallsyms]           [k] mwait_idle_with_hints\n     4.40%    perf_2.6.38-8  [kernel.kallsyms]           [k] _raw_spin_unlock_irqrestore\n     4.07%    perf_2.6.38-8  perf_2.6.38-8               [.] 0x34e1b\n     3.88%    perf_2.6.38-8  [kernel.kallsyms]           [k] format_decode\n     [...]\n</code></pre> <p>When the symbol is printed as an hexadecimal address, this is because the ELF image does not have a symbol table. This happens when binaries are stripped. We can sort by cpu as well. This could be useful to determine if the workload is well balanced:</p> <pre><code>perf report --sort=cpu\n\n# Events: 354  cycles\n#\n# Overhead  CPU\n# ........  ...\n#\n   65.85%  1\n   34.15%  0\n</code></pre>"},{"location":"tutorial/#overhead-calculation","title":"Overhead calculation","text":"<p>The overhead can be shown in two columns as 'Children' and 'Self' when perf collects callchains.  The 'self' overhead is simply calculated by adding all period values of the entry - usually a function (symbol). This is the value that perf shows traditionally and sum of all the 'self' overhead values should be 100%.</p> <p>The 'children' overhead is calculated by adding all period values of the child functions so that it can show the total overhead of the higher level functions even if they don't directly execute much. 'Children' here means functions that are called from another (parent) function.</p> <p>It might be confusing that the sum of all the 'children' overhead values exceeds 100% since each of them is already an accumulation of 'self' overhead of its child functions.  But with this enabled, users can find which function has the most overhead even if samples are spread over the children.</p> <p>Consider the following example; there are three functions like below.</p> <pre><code>void foo(void) {\n    /* do something */\n}\n\nvoid bar(void) {\n    /* do something */\n    foo();\n}\n\nint main(void) {\n    bar()\n    return 0;\n}\n</code></pre> <p>In this case 'foo' is a child of 'bar', and 'bar' is an immediate child of 'main' so 'foo' also is a child of 'main'.  In other words, 'main' is a parent of 'foo' and 'bar', and 'bar' is a parent of 'foo'.</p> <p>Suppose all samples are recorded in 'foo' and 'bar' only.  When it's recorded with callchains the output will show something like below in the usual (self-overhead-only) output of perf report:</p> <pre><code>Overhead  Symbol\n........  .....................\n  60.00%  foo\n          |\n          --- foo\n              bar\n              main\n              __libc_start_main\n\n  40.00%  bar\n          |\n          --- bar\n              main\n              __libc_start_main\n</code></pre> <p>When the --children option is enabled, the 'self' overhead values of child functions (i.e. 'foo' and 'bar') are added to the parents to calculate the 'children' overhead.  In this case the report could be displayed as:</p> <pre><code>Children      Self  Symbol\n........  ........  ....................\n 100.00%     0.00%  __libc_start_main\n          |\n          --- __libc_start_main\n\n 100.00%     0.00%  main\n          |\n          --- main\n              __libc_start_main\n\n 100.00%    40.00%  bar\n          |\n          --- bar\n              main\n              __libc_start_main\n\n  60.00%    60.00%  foo\n          |\n          --- foo\n              bar\n              main\n              __libc_start_main\n</code></pre> <p>In the above output, the 'self' overhead of 'foo' (60%) was add to the 'children' overhead of 'bar', 'main' and '__libc_start_main'. Likewise, the 'self' overhead of 'bar' (40%) was added to the 'children' overhead of 'main' and '__libc_start_main'.</p> <p>So '__libc_start_main' and 'main' are shown first since they have same (100%) 'children' overhead (even though they have zero 'self' overhead) and they are the parents of 'foo' and 'bar'.</p> <p>Since v3.16 the 'children' overhead is shown by default and the output is sorted by its values. The 'children' overhead is disabled by specifying --no-children option on the command line or by adding 'report.children = false' or 'top.children = false' in the perf config file.</p>"},{"location":"tutorial/#source-level-analysis-with-perf-annotate","title":"Source level analysis with <code>perf annotate</code>","text":"<p>It is possible to drill down to the instruction level with <code>perf annotate</code>. For that, you need to invoke <code>perf annotate</code> with the name of the command to annotate. All the functions with samples will be disassembled and each instruction will have its relative percentage of samples reported:</p> <pre><code>perf record ./noploop 5\nperf annotate -d ./noploop\n\n------------------------------------------------\n Percent |   Source code &amp; Disassembly of noploop.noggdb\n------------------------------------------------\n         :\n         :\n         :\n         :   Disassembly of section .text:\n         :\n         :   08048484 &lt;main&gt;:\n    0.00 :    8048484:       55                      push   %ebp\n    0.00 :    8048485:       89 e5                   mov    %esp,%ebp\n[...]\n    0.00 :    8048530:       eb 0b                   jmp    804853d &lt;main+0xb9&gt;\n   15.08 :    8048532:       8b 44 24 2c             mov    0x2c(%esp),%eax\n    0.00 :    8048536:       83 c0 01                add    $0x1,%eax\n   14.52 :    8048539:       89 44 24 2c             mov    %eax,0x2c(%esp)\n   14.27 :    804853d:       8b 44 24 2c             mov    0x2c(%esp),%eax\n   56.13 :    8048541:       3d ff e0 f5 05          cmp    $0x5f5e0ff,%eax\n    0.00 :    8048546:       76 ea                   jbe    8048532 &lt;main+0xae&gt;\n[...]\n</code></pre> <p>The first column reports the percentage of samples for function ==noploop()== captured for at that instruction. As explained earlier, you should interpret this information carefully.</p> <p><code>perf annotate</code> can generate sourcecode level information if the application is compiled with <code>-ggdb</code>. The following snippet shows the much more informative output for the same execution of <code>noploop</code> when compiled with this debugging information.</p> <pre><code>------------------------------------------------\n Percent |   Source code &amp; Disassembly of noploop\n------------------------------------------------\n         :\n         :\n         :\n         :   Disassembly of section .text:\n         :\n         :   08048484 &lt;main&gt;:\n         :   #include &lt;string.h&gt;\n         :   #include &lt;unistd.h&gt;\n         :   #include &lt;sys/time.h&gt;\n         :\n         :   int main(int argc, char **argv)\n         :   {\n    0.00 :    8048484:       55                      push   %ebp\n    0.00 :    8048485:       89 e5                   mov    %esp,%ebp\n[...]\n    0.00 :    8048530:       eb 0b                   jmp    804853d &lt;main+0xb9&gt;\n         :                           count++;\n   14.22 :    8048532:       8b 44 24 2c             mov    0x2c(%esp),%eax\n    0.00 :    8048536:       83 c0 01                add    $0x1,%eax\n   14.78 :    8048539:       89 44 24 2c             mov    %eax,0x2c(%esp)\n         :           memcpy(&amp;tv_end, &amp;tv_now, sizeof(tv_now));\n         :           tv_end.tv_sec += strtol(argv[1], NULL, 10);\n         :           while (tv_now.tv_sec &lt; tv_end.tv_sec ||\n         :                  tv_now.tv_usec &lt; tv_end.tv_usec) {\n         :                   count = 0;\n         :                   while (count &lt; 100000000UL)\n   14.78 :    804853d:       8b 44 24 2c             mov    0x2c(%esp),%eax\n   56.23 :    8048541:       3d ff e0 f5 05          cmp    $0x5f5e0ff,%eax\n    0.00 :    8048546:       76 ea                   jbe    8048532 &lt;main+0xae&gt;\n[...]\n</code></pre>"},{"location":"tutorial/#using-perf-annotate-on-kernel-code","title":"Using <code>perf annotate</code> on kernel code","text":"<p>The <code>perf</code> tool does not know how to extract symbols from compressed kernel images (vmlinuz). As in the case of <code>perf report</code>, users must pass the path of the uncompressed kernel using the <code>-k</code> option:</p> <pre><code>perf annotate -k /tmp/vmlinux -d symbol\n</code></pre> <p>Again, this only works if the kernel is compiled to with debug symbols.</p>"},{"location":"tutorial/#live-analysis-with-perf-top","title":"Live analysis with <code>perf top</code>","text":"<p>The perf tool can operate in a mode similar to the Linux <code>top</code> tool, printing sampled functions in real time. The default sampling event is <code>cycles</code> and default order is descending number of samples per symbol, thus <code>perf top</code> shows the functions where most of the time is spent. By default, <code>perf top</code> operates in processor-wide mode, monitoring all online CPUs at both user and kernel levels. It is possible to monitor only a subset of the CPUS using the <code>-C</code> option.</p> <pre><code>perf top\n-------------------------------------------------------------------------------------------------------------------------------------------------------\n  PerfTop:     260 irqs/sec  kernel:61.5%  exact:  0.0% [1000Hz\ncycles],  (all, 2 CPUs)\n-------------------------------------------------------------------------------------------------------------------------------------------------------\n\n            samples  pcnt function                       DSO\n            _______ _____ ______________________________ ___________________________________________________________\n\n              80.00 23.7% read_hpet                      [kernel.kallsyms]\n              14.00  4.2% system_call                    [kernel.kallsyms]\n              14.00  4.2% __ticket_spin_lock             [kernel.kallsyms]\n              14.00  4.2% __ticket_spin_unlock           [kernel.kallsyms]\n               8.00  2.4% hpet_legacy_next_event         [kernel.kallsyms]\n               7.00  2.1% i8042_interrupt                [kernel.kallsyms]\n               7.00  2.1% strcmp                         [kernel.kallsyms]\n               6.00  1.8% _raw_spin_unlock_irqrestore    [kernel.kallsyms]\n               6.00  1.8% pthread_mutex_lock             /lib/i386-linux-gnu/libpthread-2.13.so\n               6.00  1.8% fget_light                     [kernel.kallsyms]\n               6.00  1.8% __pthread_mutex_unlock_usercnt /lib/i386-linux-gnu/libpthread-2.13.so\n               5.00  1.5% native_sched_clock             [kernel.kallsyms]\n               5.00  1.5% drm_addbufs_sg                 /lib/modules/2.6.38-8-generic/kernel/drivers/gpu/drm/drm.ko\n</code></pre> <p>By default, the first column shows the aggregated number of samples since the beginning of the run. By pressing the 'Z' key, this can be changed to print the number of samples since the last refresh. Recall that the <code>cycle</code> event counts CPU cycles when the processor is not in halted state, i.e. not idle. Therefore this is not equivalent to wall clock time. Furthermore, the event is also subject to frequency scaling.</p> <p>It is also possible to drill down into single functions to see which instructions have the most samples. To drill down into a specify function, press the 's' key and enter the name of the function. Here we selected the top function <code>noploop</code> (not shown above):</p> <pre><code>------------------------------------------------------------------------------------------------------------------------------------------\n   PerfTop:    2090 irqs/sec  kernel:50.4%  exact:  0.0% [1000Hz cycles],  (all, 16 CPUs)\n------------------------------------------------------------------------------------------------------------------------------------------\nShowing cycles for noploop\n  Events  Pcnt (&gt;=5%)\n       0  0.0%   00000000004003a1 &lt;noploop&gt;:\n       0  0.0%     4003a1:   55                      push   %rbp\n       0  0.0%     4003a2:   48 89 e5                mov    %rsp,%rbp\n    3550 100.0%    4003a5:   eb fe                   jmp    4003a5 &lt;noploop+0x4&gt;\n\n</code></pre>"},{"location":"tutorial/#benchmarking-with-perf-bench","title":"Benchmarking with <code>perf bench</code>","text":"<p>The <code>perf bench</code> command includes a number of multi-threaded microbenchmarks to exercise different subsystems in the Linux kernel and system calls. This allows hackers to easily stress and measure the impact of changes, and therefore help mitigate performance regressions.</p> <p>It also serves as a general benchmark framework, enabling developers to easily create test cases and transparently integrate and make use of the rich perf tool subsystem.</p>"},{"location":"tutorial/#sched-scheduler-benchmarks","title":"sched: Scheduler benchmarks","text":"<p>Measures <code>pipe(2)</code> and <code>socketpair(2)</code> operations between multiple tasks. Allows the measurement of thread versus process context switch performance.</p> <pre><code>$perf bench sched messaging -g 64\n# Running 'sched/messaging' benchmark:\n# 20 sender and receiver processes per group\n# 64 groups == 2560 processes run\n\n     Total time: 1.549 [sec]\n</code></pre>"},{"location":"tutorial/#mem-memory-access-benchmarks","title":"mem: Memory access benchmarks","text":""},{"location":"tutorial/#numa-numa-scheduling-and-mm-benchmarks","title":"numa: NUMA scheduling and MM benchmarks","text":""},{"location":"tutorial/#futex-futex-stressing-benchmarks","title":"futex: Futex stressing benchmarks","text":"<p>Deals with finer grained aspects of the kernel's implementation of futexes. It is mostly  useful for kernel hacking. It currently supports wakeup and requeue/wait operations, as  well as stressing the hashing scheme for both private and shared futexes. An example run for nCPU threads, each handling 1024 futexes measuring the hashing logic:</p> <pre><code>$ perf bench futex hash\n# Running 'futex/hash' benchmark:\nRun summary [PID 17428]: 4 threads, each operating on 1024 [private] futexes for 10 secs.\n\n[thread  0] futexes: 0x2775700 ... 0x27766fc [ 3343462 ops/sec ]\n[thread  1] futexes: 0x2776920 ... 0x277791c [ 3679539 ops/sec ]\n[thread  2] futexes: 0x2777ab0 ... 0x2778aac [ 3589836 ops/sec ]\n[thread  3] futexes: 0x2778c40 ... 0x2779c3c [ 3563827 ops/sec ]\n\nAveraged 3544166 operations/sec (+- 2.01%), total secs = 10\n</code></pre>"},{"location":"tutorial/#troubleshooting-and-tips","title":"Troubleshooting and Tips","text":"<p>This section lists a number of tips to avoid common pitfalls when using perf.</p>"},{"location":"tutorial/#open-file-limits","title":"Open file limits","text":"<p>The design of the perf_event kernel interface which is used by the perf tool, is such  that it uses one file descriptor per event per-thread or per-cpu.</p> <p>On a 16-way system, when you do:</p> <pre><code>perf stat -e cycles sleep 1\n</code></pre> <p>You are effectively creating 16 events, and thus consuming 16 file descriptors.</p> <p>In per-thread mode, when you are sampling a process with 100 threads on the same 16-way system:</p> <pre><code>perf record -e cycles my_hundred_thread_process\n</code></pre> <p>Then, once all the threads are created, you end up with 100 * 1 (event) * 16 (cpus) = 1600 file descriptors. Perf creates one instance of the event on each CPU. Only when the thread executes on that CPU does the event effectively measure. This approach enforces sampling buffer locality and thus mitigates sampling overhead. At the end of the run, the tool aggregates all the samples into a single output file.</p> <p>In case perf aborts with 'too many open files' error, there are a few solutions:</p> <ul> <li>increase the number of per-process open files using ulimit -n. Caveat: you must be root</li> <li>limit the number of events you measure in one run</li> <li>limit the number of CPU you are measuring</li> </ul>"},{"location":"tutorial/#increasing-open-file-limit","title":"increasing open file limit","text":"<p>The superuser can override the per-process open file limit using the <code>ulimit</code> shell builtin command:</p> <pre><code>ulimit -a\n[...]\nopen files                      (-n) 1024\n[...]\n\nulimit -n 2048\nulimit -a\n[...]\nopen files                      (-n) 2048\n[...]\n</code></pre>"},{"location":"tutorial/#binary-identification-with-build-id","title":"Binary identification with <code>build-id</code>","text":"<p>The <code>perf record</code> command saves in the <code>perf.data</code> unique identifiers for all ELF images relevant to the measurement. In per-thread mode, this includes all the ELF images of the monitored processes. In cpu-wide mode, it includes all running processes running on the system. Those unique identifiers are generated by the linker if the <code>-Wl,--build-id</code> option is used. Thus, they are called <code>build-id</code>. The <code>build-id</code> are a helpful tool when correlating instruction addresses to ELF images. To extract all <code>build-id</code> entries used in a <code>perf.data</code> file, issue:</p> <pre><code>perf buildid-list -i perf.data\n\n06cb68e95cceef1ff4e80a3663ad339d9d6f0e43 [kernel.kallsyms]\ne445a2c74bc98ac0c355180a8d770cd35deb7674 /lib/modules/2.6.38-8-generic/kernel/drivers/gpu/drm/i915/i915.ko\n83c362c95642c3013196739902b0360d5cbb13c6 /lib/modules/2.6.38-8-generic/kernel/drivers/net/wireless/iwlwifi/iwlcore.ko\n1b71b1dd65a7734e7aa960efbde449c430bc4478 /lib/modules/2.6.38-8-generic/kernel/net/mac80211/mac80211.ko\nae4d6ec2977472f40b6871fb641e45efd408fa85 /lib/modules/2.6.38-8-generic/kernel/drivers/gpu/drm/drm.ko\nfafad827c43e34b538aea792cc98ecfd8d387e2f /lib/i386-linux-gnu/ld-2.13.so\n0776add23cf3b95b4681e4e875ba17d62d30c7ae /lib/i386-linux-gnu/libdbus-1.so.3.5.4\nf22f8e683907b95384c5799b40daa455e44e4076 /lib/i386-linux-gnu/libc-2.13.so\n[...]\n</code></pre>"},{"location":"tutorial/#the-build-id-cache","title":"The <code>build-id</code> cache","text":"<p>At the end of each run, the <code>perf record</code> command updates a <code>build-id</code> cache, with new entries for ELF images with samples. The cache contains:</p> <ul> <li><code>build-id</code> for ELF images with samples</li> <li>copies of the ELF images with samples</li> </ul> <p>Given  that <code>build-id</code> are immutable, they uniquely identify a binary. If a binary is recompiled, a new <code>build-id</code> is generated and a new copy of the ELF images is saved in the cache. The cache is saved on disk in a directory which is by default $HOME/.debug. There is a global configuration file <code>/etc/perfconfig</code> which can be used by sysadmin to specify an alternate global directory for the cache:</p> <pre><code>$ cat /etc/perfconfig\n[buildid]\ndir = /var/tmp/.debug\n</code></pre> <p>In certain situations it may be beneficial to turn off the <code>build-id</code> cache updates altogether. For that, you must pass the <code>-N</code> option to <code>perf record</code></p> <pre><code>perf record -N dd if=/dev/zero of=/dev/null count=100000\n</code></pre>"},{"location":"tutorial/#access-control","title":"Access Control","text":"<p>For some events, it is necessary to be <code>root</code> to invoke the <code>perf</code> tool. This document assumes that the user has root privileges. If you try to run perf with insufficient privileges, it will report</p> <pre><code>No permission to collect system-wide stats.\n</code></pre>"},{"location":"tutorial/#other-scenarios","title":"Other Scenarios","text":""},{"location":"tutorial/#profiling-sleep-times","title":"Profiling sleep times","text":"<p>This feature shows where and how long a program is sleeping or waiting something.</p> <p>The first step is collecting data. We need to collect sched_stat and sched_switch events. Sched_stat events are not enough, because they are generated in the context  of a task, which wakes up a target task (e.g. releases a lock). We need the same event but with a call-chain of the target task. This call-chain can be extracted from a previous sched_switch event.</p> <p>The second step is merging sched_start and sched_switch events. It can be done with help of \"perf inject -s\".</p> <pre><code> $ ./perf record -e sched:sched_stat_sleep -e sched:sched_switch  -e sched:sched_process_exit -g -o ~/perf.data.raw ~/foo\n $ ./perf inject -v -s -i ~/perf.data.raw -o ~/perf.data\n $ ./perf report --stdio --show-total-period -i ~/perf.data\n # Overhead        Period  Command      Shared Object          Symbol\n # ........  ............  .......  .................  ..............\n #\n   100.00%     502408738      foo  [kernel.kallsyms]  [k] __schedule\n                |\n                --- __schedule\n                    schedule\n                   |          \n                   |--79.85%-- schedule_hrtimeout_range_clock\n                   |          schedule_hrtimeout_range\n                   |          poll_schedule_timeout\n                   |          do_select\n                   |          core_sys_select\n                   |          sys_select\n                   |          system_call_fastpath\n                   |          __select\n                   |          __libc_start_main\n                   |          \n                    --20.15%-- do_nanosleep\n                              hrtimer_nanosleep\n                              sys_nanosleep\n                              system_call_fastpath\n                              __GI___libc_nanosleep\n                              __libc_start_main\n\n $cat foo.c\n ...\n           for (i = 0; i &lt;  10; i++) {\n                   ts1.tv_sec = 0;\n                   ts1.tv_nsec = 10000000;\n                   nanosleep(&amp;ts1, NULL);\n\n                   tv1.tv_sec = 0;\n                   tv1.tv_usec = 40000;\n                   select(0, NULL, NULL, NULL,&amp;tv1);\n           }\n ...\n</code></pre>"},{"location":"tutorial/#other-resources","title":"Other Resources","text":""},{"location":"tutorial/#linux-sourcecode","title":"Linux sourcecode","text":"<p>The perf tools sourcecode lives in the Linux kernel tree under <code>/tools/perf</code>. You will find much more documentation in <code>/tools/perf/Documentation</code>. To build manpages, info pages and more, install these tools:</p> <ul> <li>asciidoc</li> <li>tetex-fonts</li> <li>tetex-dvips</li> <li>dialog</li> <li>tetex</li> <li>tetex-latex</li> <li>xmltex</li> <li>passivetex</li> <li>w3m</li> <li>xmlto</li> </ul> <p>and issue a <code>make install-man</code> from <code>/tools/perf</code>. This step is also required to  be able to run <code>perf help &lt;command&gt;</code>.</p> <p>This guide is adapted from a tutorial by Stephane Eranian at Google, with contributions from Eric Gouriou, Tipp Moseley and Willem de Bruijn. The original content imported into wiki.perf.google.com is made available under the CreativeCommons attribution sharealike 3.0 license.</p>"},{"location":"useful-links/","title":"Useful web sites about the Linux perf tools","text":"<ul> <li>Julia Evans' Profiling &amp; tracing with perf zine</li> <li>Brendan Gregg's perf examples</li> <li>Wikipedia</li> <li>Franck Pachot's not so basic perf top tutorial \"Linux perf-top basics: understand the %\"</li> <li>Frank Pachot help going from 'time' to 'perf stat' while analysing database performance on \"Should CPU-intensive logic be done in the DB or in application server?\"</li> <li>Ankur Arora uses perf and pahole to investigate \"Syscall latency... and some uses of speculative execution\"</li> <li>Leo Yan on supporting 'perf c2c' on Armv8.2 \"Using the Arm Statistical Profiling Extension to detect false cache-line sharing\"</li> <li>Mark Dawson, Jr. uses 'perf diff' on \"5-level vs 4-level Page Tables: Does It Matter?\"</li> <li>Joe Mario's original 2016 article about 'perf c2c' \"C2C - False Sharing Detection in Linux Perf\"</li> <li>Paul Clarke reimplements AIX's 'curt' command using perf python scripting support, detailing the whole process on \"How to analyze your system with perf and Python\"</li> <li>Viacheslav Biriukov mentions using perf to get more info about page cache activity in the \"Advanced tools\" section in his \"SRE deep dive into Linux Page Cache\" series of articles</li> <li>Filip Busic uses perf and other BPF tools in \"Examining Problematic Memory in C/C++ Applications with BPF, perf, and Memcheck\"</li> <li>(French) Hadrien Grasland's perf tutorial (designed to be run on a specific system, but could be adapted to self-study without too much effort)</li> <li>Leo Yan, Perf Ring Buffer</li> <li>Leo Yan Debugging perf with perf</li> <li>Paul Clarke helps transitioning from OProfile to perf</li> <li>Timed Process Event Based Sampling</li> </ul>"},{"location":"useful-links/#useful-web-sites-about-profilers","title":"Useful web sites about profilers","text":"<ul> <li>ProfilerPedia A map of the Software Profiling Ecosystem</li> <li>OProfile</li> </ul>"},{"location":"useful-links/#presentations","title":"Presentations","text":"<ul> <li>Improving the Perf event subsystem after 15 years Ian Rogers, LPC September 2024</li> <li>Utilizing type info in the perf tools Namhyung Kim, LPC September 2024</li> <li>Linux perf tool metrics Ian Rogers, Weilin Wang, LPC November 2023</li> <li>Towards data type profiling Namhyung Kim, LPC November 2023</li> <li>Easyperf Twitter Spaces with Arnaldo Carvalho de Melo and Denis Bakhvalov October 2021</li> <li>Integration Arm SPE in Perf for Memory Profiling Spring 2021</li> <li>Stephane Eranian's keynote at SuperComputing ProTools 2019: Hardware Performance Monitoring Landscape</li> <li>Chandler Carruth \"Tuning C++: Benchmarks, and CPUs, and Compilers! Oh My!\"</li> <li>Roberto Vitillo's presentation on Perf events June 2011</li> </ul>"},{"location":"useful-links/#in-the-press","title":"In the press","text":"<ul> <li>Discovery/analysis of <code>libxz</code> backdoor with <code>perf record -e intel_pt//ub</code> by the discoverer Andres Freund.</li> </ul>"},{"location":"white-paper/","title":"White paper","text":""},{"location":"white-paper/#introduction","title":"Introduction","text":"<p>This page provides various documentation for perf tool. It's under construction forever.</p>"},{"location":"white-paper/#code-trees","title":"Code trees","text":"<p>If not state otherwise all features code described in here is based on:</p> <pre><code>git://git.kernel.org/pub/scm/linux/kernel/git/jolsa/perf.git\n\nperf/core branch\n</code></pre> <p>which is regularly based/synced on Arnaldo's tree:</p> <pre><code>git://git.kernel.org/pub/scm/linux/kernel/git/acme/linux (fetch)\n\nperf/core branch\n</code></pre>"},{"location":"white-paper/#docs","title":"Docs","text":"<ul> <li>events</li> <li>counting explained</li> <li>sampling explained</li> <li>diff explained</li> <li>annotations explained</li> <li>jolsa_Docs_FileFormat</li> <li>join perf developement</li> </ul>"},{"location":"white-paper/#commands","title":"Commands","text":"<ul> <li>perf stat</li> <li>perf record</li> <li>perf report</li> <li>perf diff</li> </ul>"},{"location":"white-paper/#tests","title":"Tests","text":"<ul> <li>tests explained - how to run/create tests</li> <li>auto test framework - automatic compile/run test</li> </ul>"},{"location":"white-paper/#howtos","title":"Howtos","text":"<ul> <li>install perf package</li> <li>install perf from sources</li> <li>measure child functions cycles - measure child functions cycles by parent</li> </ul>"},{"location":"white-paper/#features","title":"Features","text":""},{"location":"white-paper/#merged","title":"Merged","text":"<ul> <li>post DWARF unwind - callchains DWARF unwind</li> <li>group sampling - group leader sampling</li> <li>multi diff - diff multiple files</li> </ul>"},{"location":"white-paper/#to-be-done","title":"To be done","text":"<ul> <li>multiple file storage - allow to store record data into multiple files</li> <li>cpu hotplug - follow cpu hotplug in perf record</li> <li>stat formulas - formulas support over perf stat</li> <li>precise - precise level detection</li> <li>kbuild - kernel kbuild support</li> <li>mmap details - report mmap details</li> <li>top data file - store top data into data file</li> <li>nonarchitectural event - nonarchitectural event specification</li> <li>data file merge - merge data files by time</li> <li>toggle event - run event on another event sample</li> </ul>"},{"location":"white-paper/#contact","title":"Contact","text":"<ul> <li><code>Jiri Olsa &lt;jolsa at redhat dot com&gt;</code></li> </ul>"}]}